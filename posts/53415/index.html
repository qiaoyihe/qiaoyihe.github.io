<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="一个记录学习笔记的地方!"><meta name="keywords" content="乔一禾,乔一禾博客,乔一禾小栈,记录笔记,记录生活,一个记录学习笔记的地方"><meta name="baidu-site-verification" content="code-R94JrErUi4"><meta name="google-site-verification" content="4QDNjHNosTV6vHQUGRmOXJxh93YkUVa8O5gazOhA9Bs"><title> java入门阶级,每个 Java 初学者都应该收藏 | 乔一禾</title><link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/libs/prism/prism.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?654a00ff7065288ed384e9912b0b6e36";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-E8J9N4Q74X"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-E8J9N4Q74X")</script><script src="/js/link.js"></script><script src="/js/search/jQuery.js"></script><script src="/js/search/search.js"></script><script type="text/javascript">var search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path;searchFunc(path,"local-search-input","local-search-result")</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="乔一禾" type="application/atom+xml"></head><body><header class="clearfix"><div class="headnav wrapper"><div class="logo"><h1> <a href="https://www.isqqq.com">乔一禾</a></h1></div><div class="nav"><div class="search"><div class="local-search"><div class="d-flex local-search-div"> <input id="local-search-input" class="form-control me-2 pe-4" type="search" placeholder="搜索" aria-label="Search"></div> <button class="local-button iconfont icon-sousuo-copy"></button></div><div class="local-search-content"><div class="col-md-8"><div class="markdown-section"><div id="local-search-result"></div></div></div></div></div><div class="header-nav-items"><div class="header-nav-item"> <a href="javascript:void(0)" rel="external nofollow noreferrer" class="header-nav-page"><span>文章</span></a><ul class="header-nav-item-child"><li><a href="/tags/">标签</a></li><li><a href="/archives/">归档</a></li><li><a href="/categories/">分类</a></li></ul></div><div class="header-nav-item"> <a href="javascript:void(0)" rel="external nofollow noreferrer" class="header-nav-page"><span>社交</span></a><ul class="header-nav-item-child"><li><a href="/link/">小伙伴</a></li><li><a href="/about/">关于我</a></li><li><a href="/messageboard">留言板</a></li></ul></div><div class="header-nav-item"> <a href="javascript:void(0)" rel="external nofollow noreferrer" class="header-nav-page"><span>其他</span></a><ul class="header-nav-item-child"><li><a href="/talk/">说说</a></li><li><a href="/photo/">My相册</a></li><li><a href="/">待添加</a></li></ul></div><div class="iconfont icon-fenlei header-nav-fenlei"></div></div></div></div></header><div class="sidebar"><div class="sidebar-bg"></div><div class="sidebar-content"><div class="sidebar-banner"><div class="sidenar-avatar"> <img src="/img/avtar.webp" alt="" id="sidenar-img"></div><div class="sidenar-name">乔一禾</div><div class="sidenar-site"><div class="sidenar-statis"><a href="https://www.isqqq.com"><div>文章</div><div> 12</div></a><a href="/categories/"><div>分类</div><div> 5</div></a><a href="/tags/"><div>标签</div><div> 9</div></a></div></div></div><div class="sidenat-items"><div id="menu"> <a href="javascript::" rel="external nofollow noreferrer"><span>文章</span></a><ul><li><a href="/tags/">标签</a></li><li><a href="/archives/">归档</a></li><li><a href="/categories/">分类</a></li></ul></div><div id="menu"> <a href="javascript::" rel="external nofollow noreferrer"><span>社交</span></a><ul><li><a href="/link/">小伙伴</a></li><li><a href="/about/">关于我</a></li><li><a href="/messageboard">留言板</a></li></ul></div><div id="menu"> <a href="javascript::" rel="external nofollow noreferrer"><span>其他</span></a><ul><li><a href="/talk/">说说</a></li><li><a href="/photo/">My相册</a></li><li><a href="/">待添加</a></li></ul></div></div></div></div><div class="clearfix content wrapper post-"><div class="left"><div class="post-item-post"><h2 class="post-item-title">java入门阶级,每个 Java 初学者都应该收藏</h2><hr><div class="post-meta"><div class="meta-firstline"> <span>发表于<i>2020-07-13</i></span> | <span>更新于<i>2023-03-01</i></span></div></div><div class="meta-secondline"> <span>字数总计: <i>56k</i></span> | <span>阅读时长: <i>2:20</i></span> | <span>阅读量:<i id="busuanzi_value_page_pv"></i></span></div><div class="post-outdate-notice"><div class="post-outdate-notice1"> <span>这篇文章已经发表了</span> 33 <span>天了，其中某些内容可能已经过时。</span></div></div><article class="post-content"><p>这么说吧，在我眼里，Java 就是最流行的编程语言，没有之一（PHP 往一边站）。不仅岗位多，容易找到工作，关键是薪资水平也到位，不学 Java 亏得慌，对吧？<br>那可能零基础学编程的小伙伴就会头疼了，网上关于 Java 的大部分技术文章都不够幽默，不够风趣，不够系列，急需要一份能看得进去的学习手册，那我觉得我肝的这份手册正好符合要求，并且会一直持续更新下去。<br>第一版的内容暂时包含两方面，Java 基础和 Java 面向对象编程。来吧，先上目录，一睹为快。<br>01、Java 基本语法简介<br>02、Java 基本数据类型简介<br>03、Java main() 方法简介<br>04、Java 的流程控制语句<br>05、Java 包的简介<br>06、Java 到底是值传递还是引用传递<br>07、Java 的类和对象<br>08、Java 构造方法<br>09、Java 抽象类<br>10、Java 接口<br>11、Java 继承<br>12、this 关键字<br>13、super 关键字<br>14、重写和重载<br>15、static 关键字<br>16、Java 枚举<br>17、final 关键字<br>目录欣赏完了，接下来就是拜读精华内容的时间，搬个小板凳，认认真真好好学吧，学到就是赚到！</p><h1 id="一、Java-基本语法简介"><a href="#一、Java-基本语法简介" class="headerlink" title="一、Java 基本语法简介"></a>一、Java 基本语法简介</h1><h2 id="01、数据类型"><a href="#01、数据类型" class="headerlink" title="01、数据类型"></a>01、数据类型</h2><p>Java 有 2 种数据类型，一种是基本数据类型，一种是引用类型。<br>基本数据类型用于存储简单类型的数据，比如说，int、long、byte、short 用于存储整数，float、double 用于存储浮点数，char 用于存储字符，boolean 用于存储布尔值。<br>不同的基本数据类型，有不同的默认值和大小，来个表格感受下。</p><table><thead><tr><th>数据类型</th><th>默认值</th><th>大小</th></tr></thead><tbody><tr><td>boolean</td><td>false</td><td>1比特</td></tr><tr><td>char</td><td>0</td><td>2字节</td></tr><tr><td>byte</td><td>0</td><td>1字节</td></tr><tr><td>short</td><td>0</td><td>2字节</td></tr><tr><td>int</td><td>0</td><td>4字节</td></tr><tr><td>long</td><td>0L</td><td>8字节</td></tr><tr><td>float</td><td>0.0f</td><td>4字节</td></tr><tr><td>double</td><td>0.0</td><td>8字节</td></tr></tbody></table><p>引用类型用于存储对象（null 表示没有值的对象）的引用，String 是引用类型的最佳代表，比如说 String cmower &#x3D; “沉默王二”。</p><h2 id="02、声明变量"><a href="#02、声明变量" class="headerlink" title="02、声明变量"></a>02、声明变量</h2><p>要声明一个变量，必须指定它的名字和类型，来看一个简单的示例：</p><pre><code class="line-numbers language-Java">int age;
String name;
</code></pre><p>count 和 name 在声明后会得到一个默认值，按照它们的数据类型——不能是局部变量（否则 Java 编译器会在你使用变量的时候提醒要先赋值），必须是类成员变量。</p><pre><code class="line-numbers language-Java">public class SyntaxLocalVariable &#123;
    int age;
    String name;

    public static void main(String[] args) &#123;
        SyntaxLocalVariable syntax = new SyntaxLocalVariable();
        System.out.println(syntax.age); // 输出 0
        System.out.println(syntax.name);  // 输出 null
    &#125;
&#125;
</code></pre><p>也可以在声明一个变量后使用“&#x3D;”操作符进行赋值，就像下面这样：</p><pre><code class="line-numbers language-Java">int age = 18;
String name = &quot;沉默王二&quot;;
</code></pre><p>我们定义了 2 个变量，int 类型的 age 和 String 类型的 name，age 赋值 18，name 赋值为“沉默王二”。<br>每行代码后面都跟了一个“;”，表示当前语句结束了。<br>在 Java 中，变量最好遵守命名约定，这样能提高代码的可阅读性。</p><ul><li>以字母、下划线（_）或者美元符号（$）开头</li><li>不能使用 Java 的保留字，比如说 int 不能作为变量名</li></ul><h2 id="03、数组"><a href="#03、数组" class="headerlink" title="03、数组"></a>03、数组</h2><p>数组在 Java 中占据着重要的位置，它是很多集合类的底层实现。数组属于引用类型，它用来存储一系列指定类型的数据。<br>声明数组的一般语法如下所示：</p><pre><code class="line-numbers language-Java">type[] identiier = new type[length];
</code></pre><p>type 可以是任意的基本数据类型或者引用类型。来看下面这个例子：</p><pre><code class="line-numbers language-Java">public class ArraysDemo &#123;
    public static void main(String[] args) &#123;
        int [] nums = new int[10];
        nums[0] = 18;
        nums[1] = 19;
        System.out.println(nums[0]);
    &#125;
&#125;
</code></pre><p>数组的索引从 0 开始，第一个元素的索引为 0，第二个元素的索引为 1。为什么要这样设计？感兴趣的话，你可以去探究一下。<br>通过变量名[索引]的方式可以访问数组指定索引处的元素，赋值或者取值是一样的。</p><h2 id="04、关键字"><a href="#04、关键字" class="headerlink" title="04、关键字"></a>04、关键字</h2><p>关键字属于保留字，在 Java 中具有特殊的含义，比如说 public、final、static、new 等等，它们不能用来作为变量名。为了便于你作为参照，我列举了 48 个常用的关键字，你可以瞅一瞅。</p><p>1： abstract： abstract 关键字用于声明抽象类——可以有抽象和非抽象方法。</p><p>2： boolean： boolean 关键字用于将变量声明为布尔值类型，它只有 true 和 false 两个值。</p><p>3： break： break 关键字用于中断循环或 switch 语句。</p><p>4： byte： byte 关键字用于声明一个可以容纳 8 个比特的变量。</p><p>5： case： case 关键字用于在 switch 语句中标记条件的值。</p><p>6： catch： catch 关键字用于捕获 try 语句中的异常。</p><p>7： char： char 关键字用于声明一个可以容纳无符号 16 位比特的 Unicode 字符的变量。</p><p>8： class： class 关键字用于声明一个类。</p><p>9： continue： continue 关键字用于继续下一个循环。它可以在指定条件下跳过其余代码。</p><p>10：default： default 关键字用于指定 switch 语句中除去 case 条件之外的默认代码块。</p><p>11：do： do 关键字通常和 while 关键字配合使用，do 后紧跟循环体。</p><p>12：double： double 关键字用于声明一个可以容纳 64 位浮点数的变量。</p><p>13：else： else 关键字用于指示 if 语句中的备用分支。</p><p>14：enum： enum（枚举）关键字用于定义一组固定的常量。</p><p>15：extends： extends 关键字用于指示一个类是从另一个类或接口继承的。</p><p>16：final： final 关键字用于指示该变量是不可更改的。</p><p>17：finally： finally 关键字和 try-catch 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。</p><p>18：float： float 关键字用于声明一个可以容纳 32 位浮点数的变量。</p><p>19：for： for 关键字用于启动一个 for 循环，如果循环次数是固定的，建议使用 for 循环。</p><p>20：if： if 关键字用于指定条件，如果条件为真，则执行对应代码。</p><p>21：implements： implements 关键字用于实现接口。</p><p>22：import： import 关键字用于导入对应的类或者接口。</p><p>23：instanceof： instanceof 关键字用于判断对象是否属于某个类型（class）。</p><p>24：int： int 关键字用于声明一个可以容纳 32 位带符号的整数变量。</p><p>25：interface： interface 关键字用于声明接口——只能具有抽象方法。</p><p>26：long： long 关键字用于声明一个可以容纳 64 位整数的变量。</p><p>27：native： native 关键字用于指定一个方法是通过调用本机接口（非 Java）实现的。</p><p>28：new： new 关键字用于创建一个新的对象。</p><p>29：null： 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null。</p><p>30：package： package 关键字用于声明类所在的包。</p><p>31：private： private 关键字是一个访问修饰符，表示方法或变量只对当前类可见。</p><p>32：protected： protected 关键字也是一个访问修饰符，表示方法或变量对同一包内的类和所有子类可见。</p><p>33：public： public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。</p><p>34：return： return 关键字用于在代码执行完成后返回（一个值）。</p><p>35：short： short 关键字用于声明一个可以容纳 16 位整数的变量。</p><p>36：static： static 关键字表示该变量或方法是静态变量或静态方法。</p><p>37：strictfp： strictfp 关键字并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。</p><p>38：super： super 关键字可用于调用父类的方法或者变量。</p><p>39：switch： switch 关键字通常用于三个（以上）的条件判断。</p><p>40：synchronized： synchronized 关键字用于指定多线程代码中的同步方法、变量或者代码块。</p><p>41：this： this 关键字可用于在方法或构造函数中引用当前对象。</p><p>42：throw： throw 关键字主动抛出异常。</p><p>43：throws： throws 关键字用于声明异常。</p><p>44：transient： transient 关键字在序列化的使用用到，它修饰的字段不会被序列化。</p><p>45：try： try 关键字用于包裹要捕获异常的代码块。</p><p>46：void： void 关键字用于指定方法没有返回值。</p><p>47：volatile： volatile 关键字保证了不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><p>48：while： 如果循环次数不固定，建议使用 while 循环。<br><img src="https://www.qyihe.xyz/images/post/10.1.jpg"></p><h2 id="05、操作符"><a href="#05、操作符" class="headerlink" title="05、操作符"></a>05、操作符</h2><p>除去“&#x3D;”赋值操作符，Java 中还有很多其他作用的操作符，我们来大致看一下。</p><h3 id="①、算术运算符"><a href="#①、算术运算符" class="headerlink" title="①、算术运算符"></a>①、算术运算符</h3><ul><li>+（加号）</li><li>–（减号）</li><li> *（乘号）</li><li> &#x2F;（除号）</li><li>％（取余）</li></ul><p>来看一个例子：</p><pre><code class="line-numbers language-Java">public class ArithmeticOperator &#123;
    public static void main(String[] args) &#123;
        int a = 10;
        int b = 5;
        
        System.out.println(a + b);//15  
        System.out.println(a - b);//5  
        System.out.println(a * b);//50  
        System.out.println(a / b);//2  
        System.out.println(a % b);//0  
    &#125;
&#125;
</code></pre><p>“+”号比较特殊，还可以用于字符串拼接，来看一个例子：</p><pre><code class="line-numbers language-Java">String result = &quot;沉默王二&quot; + &quot;一枚有趣的程序员&quot;;
</code></pre><h3 id="②、逻辑运算符"><a href="#②、逻辑运算符" class="headerlink" title="②、逻辑运算符"></a>②、逻辑运算符</h3><p>逻辑运算符通常用于布尔表达式，常见的有：</p><ul><li>&amp;&amp;（AND）多个条件中只要有一个为 false 结果就为 false</li><li>||（OR）多个条件只要有一个为 true 结果就为 true</li><li>!（NOT）条件如果为 true，加上“!”就为 false，否则，反之。</li></ul><p>来看一个例子：</p><pre><code class="line-numbers language-Java">public class LogicalOperator &#123;
    public static void main(String[] args) &#123;
        int a=10;
        int b=5;
        int c=20;
        System.out.println(a&lt;b&amp;&amp;a&lt;c);//false
        System.out.println(a&gt;b||a&lt;c);//true
        System.out.println(!(a&lt;b)); // true
    &#125;
&#125;
</code></pre><h3 id="③、比较运算符"><a href="#③、比较运算符" class="headerlink" title="③、比较运算符"></a>③、比较运算符</h3><ul><li> &lt; (小于)</li><li> &lt;&#x3D; (小于或者等于)</li><li><blockquote><p>(大于)</p></blockquote></li><li> &gt;&#x3D; (大于或者等于)</li><li> &#x3D;&#x3D; (相等)</li><li> !&#x3D; (不等)</li></ul><h2 id="06、程序结构"><a href="#06、程序结构" class="headerlink" title="06、程序结构"></a>06、程序结构</h2><p>Java 中最小的程序单元叫做类，一个类可以有一个或者多个字段（也叫作成员变量），还可以有一个或者多个方法，甚至还可以有一些内部类。<br>如果一个类想要执行，就必须有一个 main 方法——程序运行的入口，就好像人的嘴一样，嗯，可以这么牵强的理解一下。</p><pre><code class="line-numbers language-Java">public class StructureProgram &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;没有成员变量，只有一个 main 方法&quot;);
    &#125;
&#125;
</code></pre><ul><li>类名叫做 StructureProgram，在它里面，只有一个 main 方法。</li><li>{} 之间的代码称之为代码块。</li><li>以上源代码将会保存在一个后缀名为 java 的文件中。</li></ul><h2 id="07、编译然后执行代码"><a href="#07、编译然后执行代码" class="headerlink" title="07、编译然后执行代码"></a>07、编译然后执行代码</h2><p>通常，一些教程在介绍这块内容的时候，建议你通过命令行中先执行 javac 命令将源代码编译成字节码文件，然后再执行 java 命令指定代码。<br>但我不希望这个糟糕的局面再继续下去了——新手安装配置 JDK 真的蛮需要勇气和耐心的，稍有不慎，没入门就先放弃了。况且，在命令行中编译源代码会遇到很多莫名其妙的错误，这对新手是极其致命的——如果你再遇到这种老式的教程，可以吐口水了。<br>好的方法，就是去下载 IntelliJ IDEA，简称 IDEA，它被业界公认为最好的 Java 集成开发工具，尤其在智能代码助手、代码自动提示、代码重构、代码版本管理(Git、SVN、Maven)、单元测试、代码分析等方面有着亮眼的发挥。IDEA 产于捷克（位于东欧），开发人员以严谨著称。IDEA 分为社区版和付费版两个版本，新手直接下载社区版就足够用了。<br>安装成功后，可以开始敲代码了，然后直接右键运行（连保存都省了），结果会在 Run 面板中显示，如下图所示。<br><img src="https://www.qyihe.xyz/images/post/10.2.jpg"><br>想查看反编译后的字节码的话，可以在 src 的同级目录 target&#x2F;classes 的包路径下找到一个 StructureProgram.class 的文件（如果找不到的话，在目录上右键选择「Reload from Disk」）。<br>可以双击打开它。</p><pre><code class="line-numbers language-Java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package com.cmower.baeldung.basic;

public class StructureProgram &#123;
    public StructureProgram() &#123;
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(&quot;没有成员变量，只有一个 main 方法&quot;);
    &#125;
&#125;
</code></pre><p>IDEA 默认会用 Fernflower 将 class 字节码反编译为我们可以看得懂的 Java 代码。实际上，class 字节码（请安装 show bytecode 插件）长下面这个样子：</p><pre><code class="line-numbers language-Java">// class version 57.65535 (-65479)
// access flags 0x21
public class com/cmower/baeldung/basic/StructureProgram &#123;

  // compiled from: StructureProgram.java

  // access flags 0x1
  public &lt;init&gt;()V
   L0
    LINENUMBER 3 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V
    RETURN
   L1
    LOCALVARIABLE this Lcom/cmower/baeldung/basic/StructureProgram; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x9
  public static main([Ljava/lang/String;)V
   L0
    LINENUMBER 5 L0
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    LDC &quot;\u6ca1\u6709\u6210\u5458\u53d8\u91cf\uff0c\u53ea\u6709\u4e00\u4e2a main \u65b9\u6cd5&quot;
    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
   L1
    LINENUMBER 6 L1
    RETURN
   L2
    LOCALVARIABLE args [Ljava/lang/String; L0 L2 0
    MAXSTACK = 2
    MAXLOCALS = 1
&#125;
</code></pre><p>新手看起来还是有些懵逼的，建议过过眼瘾就行了。<br><img src="https://www.qyihe.xyz/images/post/10.3.jpg"></p><h1 id="二、Java-基本数据类型简介"><a href="#二、Java-基本数据类型简介" class="headerlink" title="二、Java 基本数据类型简介"></a>二、Java 基本数据类型简介</h1><h2 id="01、布尔"><a href="#01、布尔" class="headerlink" title="01、布尔"></a>01、布尔</h2><p>布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：</p><pre><code class="line-numbers language-Java">boolean flag = true;
</code></pre><h2 id="02、byte"><a href="#02、byte" class="headerlink" title="02、byte"></a>02、byte</h2><p>byte 的取值范围在 -128 和 127 之间，包含 127。最小值为 -128，最大值为 127，默认值为 0。<br>在网络传输的过程中，为了节省空间，常用字节来作为数据的传输方式。代码示例：</p><pre><code class="line-numbers language-Java">byte a = 10;
byte b = -10;
</code></pre><h2 id="03、short"><a href="#03、short" class="headerlink" title="03、short"></a>03、short</h2><p>short 的取值范围在 -32,768 和 32,767 之间，包含 32,767。最小值为 -32,768，最大值为 32,767，默认值为 0。代码示例：</p><pre><code class="line-numbers language-Java">short s = 10000;
short r = -5000;
</code></pre><h2 id="04、int"><a href="#04、int" class="headerlink" title="04、int"></a>04、int</h2><p>int 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间，默认值为 0。如果没有特殊需求，整形数据就用 int。代码示例：</p><pre><code class="line-numbers language-Java">int a = 100000;
int b = -200000;
```Java
## 05、long
long 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间，默认值为 0。如果 int 存储不下，就用 long，整形数据就用 int。代码示例：
```Java
long a = 100000L; 
long b = -200000L;
</code></pre><p>为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。</p><h2 id="06、float"><a href="#06、float" class="headerlink" title="06、float"></a>06、float</h2><p>float 是单精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围是无限的，默认值为 0.0f。float 不适合用于精确的数值，比如说货币。代码示例：</p><pre><code class="line-numbers language-Java">float f1 = 234.5f;
</code></pre><p>为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。</p><h2 id="07、double"><a href="#07、double" class="headerlink" title="07、double"></a>07、double</h2><p>double 是双精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围也是无限的，默认值为 0.0。double 同样不适合用于精确的数值，比如说货币。代码示例：</p><pre><code class="line-numbers language-Java">double d1 = 12.3
</code></pre><p>那精确的数值用什么表示呢？最好使用 BigDecimal，它可以表示一个任意大小且精度完全准确的浮点数。针对货币类型的数值，也可以先乘以 100 转成整形进行处理。<br>Tips：单精度是这样的格式，1 位符号，8 位指数，23 位小数，有效位数为 7 位。<br><img src="https://www.qyihe.xyz/images/post/10.4.jpg"><br>双精度是这样的格式，1 位符号，11 位指数，52 为小数，有效位数为 16 位。<br><img src="https://www.qyihe.xyz/images/post/10.5.jpg"><br>取值范围取决于指数位，计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。</p><blockquote><p>一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。</p></blockquote><h2 id="08、char"><a href="#08、char" class="headerlink" title="08、char"></a>08、char</h2><p>char 可以表示一个 16 位的 Unicode 字符，其值范围在 ‘\u0000’（0）和 ‘\uffff’（65,535）（包含）之间。代码示例：</p><pre><code class="line-numbers language-Java">char letterA = &#39;A&#39;; // 用英文的单引号包裹住。
</code></pre><h1 id="三、Java-main-方法简介"><a href="#三、Java-main-方法简介" class="headerlink" title="三、Java main() 方法简介"></a>三、Java main() 方法简介</h1><p>每个程序都需要一个入口，对于 Java 程序来说，入口就是 main 方法。</p><pre><code>public static void main(String[] args) &#123;

&#125;
</code></pre><ul><li><p>public、static、void 这 3 个关键字在前面的内容已·经介绍过了，如果觉得回去找比较麻烦的话，这里再贴一下：</p></li><li><p>public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。</p></li><li><p>static 关键字表示该变量或方法是静态变量或静态方法，可以直接通过类访问，不需要实例化对象来访问。</p></li><li><p>void 关键字用于指定方法没有返回值。</p></li></ul><p>另外，main 关键字为方法的名字，Java 虚拟机在执行程序时会寻找这个标识符；args 为 main() 方法的参数名，它的类型为一个 String 数组，也就是说，在使用 java 命令执行程序的时候，可以给 main() 方法传递字符串数组作为参数。</p><pre><code class="line-numbers language-Java">java HelloWorld 沉默王二 沉默王三
</code></pre><p>javac 命令用来编译程序，java 命令用来执行程序，HelloWorld 为这段程序的类名，沉默王二和沉默王三为字符串数组，中间通过空格隔开，然后就可以在 main() 方法中通过 args[0] 和 args[1] 获取传递的参数值了。</p><pre><code class="line-numbers language-Java">public class HelloWorld &#123;
    public static void main(String[] args) &#123;
        if (&quot;沉默王二&quot;.equals(args[0])) &#123;
            
        &#125;
        
        if (&quot;沉默王三&quot;.equals(args[1])) &#123;
            
        &#125;
    &#125;
&#125;
</code></pre><p>main() 方法的写法并不是唯一的，还有其他几种变体，尽管它们可能并不常见，可以简单来了解一下。</p><p>第二种，把方括号 [] 往 args 靠近而不是 String 靠近：</p><pre><code class="line-numbers language-Java">public static void main(String []args) &#123; 

&#125;
</code></pre><p>第三种，把方括号 [] 放在 args 的右侧：</p><pre><code class="line-numbers language-Java">public static void main(String args[]) &#123;

&#125;
</code></pre><p>第四种，还可以把数组形式换成可变参数的形式：</p><pre><code class="line-numbers language-Java">public static void main(String...args) &#123; 

&#125;
</code></pre><p>第五种，在 main() 方法上添加另外一个修饰符 strictfp，用于强调在处理浮点数时的兼容性：</p><pre><code class="line-numbers language-Java">public strictfp static void main(String[] args) &#123; 

&#125;
</code></pre><p>也可以在 main() 方法上添加 final 关键字或者 synchronized 关键字。</p><p>第六种，还可以为 args 参数添加 final 关键字：</p><pre><code class="line-numbers language-Java">public static void main(final String[] args) &#123; 

&#125;
</code></pre><p>第七种，最复杂的一种，所有可以添加的关键字统统添加上：</p><pre><code class="line-numbers language-Java">final static synchronized strictfp void main(final String[] args) &#123; 

&#125;
</code></pre><p>当然了，并不需要为了装逼特意把 main() 方法写成上面提到的这些形式，使用 IDE 提供的默认形式就可以了。</p><h1 id="四、Java-的流程控制语句"><a href="#四、Java-的流程控制语句" class="headerlink" title="四、Java 的流程控制语句"></a>四、Java 的流程控制语句</h1><ul><li><p>在 Java 中，有三种类型的流程控制语句：</p></li><li><p>条件分支，用于在两个或者多个条件之间做出选择，常见的有 if&#x2F;else&#x2F;else if、三元运算符和 switch 语句。</p></li><li><p>循环或者遍历，常见的有 for、while 和 do-while。</p></li><li><p>break 和 continue，用于跳出循环或者跳过进入下一轮循环。</p></li></ul><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>if 语句的格式如下：</p><pre><code class="line-numbers language-Java">if(布尔表达式)&#123;  
// 如果条件为 true，则执行这块代码
&#125; 
</code></pre><p>画个流程图表示一下：<br><img src="https://www.qyihe.xyz/images/post/10.6.jpg"><br>来写个示例：</p><pre><code class="line-numbers language-Java">public class IfExample &#123;
    public static void main(String[] args) &#123;
        int age = 20;
        if (age &lt; 30) &#123;
            System.out.println(&quot;青春年华&quot;);
        &#125;
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">青春年华
</code></pre><h2 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a>if-else 语句</h2><p>if-else 语句的格式如下:</p><pre><code class="line-numbers language-Java">if(布尔表达式)&#123;  
// 条件为 true 时执行的代码块
&#125;else&#123;  
// 条件为 false  时执行的代码块
&#125;  
</code></pre><p>画个流程图表示一下：<br><img src="https://www.qyihe.xyz/images/post/10.7.jpg"><br>来写个示例：</p><pre><code class="line-numbers language-Java">public class IfElseExample &#123;
    public static void main(String[] args) &#123;
        int age = 31;
        if (age &lt; 30) &#123;
            System.out.println(&quot;青春年华&quot;);
        &#125; else &#123;
            System.out.println(&quot;而立之年&quot;);
        &#125;
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">而立之年
</code></pre><p>除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：</p><pre><code class="line-numbers language-Java">public class LeapYear &#123;
    public static void main(String[] args) &#123;
        int year = 2020;
        if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) &#123;
            System.out.println(&quot;闰年&quot;);
        &#125; else &#123;
            System.out.println(&quot;普通年份&quot;);
        &#125;
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code>闰年
```Java
如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。
</code></pre><p>public class IfElseTernaryExample {<br> public static void main(String[] args) {<br> int num &#x3D; 13;<br> String result &#x3D; (num % 2 &#x3D;&#x3D; 0) ? “偶数” : “奇数”;<br> System.out.println(result);<br> }<br>}</p><pre><code>输出：
```Java
奇数
</code></pre><h2 id="if-else-if-语句"><a href="#if-else-if-语句" class="headerlink" title="if-else-if 语句"></a>if-else-if 语句</h2><p>if-else-if 语句的格式如下：</p><pre><code class="line-numbers language-Java">if(条件1)&#123;  
// 条件1 为 true 时执行的代码
&#125;else if(条件2)&#123;  
// 条件2 为 true 时执行的代码
&#125;  
else if(条件3)&#123;  
// 条件3 为 true 时执行的代码
&#125;  
...  
else&#123;  
// 以上条件均为 false 时执行的代码
&#125; 
</code></pre><p>画个流程图表示一下：<br><img src="https://www.qyihe.xyz/images/post/10.8.jpg"><br>来写个示例：</p><pre><code class="line-numbers language-Java">public class IfElseIfExample &#123;
    public static void main(String[] args) &#123;
        int age = 31;
        if (age &lt; 30) &#123;
            System.out.println(&quot;青春年华&quot;);
        &#125; else if (age &gt;= 30 &amp;&amp; age &lt; 40 ) &#123;
            System.out.println(&quot;而立之年&quot;);
        &#125; else if (age &gt;= 40 &amp;&amp; age &lt; 50 ) &#123;
            System.out.println(&quot;不惑之年&quot;);
        &#125; else &#123;
            System.out.println(&quot;知天命&quot;);
        &#125;
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">而立之年
</code></pre><h2 id="if-嵌套语句"><a href="#if-嵌套语句" class="headerlink" title="if 嵌套语句"></a>if 嵌套语句</h2><p>if 嵌套语句的格式如下：</p><pre><code class="line-numbers language-Java">if(外侧条件)&#123;    
     // 外侧条件为 true 时执行的代码 
          if(内侧条件)&#123;  
             // 内侧条件为 true 时执行的代码
    &#125;    
&#125;  
</code></pre><p>画个流程图表示一下：<br><img src="https://www.qyihe.xyz/images/post/10.9.jpg"><br>来写个示例：</p><pre><code class="line-numbers language-Java">public class NestedIfExample &#123;
    public static void main(String[] args) &#123;
        int age = 20;
        boolean isGirl = true;
        if (age &gt;= 20) &#123;
            if (isGirl) &#123;
                System.out.println(&quot;女生法定结婚年龄&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">女生法定结婚年龄
</code></pre><h2 id="switch-语句的格式："><a href="#switch-语句的格式：" class="headerlink" title="switch 语句的格式："></a>switch 语句的格式：</h2><pre><code class="line-numbers language-Java">switch(变量) &#123;    
case 可选值1:    
 // 可选值1匹配后执行的代码;    
 break;  // 该关键字是可选项
case 可选值2:    
 // 可选值2匹配后执行的代码;    
 break;  // 该关键字是可选项
......    
    
default: // 该关键字是可选项     
 // 所有可选值都不匹配后执行的代码 
&#125;    
</code></pre><ul><li><p>变量可以有 1 个或者 N 个值。</p></li><li><p>值类型必须和变量类型是一致的，并且值是确定的。</p></li><li><p>值必须是唯一的，不能重复，否则编译会出错。</p></li><li><p>break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。</p></li><li><p>default 关键字也是可选的。<br><img src="https://www.qyihe.xyz/images/post/10.10.jpg"><br>画个流程图：</p></li></ul><p>来个示例：</p><pre><code class="line-numbers language-Java">public class Switch1 &#123;
    public static void main(String[] args) &#123;
        int age = 20;
        switch (age) &#123;
            case 20 :
                System.out.println(&quot;上学&quot;);
                break;
            case 24 :
                System.out.println(&quot;苏州工作&quot;);
                break;
            case 30 :
                System.out.println(&quot;洛阳工作&quot;);
                break;
            default:
                System.out.println(&quot;未知&quot;);
                break; // 可省略
        &#125;
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">上学
</code></pre><p>当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：</p><pre><code class="line-numbers language-Java">public class Switch2 &#123;
    public static void main(String[] args) &#123;
        String name = &quot;沉默王二&quot;;
        switch (name) &#123;
            case &quot;詹姆斯&quot;:
                System.out.println(&quot;篮球运动员&quot;);
                break;
            case &quot;穆里尼奥&quot;:
                System.out.println(&quot;足球教练&quot;);
                break;
            case &quot;沉默王二&quot;:
            case &quot;沉默王三&quot;:
                System.out.println(&quot;乒乓球爱好者&quot;);
                break;
            default:
                throw new IllegalArgumentException(
                        &quot;名字没有匹配项&quot;);

        &#125;
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">乒乓球爱好者
</code></pre><p>枚举作为 switch 语句的变量也很常见，来看例子：</p><pre><code class="line-numbers language-Java">public class SwitchEnumDemo &#123;
    public enum PlayerTypes &#123;
        TENNIS,
        FOOTBALL,
        BASKETBALL,
        UNKNOWN
    &#125;

    public static void main(String[] args) &#123;
        System.out.println(createPlayer(PlayerTypes.BASKETBALL));
    &#125;

    private static String createPlayer(PlayerTypes playerType) &#123;
        switch (playerType) &#123;
            case TENNIS:
                return &quot;网球运动员费德勒&quot;;
            case FOOTBALL:
                return &quot;足球运动员C罗&quot;;
            case BASKETBALL:
                return &quot;篮球运动员詹姆斯&quot;;
            case UNKNOWN:
                throw new IllegalArgumentException(&quot;未知&quot;);
            default:
                throw new IllegalArgumentException(
                        &quot;运动员类型: &quot; + playerType);

        &#125;
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">篮球运动员詹姆斯
</code></pre><h2 id="循环语句比较"><a href="#循环语句比较" class="headerlink" title="循环语句比较"></a>循环语句比较</h2><table><thead><tr><th>比较方式</th><th>for</th><th>while</th><th>do-while</th></tr></thead><tbody><tr><td>简介</td><td>for 循环的次数是固定的</td><td>while 循环的次数是不固定的，并且需要条件为 true</td><td>do-while 循环的次数也不固定，但会至少执行一次循环，无聊条件是否为 true</td></tr><tr><td>何时使用</td><td>循环次数固定的</td><td>循环次数是不固定的</td><td>循环次数不固定，并且循环体至少要执行一次</td></tr><tr><td>语法</td><td>for(init:condition;++&#x2F;–) {&#x2F;&#x2F; 要执行的代码}</td><td>while(condition){&#x2F;&#x2F; 要执行的代码}</td><td>do{&#x2F;&#x2F;要执行的代码}while(condition);</td></tr></tbody></table><h2 id="普通的-for-循环"><a href="#普通的-for-循环" class="headerlink" title="普通的 for 循环"></a>普通的 for 循环</h2><p>普通的 for 循环可以分为 4 个部分：<br>（1）初始变量：循环开始执行时的初始条件。<br>（2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。<br>（3）循环体：循环每次要执行的代码块，直到条件变为 false。<br>（4）自增&#x2F;自减：初识变量变化的方式。<br>来看一下普通 for 循环的格式：</p><pre><code class="line-numbers language-Java">for(初识变量;条件;自增/自减)&#123;  
// 循环体
&#125;  
</code></pre><p>画个流程图：<br><img src="https://www.qyihe.xyz/images/post/10.11.jpg"><br>来个示例：</p><pre><code>public class ForExample &#123;
    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; 5; i++) &#123;
            System.out.println(&quot;沉默王二好帅啊&quot;);
        &#125;
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">沉默王二好帅啊
沉默王二好帅啊
沉默王二好帅啊
沉默王二好帅啊
沉默王二好帅啊
</code></pre><p>循环语句还可以嵌套呢，这样就可以打印出更好玩的呢。</p><pre><code class="line-numbers language-Java">public class PyramidForExample &#123;
    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; 5; i++) &#123;
            for (int j = 0;j&lt;= i;j++) &#123;
                System.out.print(&quot;❤&quot;);
            &#125;
            System.out.println();
        &#125;
    &#125;
&#125;
</code></pre><p>打印出什么玩意呢？</p><pre><code class="line-numbers language-Java">❤
❤❤
❤❤❤
❤❤❤❤
❤❤❤❤❤
</code></pre><h2 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h2><p>for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：</p><pre><code class="line-numbers language-Java">for(元素类型 元素 : 数组或集合)&#123;  
// 要执行的代码
&#125;  
</code></pre><p>来看一下示例：</p><pre><code class="line-numbers language-Java">public class ForEachExample &#123;
    public static void main(String[] args) &#123;
        String[] strs = &#123;&quot;沉默王二&quot;, &quot;一枚有趣的程序员&quot;&#125;;

        for (String str : strs) &#123;
            System.out.println(str);
        &#125;
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">沉默王二
一枚有趣的程序员
</code></pre><h2 id="无限-for-循环"><a href="#无限-for-循环" class="headerlink" title="无限 for 循环"></a>无限 for 循环</h2><p>想不想体验一下无限 for 循环的威力，也就是死循环？</p><pre><code class="line-numbers language-Java">public class InfinitiveForExample &#123;
    public static void main(String[] args) &#123;
        for(;;)&#123;
            System.out.println(&quot;停不下来。。。。&quot;);
        &#125;
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">停不下来。。。。
停不下来。。。。
停不下来。。。。
停不下来。。。。
</code></pre><p>一旦运行起来，就停不下来了，除非强制停止。</p><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><pre><code class="line-numbers language-Java">while(条件)&#123;  
//循环体  
&#125;  
</code></pre><p>画个流程图：<br><img src="https://www.qyihe.xyz/images/post/10.12.jpg"><br>来个示例：</p><pre><code class="line-numbers language-Java">public class WhileExample &#123;
    public static void main(String[] args) &#123;
        int i = 0;
        while (true) &#123;
            System.out.println(&quot;沉默王二&quot;);
            i++;
            if (i == 5) &#123;
                break;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><p>猜猜会输出几次？</p><pre><code class="line-numbers language-Java">沉默王二
沉默王二
沉默王二
沉默王二
沉默王二
</code></pre><h2 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h2><pre><code class="line-numbers language-Java">do&#123;  
// 循环体
&#125;while(提交); 
</code></pre><p>画个流程图：<br><img src="https://www.qyihe.xyz/images/post/10.13.jpg"><br>来个示例：</p><pre><code>public class DoWhileExample &#123;
    public static void main(String[] args) &#123;
        int i = 0;
        do &#123;
            System.out.println(&quot;沉默王二&quot;);
            i++;
            if (i == 5) &#123;
                break;
            &#125;
        &#125; while (true);
    &#125;
&#125;
</code></pre><p>程序输出结果如下所示：</p><pre><code class="line-numbers language-Java">沉默王二
沉默王二
沉默王二
沉默王二
沉默王二
</code></pre><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>break 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。<br>可以将 break 关键字用于所有类型循环语句中，比如说 for 循环，while 循环，以及 do-while 循环。<br>来画个流程图感受一下：<br><img src="https://www.qyihe.xyz/images/post/10.14.jpg"><br>用在 for 循环中的示例：</p><pre><code class="line-numbers language-Java">for (int i = 1; i &lt;= 10; i++) &#123;
    if (i == 5) &#123;
        break;
    &#125;
    System.out.println(i);
&#125;
</code></pre><p>用在嵌套 for 循环中的示例：</p><pre><code class="line-numbers language-Java">for (int i = 1; i &lt;= 3; i++) &#123;
    for (int j = 1; j &lt;= 3; j++) &#123;
        if (i == 2 &amp;&amp; j == 2) &#123;
            break;
        &#125;
        System.out.println(i + &quot; &quot; + j);
    &#125;
&#125;
</code></pre><p>用在 while 循环中的示例：</p><pre><code class="line-numbers language-Java">int i = 1;
while (i &lt;= 10) &#123;
    if (i == 5) &#123;
        i++;
        break;
    &#125;
    System.out.println(i);
    i++;
&#125;
</code></pre><p>用在 do-while 循环中的示例：</p><pre><code class="line-numbers language-Java">int j = 1;
do &#123;
    if (j == 5) &#123; 
        j++;
        break;
    &#125;
    System.out.println(j);
    j++;
&#125; while (j &lt;= 10);
</code></pre><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。<br>来个示例：</p><pre><code class="line-numbers language-Java">public class ContinueDemo &#123;
    public static void main(String[] args) &#123;
        for (int i = 1; i &lt;= 10; i++) &#123;
            if (i == 5) &#123;
                // 使用 continue 关键字
                continue;// 5 将会被跳过
            &#125;
            System.out.println(i);
        &#125;
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">1
2
3
4
6
7
8
9
10
</code></pre><p>5 真的被跳过了。<br>再来个循环嵌套的例子。</p><pre><code class="line-numbers language-Java">public class ContinueInnerDemo &#123;
    public static void main(String[] args) &#123;
        for (int i = 1; i &lt;= 3; i++) &#123;
            for (int j = 1; j &lt;= 3; j++) &#123;
                if (i == 2 &amp;&amp; j == 2) &#123;
                    //  当i=2，j=2时跳过
                    continue;
                &#125;
                System.out.println(i + &quot; &quot; + j);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><p>打印出什么玩意呢？</p><pre><code class="line-numbers language-Java">1 1
1 2
1 3
2 1
2 3
3 1
3 2
3 3
</code></pre><p>“2 2” 没有输出，被跳过了。<br>再来看一下 while 循环时 continue 的使用示例：</p><pre><code class="line-numbers language-Java">public class ContinueWhileDemo &#123;
    public static void main(String[] args) &#123;
        int i = 1;
        while (i &lt;= 10) &#123;
            if (i == 5) &#123;
                i++;
                continue;
            &#125;
            System.out.println(i);
            i++;
        &#125;
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">1
2
3
4
6
7
8
9
10
</code></pre><p>注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。<br>最后，再来看一下 do-while 循环时 continue 的使用示例：</p><pre><code class="line-numbers language-Java">public class ContinueDoWhileDemo &#123;
    public static void main(String[] args) &#123;
        int i=1;
        do&#123;
            if(i==5)&#123;
                i++;
                continue;
            &#125;
            System.out.println(i);
            i++;
        &#125;while(i&lt;=10);
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">1
2
3
4
6
7
8
9
10
</code></pre><p>注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。</p><h1 id="五、Java-包的简介"><a href="#五、Java-包的简介" class="headerlink" title="五、Java 包的简介"></a>五、Java 包的简介</h1><p>在 Java 中，我们使用 package（包）对相关的类、接口和子包进行分组。这样做的好处有：</p><ul><li>使相关类型更容易查找</li><li>避免命名冲突，比如说 com.itwanger.Hello 和 com.itwangsan.Hello 不同</li><li>通过包和访问权限控制符来限定类的可见性</li></ul><h2 id="01、创建一个包"><a href="#01、创建一个包" class="headerlink" title="01、创建一个包"></a>01、创建一个包</h2><pre><code class="line-numbers language-Java">package com.itwanger;
</code></pre><p>可以使用 package 关键字来定义一个包名，需要注意的是，这行代码必须处于一个类中的第一行。强烈建议在包中声明类，不要缺省，否则就失去了包结构的带来的好处。<br>包的命名应该遵守以下规则：</p><ul><li>应该全部是小写字母</li><li>可以包含多个单词，单词之间使用“.”连接，比如说 java.lang</li><li>名称由公司名或者组织名确定，采用倒序的方式，比如说，我个人博客的域名是 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.itwanger.com,所以我创建的包名是就是/">www.itwanger.com，所以我创建的包名是就是</a> com.itwanger.xxxx。</li></ul><p>每个包或者子包都在磁盘上有自己的目录结构，如果 Java 文件时在 com.itwanger.xxxx 包下，那么该文件所在的目录结构就应该是 com-&gt;itwanger-&gt;xxxx。</p><h2 id="02、使用包"><a href="#02、使用包" class="headerlink" title="02、使用包"></a>02、使用包</h2><p>让我们在名为 test 的子包里新建一个 Cmower 类：</p><pre><code class="line-numbers language-Java">package com.itwanger.test;

public class Cmower &#123;
    private String name;
    private int age;
&#125;
</code></pre><p>如果需要在另外一个包中使用 Cmower 类，就需要通过 import 关键字将其引入。有两种方式可供选择，第一种，使用 * 导入包下所有的类：</p><pre><code class="line-numbers language-Java">import com.itwanger.test.*;
</code></pre><p>第二种，使用类名导入该类：</p><pre><code class="line-numbers language-Java">import com.itwanger.test.Cmower;
</code></pre><p>Java 和第三方类库提供了很多包可供使用，可以通过上述的方式导入类库使用。</p><pre><code class="line-numbers language-Java">package com.itwanger.test;

import java.util.ArrayList;
import java.util.List;

public class CmowerTest &#123;
    public static void main(String[] args) &#123;
        List&lt;Cmower&gt; list = new ArrayList&lt;&gt;();
        list.add(new Cmower());
    &#125;
&#125;
</code></pre><h2 id="03、全名"><a href="#03、全名" class="headerlink" title="03、全名"></a>03、全名</h2><p>有时，我们可能会使用来自不同包下的两个具有相同名称的类。例如，我们可能同时使用 java.sql.Date 和 java.util.Date。当我们遇到命名冲突时，我们需要对至少一个类使用全名（包名+类名）。</p><pre><code class="line-numbers language-Java">List&lt;com.itwanger.test.Cmower&gt; list1 = new ArrayList&lt;&gt;();
list.add(new com.itwanger.test.Cmower());
</code></pre><h1 id="六、Java-到底是值传递还是引用传递"><a href="#六、Java-到底是值传递还是引用传递" class="headerlink" title="六、Java 到底是值传递还是引用传递"></a>六、Java 到底是值传递还是引用传递</h1><p>将参数传递给方法有两种常见的方式，一种是“值传递”，一种是“引用传递”。C 语言本身只支持值传递，它的衍生品 C++ 既支持值传递，也支持引用传递，而 Java 只支持值传递。</p><h2 id="01、值传递-VS-引用传递"><a href="#01、值传递-VS-引用传递" class="headerlink" title="01、值传递 VS 引用传递"></a>01、值传递 VS 引用传递</h2><p>首先，我们必须要搞清楚，到底什么是值传递，什么是引用传递，否则，讨论 Java 到底是值传递还是引用传递就显得毫无意义。<br>当一个参数按照值的方式在两个方法之间传递时，调用者和被调用者其实是用的两个不同的变量——被调用者中的变量（原始值）是调用者中变量的一份拷贝，对它们当中的任何一个变量修改都不会影响到另外一个变量。<br>而当一个参数按照引用传递的方式在两个方法之间传递时，调用者和被调用者其实用的是同一个变量，当该变量被修改时，双方都是可见的。<br>Java 程序员之所以容易搞混值传递和引用传递，主要是因为 Java 有两种数据类型，一种是基本类型，比如说 int，另外一种是引用类型，比如说 String。<br>基本类型的变量存储的都是实际的值，而引用类型的变量存储的是对象的引用——指向了对象在内存中的地址。值和引用存储在 stack（栈）中，而对象存储在 heap（堆）中。<br><img src="https://www.qyihe.xyz/images/post/10.15.jpg"><br>之所以有这个区别，是因为：</p><ul><li>栈的优势是，存取速度比堆要快，仅次于直接位于 CPU 中的寄存器。但缺点是，栈中的数据大小与生存周期必须是确定的。</li><li>堆的优势是可以动态地分配内存大小，生存周期也不必事先告诉编译器，Java 的垃圾回收器会自动收走那些不再使用的数据。但由于要在运行时动态分配内存，存取速度较慢。</li></ul><h2 id="02、基本类型的参数传递"><a href="#02、基本类型的参数传递" class="headerlink" title="02、基本类型的参数传递"></a>02、基本类型的参数传递</h2><p>众所周知，Java 有 8 种基本数据类型，分别是 int、long、byte、short、float、double 、char 和 boolean。它们的值直接存储在栈中，每当作为参数传递时，都会将原始值（实参）复制一份新的出来，给形参用。形参将会在被调用方法结束时从栈中清除。<br>来看下面这段代码：</p><pre><code class="line-numbers language-Java">public class PrimitiveTypeDemo &#123;
    public static void main(String[] args) &#123;
        int age = 18;
        modify(age);
        System.out.println(age);
    &#125;

    private static void modify(int age1) &#123;
        age1 = 30;
    &#125;
&#125;
</code></pre><p>（1）main 方法中的 age 是基本类型，所以它的值 18 直接存储在栈中。<br>（2）调用 modify() 方法的时候，将为实参 age 创建一个副本（形参 age1），它的值也为 18，不过是在栈中的其他位置。<br>（3）对形参 age 的任何修改都只会影响它自身而不会影响实参。<br><img src="https://www.qyihe.xyz/images/post/10.16.jpg"></p><h2 id="03、引用类型的参数传递"><a href="#03、引用类型的参数传递" class="headerlink" title="03、引用类型的参数传递"></a>03、引用类型的参数传递</h2><p>来看一段创建引用类型变量的代码：</p><pre><code class="line-numbers language-Java">Writer writer = new Writer(18, &quot;沉默王二&quot;);
</code></pre><p>writer 是对象吗？还是对象的引用？为了搞清楚这个问题，我们可以把上面的代码拆分为两行代码：</p><pre><code class="line-numbers language-Java">Writer writer;
writer = new Writer(18, &quot;沉默王二&quot;);
</code></pre><p>假如 writer 是对象的话，就不需要通过 new 关键字创建对象了，对吧？那也就是说，writer 并不是对象，在“&#x3D;”操作符执行之前，它仅仅是一个变量。那谁是对象呢？new Writer(18, “沉默王二”)，它是对象，存储于堆中；然后，“&#x3D;”操作符将对象的引用赋值给了 writer 变量，于是 writer 此时应该叫对象引用，它存储在栈中，保存了对象在堆中的地址。<br>每当引用类型作为参数传递时，都会创建一个对象引用（实参）的副本（形参），该形参保存的地址和实参一样。<br>来看下面这段代码：</p><pre><code class="line-numbers language-Java">public class ReferenceTypeDemo &#123;
    public static void main(String[] args) &#123;
        Writer a = new Writer(18);
        Writer b = new Writer(18);
        modify(a, b);

        System.out.println(a.getAge());
        System.out.println(b.getAge());
    &#125;

    private static void modify(Writer a1, Writer b1) &#123;
        a1.setAge(30);

        b1 = new Writer(18);
        b1.setAge(30);
    &#125;
&#125;
</code></pre><p>（1）在调用 modify() 方法之前，实参 a 和 b 指向的对象是不一样的，尽管 age 都为 18。<br><img src="https://www.qyihe.xyz/images/post/10.17.jpg"><br>（2）在调用 modify() 方法时，实参 a 和 b 都在栈中创建了一个新的副本，分别是 a1 和 b1，但指向的对象是一致的（a 和 a1 指向对象 a，b 和 b1 指向对象 b）。<br><img src="https://www.qyihe.xyz/images/post/10.18.jpg"><br>（3）在 modify() 方法中，修改了形参 a1 的 age 为 30，意味着对象 a 的 age 从 18 变成了 30，而实参 a 指向的也是对象 a，所以 a 的 age 也变成了 30；形参 b1 指向了一个新的对象，随后 b1 的 age 被修改为 30。<br><img src="https://www.qyihe.xyz/images/post/10.19.jpg"><br>修改 a1 的 age，意味着同时修改了 a 的 age，因为它们指向的对象是一个；修改 b1 的 age，对 b 却没有影响，因为它们指向的对象是两个。<br>程序输出的结果如下所示：</p><pre><code class="line-numbers language-Java">30
18
</code></pre><p>果然和我们的分析是吻合的。</p><h1 id="七、Java-的类和对象"><a href="#七、Java-的类和对象" class="headerlink" title="七、Java 的类和对象"></a>七、Java 的类和对象</h1><p>类和对象是 Java 中最基本的两个概念，可以说撑起了面向对象编程（OOP）的一片天。对象可以是现实中看得见的任何物体（一只特立独行的猪），也可以是想象中的任何虚拟物体（能七十二变的孙悟空），Java 通过类（class）来定义这些物体，有什么状态（通过字段，或者叫成员变量定义，比如说猪的颜色是纯色还是花色），有什么行为（通过方法定义，比如说猪会吃，会睡觉）。<br>来，让我来定义一个简单的类给你看看。</p><pre><code class="line-numbers language-Java">public class Pig &#123;
    private String color;

    public void eat() &#123;
        System.out.println(&quot;吃&quot;);
    &#125;
&#125;
</code></pre><p>默认情况下，每个 Java 类都会有一个空的构造方法，尽管它在源代码中是缺省的，但却可以通过反编译字节码看到它。</p><pre><code class="line-numbers language-Java">public class Pig &#123;
    private String color;

    public Pig() &#123;
    &#125;

    public void eat() &#123;
        System.out.println(&quot;吃&quot;);
    &#125;
&#125;
</code></pre><p>没错，就是多出来的那个 public Pig() {}，参数是空的，方法体是空的。我们可以通过 new 关键字利用这个构造方法来创建一个对象，代码如下所示：</p><pre><code class="line-numbers language-Java">Pig pig = new Pig();
</code></pre><p>当然了，我们也可以主动添加带参的构造方法。</p><pre><code class="line-numbers language-Java">public class Pig &#123;
    private String color;

    public Pig(String color) &#123;
        this.color = color;
    &#125;

    public void eat() &#123;
        System.out.println(&quot;吃&quot;);
    &#125;
&#125;
</code></pre><p>这时候，再查看反编译后的字节码时，你会发现缺省的无参构造方法消失了——和源代码一模一样。</p><pre><code class="line-numbers language-Java">public class Pig &#123;
    private String color;

    public Pig(String color) &#123;
        this.color = color;
    &#125;

    public void eat() &#123;
        System.out.println(&quot;吃&quot;);
    &#125;
&#125;
</code></pre><p>这意味着无法通过 new Pig() 来创建对象了——编译器会提醒你追加参数。<br><img src="https://www.qyihe.xyz/images/post/10.20.jpg"><br>比如说你将代码修改为 new Pig(“纯白色”)，或者添加无参的构造方法。</p><pre><code class="line-numbers language-Java">public class Pig &#123;
    private String color;

    public Pig(String color) &#123;
        this.color = color;
    &#125;

    public Pig() &#123;
    &#125;

    public void eat() &#123;
        System.out.println(&quot;吃&quot;);
    &#125;
&#125;
</code></pre><p>使用无参构造方法创建的对象状态默认值为 null（color 字符串为引用类型），如果是基本类型的话，默认值为对应基本类型的默认值，比如说 int 为 0，更详细的见下图。<br><img src="https://www.qyihe.xyz/images/post/10.21.jpg"><br>（图片中有一处错误，boolean 的默认值为 false）<br>接下来，我们来创建多个 Pig 对象，它的颜色各不相同。</p><pre><code class="line-numbers language-Java">public class PigTest &#123;
    public static void main(String[] args) &#123;
        Pig pigNoColor = new Pig();
        Pig pigWhite = new Pig(&quot;纯白色&quot;);
        Pig pigBlack = new Pig(&quot;纯黑色&quot;);
    &#125;
&#125;
</code></pre><p>你看，我们创建了 3 个不同花色的 Pig 对象，全部来自于一个类，由此可见类的重要性，只需要定义一次，就可以多次使用。<br>那假如我想改变对象的状态呢？该怎么办？目前毫无办法，因为没有任何可以更改状态的方法，直接修改 color 是行不通的，因为它的访问权限修饰符是 private 的。<br>最好的办法就是为 Pig 类追加 getter&#x2F;setter 方法，就像下面这样：</p><pre><code class="line-numbers language-Java">public String getColor() &#123;
    return color;
&#125;

public void setColor(String color) &#123;
    this.color = color;
&#125;
</code></pre><p>通过 setColor() 方法来修改，通过 getColor() 方法获取状态，它们的权限修饰符是 public 的。</p><pre><code class="line-numbers language-Java">Pig pigNoColor = new Pig();
pigNoColor.setColor(&quot;花色&quot;);
System.out.println(pigNoColor.getColor()); // 花色
</code></pre><p>为什么要这样设计呢？可以直接将 color 字段的访问权限修饰符换成是 public 的啊，不就和 getter&#x2F;setter 一样的效果了吗？<br>因为有些情况，某些字段是不允许被随意修改的，它只有在对象创建的时候初始化一次，比如说猪的年龄，它只能每年长一岁（举个例子），没有月光宝盒让它变回去。</p><pre><code class="line-numbers language-Java">private int age;

public int getAge() &#123;
    return age;
&#125;

public void increaseAge() &#123;
    this.age++;
&#125;
</code></pre><p>你看，age 就没有 setter 方法，只有一个每年可以调用一次的 increaseAge() 方法和 getter 方法。如果把 age 的访问权限修饰符更改为 public，age 就完全失去控制了，可以随意将其重置为 0 或者负数。<br>访问权限修饰符对于 Java 来说，非常重要，目前共有四种：public、private、protected 和 default（缺省）。<br>一个类只能使用 public 或者 default 修饰，public 修饰的类你之前已经见到过了，现在我来定义一个缺省权限修饰符的类给你欣赏一下。</p><pre><code class="line-numbers language-Java">class Dog &#123;
&#125;
</code></pre><p>哈哈，其实也没啥可以欣赏的。缺省意味着这个类可以被同一个包下的其他类进行访问；而 public 意味着这个类可以被所有包下的类进行访问。<br>假如硬要通过 private 和 protected 来修饰类的话，编译器会生气的，它不同意。<br><img src="https://www.qyihe.xyz/images/post/10.22.jpg"><br>private 可以用来修饰类的构造方法、字段和方法，只能被当前类进行访问。protected 也可以用来修饰类的构造方法、字段和方法，但它的权限范围更宽一些，可以被同一个包中的类进行访问，或者当前类的子类。<br>可以通过下面这张图来对比一下四个权限修饰符之间的差别：<br><img src="https://www.qyihe.xyz/images/post/10.23.jpg"></p><ul><li>同一个类中，不管是哪种权限修饰符，都可以访问；</li><li>同一个包下，private 修饰的无法访问；</li><li>子类可以访问 public 和 protected 修饰的；</li><li>public 修饰符面向世界，哈哈，可以被所有的地方访问到。<br><img src="https://www.qyihe.xyz/images/post/10.24.jpg"></li></ul><h1 id="八、Java-构造方法"><a href="#八、Java-构造方法" class="headerlink" title="八、Java 构造方法"></a>八、Java 构造方法</h1><p>假设现在有一个 Writer 类，它有两个字段，姓名和年纪：</p><pre><code class="line-numbers language-Java">public class Writer &#123;
    private String name;
    private int age;

    @Override
    public String toString() &#123;
        return &quot;Writer&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre><p>重写了 toString() 方法，用于打印 Writer 类的详情。由于没有构造方法，意味着当我们创建 Writer 对象时，它的字段值并没有初始化：</p><pre><code class="line-numbers language-Java">Writer writer = new Writer();
System.out.println(writer.toString());
</code></pre><p>输出结果如下所示：</p><pre><code class="line-numbers language-Java">Writer&#123;name=&#39;null&#39;, age=0&#125;
</code></pre><p>name 是字符串类型，所以默认值为 null，age 为 int 类型，所以默认值为 0。<br>让我们为 Writer 类主动加一个无参的构造方法：</p><pre><code class="line-numbers language-Java">public Writer() &#123;
    this.name = &quot;&quot;;
    this.age = 0;
&#125;
</code></pre><p>构造方法也是一个方法，只不过它没有返回值，默认返回创建对象的类型。需要注意的是，当前构造方法没有参数，它被称为无参构造方法。如果我们没有主动创建无参构造方法的话，编译器会隐式地自动添加一个无参的构造方法。这就是为什么，一开始虽然没有构造方法，却可以使用 new Writer() 创建对象的原因，只不过，所有的字段都被初始化成了默认值。<br>接下来，让我们添加一个有参的构造方法：</p><pre><code class="line-numbers language-Java">public Writer(String name, int age) &#123;
    this.name = name;
    this.age = age;
&#125;
</code></pre><p>现在，我们创建 Writer 对象的时候就可以通过对字段值初始化值了。</p><pre><code class="line-numbers language-Java">Writer writer1 = new Writer(&quot;沉默王二&quot;,18);
System.out.println(writer1.toString());
</code></pre><p>来看一下打印结果：</p><pre><code class="line-numbers language-Java">Writer&#123;name=&#39;沉默王二&#39;, age=18&#125;
</code></pre><p>可以根据字段的数量添加不同参数数量的构造方法，比如说，我们可以单独为 name 字段添加一个构造方法：</p><pre><code class="line-numbers language-Java">public Writer(String name) &#123;
    this.name = name;
&#125;
</code></pre><p>为了能够兼顾 age 字段，我们可以通过 this 关键字调用其他的构造方法：</p><pre><code class="line-numbers language-Java">public Writer(String name) &#123;
    this(name,18);
&#125;
</code></pre><p>把作者的年龄都默认初始化为 18。如果需要使用父类的构造方法，还可以使用 super 关键字，手册后面有详细的介绍。</p><h1 id="九、Java-抽象类"><a href="#九、Java-抽象类" class="headerlink" title="九、Java 抽象类"></a>九、Java 抽象类</h1><p>当我们要完成的任务是确定的，但具体的方式需要随后开个会投票的话，Java 的抽象类就派上用场了。这句话怎么理解呢？搬个小板凳坐好，听我来给你讲讲。<br><img src="https://www.qyihe.xyz/images/post/10.25.jpg"></p><h2 id="01、抽象类的-5-个关键点"><a href="#01、抽象类的-5-个关键点" class="headerlink" title="01、抽象类的 5 个关键点"></a>01、抽象类的 5 个关键点</h2><p>（1）定义抽象类的时候需要用到关键字 abstract，放在 class 关键字前。</p><pre><code class="line-numbers language-Java">public abstract class AbstractPlayer &#123;
&#125;
</code></pre><p>关于抽象类的命名，阿里出品的 Java 开发手册上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，记住了哦。<br>（2）抽象类不能被实例化，但可以有子类。<br>尝试通过 new 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。<br><img src="https://www.qyihe.xyz/images/post/10.26.jpg"><br>通过 extends 关键字可以继承抽象类，继承后，BasketballPlayer 类就是 AbstractPlayer 的子类。</p><pre><code class="line-numbers language-Java">public class BasketballPlayer extends AbstractPlayer &#123;
&#125;
</code></pre><p>（3）如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。<br>当在一个普通类（没有使用 abstract 关键字修饰）中定义了抽象方法，编译器就会有两处错误提示。<br>第一处在类级别上，提醒你“这个类必须通过 abstract 关键字定义”，or 的那个信息没必要，见下图。<br><img src="https://www.qyihe.xyz/images/post/10.27.jpg"><br>第二处在方法级别上，提醒你“抽象方法所在的类不是抽象的”，见下图。<br><img src="https://www.qyihe.xyz/images/post/10.28.jpg"><br>（4）抽象类可以同时声明抽象方法和具体方法，也可以什么方法都没有，但没必要。就像下面这样：</p><pre><code class="line-numbers language-Java">public abstract class AbstractPlayer &#123;
    abstract void play();
    
    public void sleep() &#123;
        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);
    &#125;
&#125;
</code></pre><p>（5）抽象类派生的子类必须实现父类中定义的抽象方法。比如说，抽象类中定义了 play() 方法，子类中就必须实现。</p><pre><code class="line-numbers language-Java">public class BasketballPlayer extends AbstractPlayer &#123;
    @Override
    void play() &#123;
        System.out.println(&quot;我是张伯伦，篮球场上得过 100 分&quot;);
    &#125;
&#125;
</code></pre><p>如果没有实现的话，编译器会提醒你“子类必须实现抽象方法”，见下图。<br><img src="https://www.qyihe.xyz/images/post/10.29.jpg"></p><h2 id="02、什么时候用抽象类"><a href="#02、什么时候用抽象类" class="headerlink" title="02、什么时候用抽象类"></a>02、什么时候用抽象类</h2><p>与抽象类息息相关的还有一个概念，就是接口，我们留到下一篇文章中详细说，因为要说的知识点还是蛮多的。你现在只需要有这样一个概念就好，接口是对行为的抽象，抽象类是对整个类（包含成员变量和行为）进行抽象。<br>（是不是有点明白又有点不明白，别着急，翘首以盼地等下一篇文章出炉吧）<br>除了接口之外，还有一个概念就是具体的类，就是不通过 abstract 修饰的普通类，见下面这段代码中的定义。</p><pre><code class="line-numbers language-Java">public class BasketballPlayer &#123;
   public void play() &#123;
        System.out.println(&quot;我是詹姆斯，现役第一人&quot;);
    &#125;
&#125;
</code></pre><p>有接口，有具体类，那什么时候该使用抽象类呢？<br>（1）我们希望一些通用的功能被多个子类复用。比如说，AbstractPlayer 抽象类中有一个普通的方法 sleep()，表明所有运动员都需要休息，那么这个方法就可以被子类复用。</p><pre><code class="line-numbers language-Java">public abstract class AbstractPlayer &#123;
    public void sleep() &#123;
        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);
    &#125;
&#125;
</code></pre><p>虽然 AbstractPlayer 类可以不是抽象类——把 abstract 修饰符去掉也能满足这种场景。但 AbstractPlayer 类可能还会有一个或者多个抽象方法。<br>BasketballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。</p><pre><code class="line-numbers language-Java">public class BasketballPlayer extends AbstractPlayer &#123;
&#125;
</code></pre><p>BasketballPlayer 对象可以直接调用 sleep() 方法：</p><pre><code class="line-numbers language-Java">BasketballPlayer basketballPlayer = new BasketballPlayer();
basketballPlayer.sleep();
</code></pre><p>FootballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。</p><pre><code class="line-numbers language-Java">public class FootballPlayer extends AbstractPlayer &#123;
&#125;
</code></pre><p>FootballPlayer 对象也可以直接调用 sleep() 方法：</p><pre><code class="line-numbers language-Java">FootballPlayer footballPlayer = new FootballPlayer();
footballPlayer.sleep();
</code></pre><p>（2）我们需要在抽象类中定义好 API，然后在子类中扩展实现。比如说，AbstractPlayer 抽象类中有一个抽象方法 play()，定义所有运动员都可以从事某项运动，但需要对应子类去扩展实现。</p><pre><code class="line-numbers language-Java">public abstract class AbstractPlayer &#123;
    abstract void play();
&#125;
</code></pre><p>BasketballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</p><pre><code class="line-numbers language-Java">public class BasketballPlayer extends AbstractPlayer &#123;
    @Override
    void play() &#123;
        System.out.println(&quot;我是张伯伦，我篮球场上得过 100 分，&quot;);
    &#125;
&#125;```

FootballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。
```Java
public class FootballPlayer extends AbstractPlayer &#123;
    @Override
    void play() &#123;
        System.out.println(&quot;我是C罗，我能接住任意高度的头球&quot;);
    &#125;
&#125;
</code></pre><p>（3）如果父类与子类之间的关系符合 is-a 的层次关系，就可以使用抽象类，比如说篮球运动员是运动员，足球运动员是运动员。</p><h2 id="03、具体示例"><a href="#03、具体示例" class="headerlink" title="03、具体示例"></a>03、具体示例</h2><p>为了进一步展示抽象类的特性，我们再来看一个具体的示例。假设现在有一个文件，里面的内容非常简单——“Hello World”，现在需要有一个读取器将内容读取出来，最好能按照大写的方式，或者小写的方式。<br>这时候，最好定义一个抽象类，比如说 BaseFileReader：</p><pre><code class="line-numbers language-Java">public abstract class BaseFileReader &#123;
    protected Path filePath;

    protected BaseFileReader(Path filePath) &#123;
        this.filePath = filePath;
    &#125;

    public List&lt;String&gt; readFile() throws IOException &#123;
        return Files.lines(filePath)
                .map(this::mapFileLine).collect(Collectors.toList());
    &#125;

    protected abstract String mapFileLine(String line);
&#125;
</code></pre><p>filePath 为文件路径，使用 protected 修饰，表明该成员变量可以在需要时被子类访问。<br>readFile() 方法用来读取文件，方法体里面调用了抽象方法 mapFileLine()——需要子类扩展实现大小写的方式。<br>你看，BaseFileReader 设计的就非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了。<br>小写的方式：</p><pre><code class="line-numbers language-Java">public class LowercaseFileReader extends BaseFileReader &#123;
    protected LowercaseFileReader(Path filePath) &#123;
        super(filePath);
    &#125;

    @Override
    protected String mapFileLine(String line) &#123;
        return line.toLowerCase();
    &#125;
&#125;
</code></pre><p>大写的方式：</p><pre><code class="line-numbers language-Java">public class UppercaseFileReader extends BaseFileReader &#123;
    protected UppercaseFileReader(Path filePath) &#123;
        super(filePath);
    &#125;

    @Override
    protected String mapFileLine(String line) &#123;
        return line.toUpperCase();
    &#125;
&#125;
</code></pre><p>你看，从文件里面一行一行读取内容的代码被子类复用了——抽象类 BaseFileReader 类中定义的普通方法 readFile()。与此同时，子类只需要专注于自己该做的工作，LowercaseFileReader 以小写的方式读取文件内容，UppercaseFileReader 以大写的方式读取文件内容。<br>接下来，我们来新建一个测试类 FileReaderTest：</p><pre><code class="line-numbers language-Java">public class FileReaderTest &#123;
    public static void main(String[] args) throws URISyntaxException, IOException &#123;
        URL location = FileReaderTest.class.getClassLoader().getResource(&quot;helloworld.txt&quot;);
        Path path = Paths.get(location.toURI());
        BaseFileReader lowercaseFileReader = new LowercaseFileReader(path);
        BaseFileReader uppercaseFileReader = new UppercaseFileReader(path);
        System.out.println(lowercaseFileReader.readFile());
        System.out.println(uppercaseFileReader.readFile());
    &#125;
&#125;
</code></pre><p>项目的 resource 目录下有一个文本文件，名字叫 helloworld.txt。<br><img src="https://www.qyihe.xyz/images/post/10.30.jpg"><br>可以通过 ClassLoader.getResource() 的方式获取到该文件的 URI 路径，然后就可以使用 LowercaseFileReader 和 UppercaseFileReader 两种方式读取到文本内容了。<br>输出结果如下所示：</p><pre><code class="line-numbers language-Java">[hello world]
[HELLO WORLD]
</code></pre><h1 id="十、Java-接口"><a href="#十、Java-接口" class="headerlink" title="十、Java 接口"></a>十、Java 接口</h1><p>对于面向对象编程来说，抽象是一个极具魅力的特征。如果一个程序员的抽象思维很差，那他在编程中就会遇到很多困难，无法把业务变成具体的代码。在 Java 中，可以通过两种形式来达到抽象的目的，一种是抽象类，另外一种就是接口。<br>如果你现在就想知道抽象类与接口之间的区别，我可以提前给你说一个：</p><ul><li>一个类只能继承一个抽象类，但却可以实现多个接口。</li></ul><p>当然了，在没有搞清楚接口到底是什么，它可以做什么之前，这个区别理解起来会有点难度。</p><h2 id="01、接口是什么"><a href="#01、接口是什么" class="headerlink" title="01、接口是什么"></a>01、接口是什么</h2><p>接口是通过 interface 关键字定义的，它可以包含一些常量和方法，来看下面这个示例。</p><pre><code class="line-numbers language-Java">public interface Electronic &#123;
    // 常量
    String LED = &quot;LED&quot;;

    // 抽象方法
    int getElectricityUse();

    // 静态方法
    static boolean isEnergyEfficient(String electtronicType) &#123;
        return electtronicType.equals(LED);
    &#125;

    // 默认方法
    default void printDescription() &#123;
        System.out.println(&quot;电子&quot;);
    &#125;
&#125;
</code></pre><p>（1）接口中定义的变量会在编译的时候自动加上 public static final 修饰符，也就是说 LED 变量其实是一个常量。<br>Java 官方文档上有这样的声明：</p><pre><code class="line-numbers language-Java">Every field declaration in the body of an interface is implicitly public, static, and final.
</code></pre><p>换句话说，接口可以用来作为常量类使用，还能省略掉 public static final，看似不错的一种选择，对吧？<br>不过，这种选择并不可取。因为接口的本意是对方法进行抽象，而常量接口会对子类中的变量造成命名空间上的“污染”。<br>（2）没有使用 private、default 或者 static 关键字修饰的方法是隐式抽象的，在编译的时候会自动加上 public abstract 修饰符。也就是说 getElectricityUse() 其实是一个抽象方法，没有方法体——这是定义接口的本意。<br>（3）从 Java 8 开始，接口中允许有静态方法，比如说 isEnergyEfficient() 方法。<br>静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口的名字来调用，比如说 Electronic.isEnergyEfficient(“LED”)。<br>接口中定义静态方法的目的是为了提供一种简单的机制，使我们不必创建对象就能调用方法，从而提高接口的竞争力。<br>（4）接口中允许定义 default 方法也是从 Java 8 开始的，比如说 printDescription()，它始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现，也就是说，无法直接使用一个“;”号来结束默认方法——编译器会报错的。<br><img src="https://www.qyihe.xyz/images/post/10.31.jpg"><br>允许在接口中定义默认方法的理由是很充分的，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 default 方法的帮助下，我们就必须挨个对实现类进行修改。<br>来看一下 Electronic 接口反编译后的字节码吧，你会发现，接口中定义的所有变量或者方法，都会自动添加上 public 关键字——假如你想知道编译器在背后都默默做了哪些辅助，记住反编译字节码就对了。</p><pre><code class="line-numbers language-Java">public interface Electronic
&#123;

    public abstract int getElectricityUse();

    public static boolean isEnergyEfficient(String electtronicType)
    &#123;
        return electtronicType.equals(&quot;LED&quot;);
    &#125;

    public void printDescription()
    &#123;
        System.out.println(&quot;\u7535\u5B50&quot;);
    &#125;

    public static final String LED = &quot;LED&quot;;
&#125;
</code></pre><p>有些读者可能会问，“二哥，为什么我反编译后的字节码和你的不一样，你用了什么反编译工具？”其实没有什么秘密，微信搜「沉默王二」回复关键字「JAD」就可以免费获取了，超级好用。</p><h2 id="02、定义接口的注意事项"><a href="#02、定义接口的注意事项" class="headerlink" title="02、定义接口的注意事项"></a>02、定义接口的注意事项</h2><p>由之前的例子我们就可以得出下面这些结论：</p><ul><li>接口中允许定义变量</li><li>接口中允许定义抽象方法</li><li>接口中允许定义静态方法（Java 8 之后）</li><li>接口中允许定义默认方法（Java 8 之后）</li></ul><p>除此之外，我们还应该知道：<br>（1）接口不允许直接实例化。<br><img src="https://www.qyihe.xyz/images/post/10.32.jpg"><br>需要定义一个类去实现接口，然后再实例化。</p><pre><code class="line-numbers language-Java">public class Computer implements Electronic &#123;

    public static void main(String[] args) &#123;
        new Computer();
    &#125;

    @Override
    public int getElectricityUse() &#123;
        return 0;
    &#125;
&#125;
</code></pre><p>（2）接口可以是空的，既不定义变量，也不定义方法。</p><pre><code class="line-numbers language-Java">public interface Serializable &#123;
&#125;
</code></pre><p>Serializable 是最典型的一个空的接口，我之前分享过一篇文章《Java Serializable：明明就一个空的接口嘛》，感兴趣的读者可以去我的个人博客看一看，你就明白了空接口的意义。</p><pre><code class="line-numbers language-Java">www.itwanger.com/java/2019/1…
</code></pre><p>（3）不要在定义接口的时候使用 final 关键字，否则会报编译错误，因为接口就是为了让子类实现的，而 final 阻止了这种行为。<br><img src="https://www.qyihe.xyz/images/post/10.33.jpg"><br>（4）接口的抽象方法不能是 private、protected 或者 final。<br><img src="https://www.qyihe.xyz/images/post/10.34.jpg"><br><img src="https://www.qyihe.xyz/images/post/10.35.jpg"><br><img src="https://www.qyihe.xyz/images/post/10.36.jpg"><br>（5）接口的变量是隐式 public static final，所以其值无法改变。</p><h2 id="03、接口可以做什么"><a href="#03、接口可以做什么" class="headerlink" title="03、接口可以做什么"></a>03、接口可以做什么</h2><p>（1）使某些实现类具有我们想要的功能，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了 Comparable 或者 Comparator 的类具有比较功能。<br>Cloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。实现了 Cloneable 接口的类可以使用 Object.clone() 方法，否则会抛出 CloneNotSupportedException。</p><pre><code class="line-numbers language-Java">public class CloneableTest implements Cloneable &#123;
    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;

    public static void main(String[] args) throws CloneNotSupportedException &#123;
        CloneableTest c1 = new CloneableTest();
        CloneableTest c2 = (CloneableTest) c1.clone();
    &#125;
&#125;
</code></pre><p>运行后没有报错。现在把 implements Cloneable 去掉。</p><pre><code class="line-numbers language-Java">public class CloneableTest &#123;
    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;

    public static void main(String[] args) throws CloneNotSupportedException &#123;
        CloneableTest c1 = new CloneableTest();
        CloneableTest c2 = (CloneableTest) c1.clone();

    &#125;
&#125;
</code></pre><p>运行后抛出 CloneNotSupportedException：</p><pre><code class="line-numbers language-Java">Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException: com.cmower.baeldung.interface1.CloneableTest
    at java.base/java.lang.Object.clone(Native Method)
    at com.cmower.baeldung.interface1.CloneableTest.clone(CloneableTest.java:6)
    at com.cmower.baeldung.interface1.CloneableTest.main(CloneableTest.java:11)
</code></pre><p>至于 Comparable 和 Comparator 的用法，感兴趣的读者可以参照我之前写的另外一篇文章《来吧，一文彻底搞懂Java中的Comparable和Comparator》。</p><pre><code class="line-numbers language-Java">www.itwanger.com/java/2020/0…
</code></pre><p>（2）Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。<br>可能有些读者会问，“二哥，为什么 Java 只支持单一继承？”简单来解释一下。<br>如果有两个类共同继承（extends）一个有特定方法的父类，那么该方法会被两个子类重写。然后，如果你决定同时继承这两个子类，那么在你调用该重写方法时，编译器不能识别你要调用哪个子类的方法。这也正是著名的菱形问题，见下图。<br><img src="https://www.qyihe.xyz/images/post/10.37.jpg"><br>ClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重载的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。<br>接口没有这方面的困扰。来定义两个接口，Fly 会飞，Run 会跑。</p><pre><code class="line-numbers language-Java">public interface Fly &#123;
    void fly();
&#125;
public interface Run &#123;
    void run();
&#125;
</code></pre><p>然后让一个类同时实现这两个接口。</p><pre><code class="line-numbers language-Java">public class Pig implements Fly,Run&#123;
    @Override
    public void fly() &#123;
        System.out.println(&quot;会飞的猪&quot;);
    &#125;

    @Override
    public void run() &#123;
        System.out.println(&quot;会跑的猪&quot;);
    &#125;
&#125;
</code></pre><p>这就在某种形式上达到了多重继承的目的：现实世界里，猪的确只会跑，但在雷军的眼里，站在风口的猪就会飞，这就需要赋予这只猪更多的能力，通过抽象类是无法实现的，只能通过接口。<br>（3）实现多态。<br>什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。<br>多态可以通过继承（extends）的关系实现，也可以通过接口的形式实现。来看这样一个例子。<br>Shape 是表示一个形状。</p><pre><code class="line-numbers language-Java">public interface Shape &#123;
    String name();
&#125;
</code></pre><p>圆是一个形状。</p><pre><code class="line-numbers language-Java">public class Circle implements Shape &#123;
    @Override
    public String name() &#123;
        return &quot;圆&quot;;
    &#125;
&#125;
</code></pre><p>正方形也是一个形状。</p><pre><code class="line-numbers language-Java">public class Square implements Shape &#123;
    @Override
    public String name() &#123;
        return &quot;正方形&quot;;
    &#125;
&#125;
</code></pre><p>然后来看测试类。</p><pre><code class="line-numbers language-Java">List&lt;Shape&gt; shapes = new ArrayList&lt;&gt;();
Shape circleShape = new Circle();
Shape squareShape = new Square();

shapes.add(circleShape);
shapes.add(squareShape);

for (Shape shape : shapes) &#123;
    System.out.println(shape.name());
&#125;
</code></pre><p>多态的存在 3 个前提：<br>1、要有继承关系，Circle 和 Square 都实现了 Shape 接口<br>2、子类要重写父类的方法，Circle 和 Square 都重写了 name() 方法<br>3、父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle 对象，后者指向的是 Square 对象。<br>然后，我们来看一下测试结果：</p><pre><code class="line-numbers language-Java">圆
正方形
</code></pre><p>也就意味着，尽管在 for 循环中，shape 的类型都为 Shape，但在调用 name() 方法的时候，它知道 Circle 对象应该调用 Circle 类的 name() 方法，Square 对象应该调用 Square 类的 name() 方法。</p><h2 id="04、接口与抽象类的区别"><a href="#04、接口与抽象类的区别" class="headerlink" title="04、接口与抽象类的区别"></a>04、接口与抽象类的区别</h2><p>好了，关于接口的一切，你应该都搞清楚了。现在回到读者春夏秋冬的那条留言，“兄弟，说说抽象类和接口之间的区别？”<br>（1）语法层面上</p><ul><li>接口中不能有 public 和 protected 修饰的方法，抽象类中可以有。</li><li>接口中的变量只能是隐式的常量，抽象类中可以有任意类型的变量。</li><li>一个类只能继承一个抽象类，但却可以实现多个接口。</li></ul><p>（2）设计层面上<br>抽象类是对类的一种抽象，继承抽象类的类和抽象类本身是一种 is-a 的关系。<br>接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，所有的类都可以实现 Serializable 接口，从而具有序列化的功能。<br>就这么多吧，能说道这份上，我相信面试官就不会为难你了。</p><h1 id="十一、Java-继承"><a href="#十一、Java-继承" class="headerlink" title="十一、Java 继承"></a>十一、Java 继承</h1><p>在 Java 中，一个类可以继承另外一个类或者实现多个接口，我想这一点，大部分的读者应该都知道了。还有一点，我不确定大家是否知道，就是一个接口也可以继承另外一个接口，就像下面这样：</p><pre><code class="line-numbers language-Java">public interface OneInterface extends Cloneable &#123;
&#125;
</code></pre><p>这样做有什么好处呢？我想有一部分读者应该已经猜出来了，就是实现了 OneInterface 接口的类，也可以使用 Object.clone() 方法了。</p><pre><code class="line-numbers language-Java">public class TestInterface implements OneInterface &#123;
    public static void main(String[] args) throws CloneNotSupportedException &#123;
        TestInterface c1 = new TestInterface();
        TestInterface c2 = (TestInterface) c1.clone();
    &#125;
&#125;
</code></pre><p>除此之外，我们还可以在 OneInterface 接口中定义其他一些抽象方法（比如说深拷贝），使该接口拥有 Cloneable 所不具有的功能。</p><pre><code class="line-numbers language-Java">public interface OneInterface extends Cloneable &#123;
    void deepClone();
&#125;
</code></pre><p>看到了吧？这就是继承的好处：子接口拥有了父接口的方法，使得子接口具有了父接口相同的行为；同时，子接口还可以在此基础上自由发挥，添加属于自己的行为。<br>以上，把“接口”换成“类”，结论同样成立。让我们来定义一个普通的父类 Wanger：</p><pre><code class="line-numbers language-Java">public class Wanger &#123;
    int age;
    String name;
    void write() &#123;
        System.out.println(&quot;我写了本《基督山伯爵》&quot;);
    &#125;
&#125;
</code></pre><p>然后，我们再来定义一个子类 Wangxiaoer，使用关键字 extends 来继承父类 Wanger：</p><pre><code class="line-numbers language-Java">public class Wangxiaoer extends Wanger&#123;
    @Override
    void write() &#123;
        System.out.println(&quot;我写了本《茶花女》&quot;);
    &#125;
&#125;
</code></pre><p>我们可以将通用的方法和成员变量放在父类中，达到代码复用的目的；然后将特殊的方法和成员变量放在子类中，除此之外，子类还可以覆盖父类的方法（比如write() 方法）。这样，子类也就焕发出了新的生命力。<br>Java 只支持单一继承，这一点，我在上一篇接口的文章中已经提到过了。如果一个类在定义的时候没有使用 extends 关键字，那么它隐式地继承了 java.lang.Object 类——在我看来，这恐怕就是 Java 号称万物皆对象的真正原因了。<br>那究竟子类继承了父类的什么呢？<br>子类可以继承父类的非 private 成员变量，为了验证这一点，我们来看下面这个示例。</p><pre><code class="line-numbers language-Java">public class Wanger &#123;
    String defaultName;
    private String privateName;
    public String publicName;
    protected String protectedName;
&#125;
</code></pre><p>父类 Wanger 定义了四种类型的成员变量，缺省的 defaultName、私有的 privateName、共有的 publicName、受保护的 protectedName。<br>在子类 Wangxiaoer 中定义一个测试方法 testVariable()：<br><img src="https://www.qyihe.xyz/images/post/10.38.jpg"><br>可以确认，除了私有的 privateName，其他三种类型的成员变量都可以继承到。<br>同理，子类可以继承父类的非 private 方法，为了验证这一点，我们来看下面这个示例。</p><pre><code class="line-numbers language-Java">public class Wanger &#123;
    void write() &#123;
    &#125;

    private void privateWrite() &#123;
    &#125;

    public void publicWrite() &#123;
    &#125;

    protected void protectedWrite() &#123;
    &#125;
&#125;
</code></pre><p>父类 Wanger 定义了四种类型的方法，缺省的 write、私有的 privateWrite()、共有的 publicWrite()、受保护的 protectedWrite()。<br>在子类 Wangxiaoer 中定义一个 main 方法，并使用 new 关键字新建一个子类对象：<br><img src="https://www.qyihe.xyz/images/post/10.39.jpg"><br>可以确认，除了私有的 privateWrite()，其他三种类型的方法都可以继承到。<br>不过，子类无法继承父类的构造方法。如果父类的构造方法是带有参数的，代码如下所示：</p><pre><code class="line-numbers language-Java">public class Wanger &#123;
    int age;
    String name;

    public Wanger(int age, String name) &#123;
        this.age = age;
        this.name = name;
    &#125;
&#125;
</code></pre><p>则必须在子类的构造器中显式地通过 super 关键字进行调用，否则编译器将提示以下错误：<br><img src="https://www.qyihe.xyz/images/post/10.40.jpg"><br>修复后的代码如下所示：</p><pre><code class="line-numbers language-Java">public class Wangxiaoer extends Wanger&#123;
    public Wangxiaoer(int age, String name) &#123;
        super(age, name);
    &#125;
&#125;
</code></pre><p>is-a 是继承的一个明显特征，就是说子类的对象引用类型可以是一个父类类型。</p><pre><code>public class Wangxiaoer extends Wanger&#123;
    public static void main(String[] args) &#123;
        Wanger wangxiaoer = new Wangxiaoer();
    &#125;
&#125;
</code></pre><p>同理，子接口的实现类的对象引用类型也可以是一个父接口类型。</p><pre><code class="line-numbers language-Java">public interface OneInterface extends Cloneable &#123;
&#125;
public class TestInterface implements OneInterface &#123;
    public static void main(String[] args) &#123;
        Cloneable c1 = new TestInterface();
    &#125;
&#125;
</code></pre><p>尽管一个类只能继承一个类，但一个类却可以实现多个接口，这一点，我在上一篇文章也提到过了。另外，还有一点我也提到了，就是 Java 8 之后，接口中可以定义 default 方法，这很方便，但也带来了新的问题：</p><blockquote><p>如果一个类实现了多个接口，而这些接口中定义了相同签名的 default 方法，那么这个类就要重写该方法，否则编译无法通过。</p></blockquote><p>FlyInterface 是一个会飞的接口，里面有一个签名为 sleep() 的默认方法：</p><pre><code class="line-numbers language-Java">public interface FlyInterface &#123;
    void fly();
    default void sleep() &#123;
        System.out.println(&quot;睡着飞&quot;);
    &#125;
&#125;
</code></pre><p>RunInterface 是一个会跑的接口，里面也有一个签名为 sleep() 的默认方法：</p><pre><code class="line-numbers language-Java">public interface RunInterface &#123;
    void run();
    default void sleep() &#123;
        System.out.println(&quot;睡着跑&quot;);
    &#125;
&#125;
</code></pre><p>Pig 类实现了 FlyInterface 和 RunInterface 两个接口，但这时候编译出错了。<br><img src="https://www.qyihe.xyz/images/post/10.41.jpg"><br>原本，default 方法就是为实现该接口而不覆盖该方法的类提供默认实现的，现在，相同方法签名的 sleep() 方法把编译器搞懵逼了，只能重写了。</p><pre><code class="line-numbers language-Java">public class Pig implements FlyInterface, RunInterface &#123;

    @Override
    public void fly() &#123;
        System.out.println(&quot;会飞的猪&quot;);
    &#125;

    @Override
    public void sleep() &#123;
        System.out.println(&quot;只能重写了&quot;);
    &#125;

    @Override
    public void run() &#123;
        System.out.println(&quot;会跑的猪&quot;);
    &#125;
&#125;
</code></pre><p>类虽然不能继承多个类，但接口却可以继承多个接口，这一点，我不知道有没有触及到一些读者的知识盲区。</p><pre><code class="line-numbers language-Java">public interface WalkInterface extends FlyInterface,RunInterface&#123;
    void walk();
&#125;
</code></pre><h1 id="十二、this-关键字"><a href="#十二、this-关键字" class="headerlink" title="十二、this 关键字"></a>十二、this 关键字</h1><p>在 Java 中，this 关键字指的是当前对象（它的方法正在被调用）的引用，能理解吧，各位亲？不理解的话，我们继续往下看。<br>看完再不明白，你过来捶爆我，我保证不还手，只要不打脸。</p><h2 id="01、消除字段歧义"><a href="#01、消除字段歧义" class="headerlink" title="01、消除字段歧义"></a>01、消除字段歧义</h2><p>我敢赌一毛钱，所有的读者，不管男女老少，应该都知道这种用法，毕竟写构造方法的时候经常用啊。谁要不知道，过来，我给你发一毛钱红包，只要你脸皮够厚。</p><pre><code class="line-numbers language-Java">public class Writer &#123;
    private int age;
    private String name;

    public Writer(int age, String name) &#123;
        this.age = age;
        this.name = name;
    &#125;
&#125;
</code></pre><p>Writer 类有两个成员变量，分别是 age 和 name，在使用有参构造函数的时候，如果参数名和成员变量的名字相同，就需要使用 this 关键字消除歧义：this.age 是指成员变量，age 是指构造方法的参数。</p><h2 id="02、引用类的其他构造方法"><a href="#02、引用类的其他构造方法" class="headerlink" title="02、引用类的其他构造方法"></a>02、引用类的其他构造方法</h2><p>当一个类的构造方法有多个，并且它们之间有交集的话，就可以使用 this 关键字来调用不同的构造方法，从而减少代码量。<br>比如说，在无参构造方法中调用有参构造方法：</p><pre><code class="line-numbers language-Java">public class Writer &#123;
    private int age;
    private String name;

    public Writer(int age, String name) &#123;
        this.age = age;
        this.name = name;
    &#125;

    public Writer() &#123;
        this(18, &quot;沉默王二&quot;);
    &#125;
&#125;
</code></pre><p>也可以在有参构造方法中调用无参构造方法：</p><pre><code class="line-numbers language-Java">public class Writer &#123;
    private int age;
    private String name;

    public Writer(int age, String name) &#123;
        this();
        this.age = age;
        this.name = name;
    &#125;

    public Writer() &#123;
    &#125;
&#125;
</code></pre><p>需要注意的是，this() 必须是构造方法中的第一条语句，否则就会报错。<br><img src="https://www.qyihe.xyz/images/post/10.42.jpg"></p><h2 id="03、作为参数传递"><a href="#03、作为参数传递" class="headerlink" title="03、作为参数传递"></a>03、作为参数传递</h2><p>在下例中，有一个无参的构造方法，里面调用了 print() 方法，参数只有一个 this 关键字。</p><pre><code class="line-numbers language-Java">public class ThisTest &#123;
    public ThisTest() &#123;
        print(this);
    &#125;

    private void print(ThisTest thisTest) &#123;
        System.out.println(&quot;print &quot; +thisTest);
    &#125;

    public static void main(String[] args) &#123;
        ThisTest test = new ThisTest();
        System.out.println(&quot;main &quot; + test);
    &#125;
&#125;
</code></pre><p>来打印看一下结果：</p><pre><code class="line-numbers language-Java">print com.cmower.baeldung.this1.ThisTest@573fd745
main com.cmower.baeldung.this1.ThisTest@573fd745
</code></pre><p>从结果中可以看得出来，this 就是我们在 main() 方法中使用 new 关键字创建的 ThisTest 对象。</p><h2 id="04、链式调用"><a href="#04、链式调用" class="headerlink" title="04、链式调用"></a>04、链式调用</h2><p>学过 JavaScript，或者 jQuery 的读者可能对链式调用比较熟悉，类似于 a.b().c().d()，仿佛能无穷无尽调用下去。<br>在 Java 中，对应的专有名词叫 Builder 模式，来看一个示例。</p><pre><code class="line-numbers language-Java">public class Writer &#123;
    private int age;
    private String name;
    private String bookName;
    
    public Writer(WriterBuilder builder) &#123;
        this.age = builder.age;
        this.name = builder.name;
        this.bookName = builder.bookName;
    &#125;

    public static class WriterBuilder &#123;
        public String bookName;
        private int age;
        private String name;

        public WriterBuilder(int age, String name) &#123;
            this.age = age;
            this.name = name;
        &#125;

        public WriterBuilder writeBook(String bookName) &#123;
            this.bookName = bookName;
            return this;
        &#125;

        public Writer build() &#123;
            return new Writer(this);
        &#125;
    &#125;
&#125;
</code></pre><p>Writer 类有三个成员变量，分别是 age、name 和 bookName，还有它们仨对应的一个构造方法，参数是一个内部静态类 WriterBuilder。<br>内部类 WriterBuilder 也有三个成员变量，和 Writer 类一致，不同的是，WriterBuilder 类的构造方法里面只有 age 和 name 赋值了，另外一个成员变量 bookName 通过单独的方法 writeBook() 来赋值，注意，该方法的返回类型是 WriterBuilder，最后使用 return 返回了 this 关键字。<br>最后的 build() 方法用来创建一个 Writer 对象，参数为 this 关键字，也就是当前的 WriterBuilder 对象。<br>这时候，创建 Writer 对象就可以通过链式调用的方式。</p><pre><code class="line-numbers language-Java">Writer writer = new Writer.WriterBuilder(18,&quot;沉默王二&quot;)
                .writeBook(&quot;《Web全栈开发进阶之路》&quot;)
                .build();
</code></pre><h2 id="05、在内部类中访问外部类对象"><a href="#05、在内部类中访问外部类对象" class="headerlink" title="05、在内部类中访问外部类对象"></a>05、在内部类中访问外部类对象</h2><p>说实话，自从 Java 8 的函数式编程出现后，就很少用到 this 在内部类中访问外部类对象了。来看一个示例：</p><pre><code class="line-numbers language-Java">public class ThisInnerTest &#123;
    private String name;
    
    class InnerClass &#123;
        public InnerClass() &#123;
            ThisInnerTest thisInnerTest = ThisInnerTest.this;
            String outerName = thisInnerTest.name;
        &#125;
    &#125;
&#125;
</code></pre><p>在内部类 InnerClass 的构造方法中，通过外部类.this 可以获取到外部类对象，然后就可以使用外部类的成员变量了，比如说 name。</p><h1 id="十三、super-关键字"><a href="#十三、super-关键字" class="headerlink" title="十三、super 关键字"></a>十三、super 关键字</h1><p>简而言之，super 关键字就是用来访问父类的。<br>先来看父类：</p><pre><code class="line-numbers language-Java">public class SuperBase &#123;
    String message = &quot;父类&quot;;

    public SuperBase(String message) &#123;
        this.message = message;
    &#125;

    public SuperBase() &#123;
    &#125;

    public void printMessage() &#123;
        System.out.println(message);
    &#125;
&#125;
</code></pre><p>再来看子类：</p><pre><code class="line-numbers language-Java">public class SuperSub extends SuperBase &#123;
    String message = &quot;子类&quot;;

    public SuperSub(String message) &#123;
        super(message);
    &#125;

    public SuperSub() &#123;
        super.printMessage();
        printMessage();
    &#125;

    public void getParentMessage() &#123;
        System.out.println(super.message);
    &#125;

    public void printMessage() &#123;
        System.out.println(message);
    &#125;
&#125;
</code></pre><p>（1）super 关键字可用于访问父类的构造方法<br>你看，子类可以通过 super(message) 来调用父类的构造方法。现在来新建一个 SuperSub 对象，看看输出结果是什么：</p><pre><code class="line-numbers language-Java">SuperSub superSub = new SuperSub(&quot;子类的message&quot;);
</code></pre><p>new 关键字在调用构造方法创建子类对象的时候，会通过 super 关键字初始化父类的 message，所以此此时父类的 message 会输出“子类的message”。<br>（2）super 关键字可以访问父类的变量<br>上述例子中的 SuperSub 类中就有，getParentMessage() 通过 super.message 方法父类的同名成员变量 message。<br>（3）当方法发生重写时，super 关键字可以访问父类的同名方法<br>上述例子中的 SuperSub 类中就有，无参的构造方法 SuperSub() 中就使用 super.printMessage() 调用了父类的同名方法。</p><h1 id="十四、重写和重载"><a href="#十四、重写和重载" class="headerlink" title="十四、重写和重载"></a>十四、重写和重载</h1><p>先来看一段重写的代码吧。</p><pre><code class="line-numbers language-Java">class LaoWang&#123;
    public void write() &#123;
        System.out.println(&quot;老王写了一本《基督山伯爵》&quot;);
    &#125;
&#125;
public class XiaoWang extends LaoWang &#123;
    @Override
    public void write() &#123;
        System.out.println(&quot;小王写了一本《茶花女》&quot;);
    &#125;
&#125;
</code></pre><p>重写的两个方法名相同，方法参数的个数也相同；不过一个方法在父类中，另外一个在子类中。就好像父类 LaoWang 有一个 write() 方法（无参），方法体是写一本《基督山伯爵》；子类 XiaoWang 重写了父类的 write() 方法（无参），但方法体是写一本《茶花女》。<br>来写一段测试代码。</p><pre><code class="line-numbers language-Java">public class OverridingTest &#123;
    public static void main(String[] args) &#123;
        LaoWang wang = new XiaoWang();
        wang.write();
    &#125;
&#125;
</code></pre><p>大家猜结果是什么？</p><pre><code class="line-numbers language-Java">小王写了一本《茶花女》
</code></pre><p>在上面的代码中，们声明了一个类型为 LaoWang 的变量 wang。在编译期间，编译器会检查 LaoWang 类是否包含了 write() 方法，发现 LaoWang 类有，于是编译通过。在运行期间，new 了一个 XiaoWang 对象，并将其赋值给 wang，此时 Java 虚拟机知道 wang 引用的是 XiaoWang 对象，所以调用的是子类 XiaoWang 中的 write() 方法而不是父类 LaoWang 中的 write() 方法，因此输出结果为“小王写了一本《茶花女》”。<br>再来看一段重载的代码吧。</p><pre><code class="line-numbers language-Java">class LaoWang&#123;
    public void read() &#123;
        System.out.println(&quot;老王读了一本《Web全栈开发进阶之路》&quot;);
    &#125;
    
    public void read(String bookname) &#123;
        System.out.println(&quot;老王读了一本《&quot; + bookname + &quot;》&quot;);
    &#125;
&#125;
</code></pre><p>重载的两个方法名相同，但方法参数的个数不同，另外也不涉及到继承，两个方法在同一个类中。就好像类 LaoWang 有两个方法，名字都是 read()，但一个有参数（书名），另外一个没有（只能读写死的一本书）。<br>来写一段测试代码。</p><pre><code class="line-numbers language-Java">public class OverloadingTest &#123;
    public static void main(String[] args) &#123;
        LaoWang wang = new LaoWang();
        wang.read();
        wang.read(&quot;金瓶梅&quot;);
    &#125;
&#125;
</code></pre><p>这结果就不用猜了。变量 wang 的类型为 LaoWang，wang.read() 调用的是无参的 read() 方法，因此先输出“老王读了一本《Web全栈开发进阶之路》”；wang.read(“金瓶梅”) 调用的是有参的 read(bookname) 方法，因此后输出“老王读了一本《金瓶梅》”。在编译期间，编译器就知道这两个 read() 方法时不同的，因为它们的方法签名（&#x3D;方法名称+方法参数）不同。<br>简单的来总结一下：<br>（1）编译器无法决定调用哪个重写的方法，因为只从变量的类型上是无法做出判断的，要在运行时才能决定；但编译器可以明确地知道该调用哪个重载的方法，因为引用类型是确定的，参数个数决定了该调用哪个方法。<br>（2）多态针对的是重写，而不是重载。<br><img src="https://www.qyihe.xyz/images/post/10.43.jpg"><br>哎，后悔啊，早年我要是能把这道面试题吃透的话，也不用被老马刁难了。吟一首诗感慨一下人生吧。</p><blockquote><p>青青园中葵，朝露待日晞。<br>阳春布德泽，万物生光辉。<br>常恐秋节至，焜黄华叶衰。<br>百川东到海，何时复西归?<br>少壮不努力，老大徒伤悲</p></blockquote><p>另外，我想要告诉大家的是，重写（Override）和重载（Overload）是 Java 中两个非常重要的概念，新手经常会被它们俩迷惑，因为它们俩的英文名字太像了，中文翻译也只差一个字。难，太难了。<br><img src="https://www.qyihe.xyz/images/post/10.44.jpg"></p><h1 id="十五、static-关键字"><a href="#十五、static-关键字" class="headerlink" title="十五、static 关键字"></a>十五、static 关键字</h1><p>先来个提纲挈领（唉呀妈呀，成语区博主上线了）吧：</p><blockquote><p>static 关键字可用于变量、方法、代码块和内部类，表示某个特定的成员只属于某个类本身，而不是该类的某个对象。</p></blockquote><h2 id="01、静态变量"><a href="#01、静态变量" class="headerlink" title="01、静态变量"></a>01、静态变量</h2><p>静态变量也叫类变量，它属于一个类，而不是这个类的对象。</p><pre><code class="line-numbers language-Java">public class Writer &#123;
    private String name;
    private int age;
    public static int countOfWriters;

    public Writer(String name, int age) &#123;
        this.name = name;
        this.age = age;
        countOfWriters++;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;
</code></pre><p>其中，countOfWriters 被称为静态变量，它有别于 name 和 age 这两个成员变量，因为它前面多了一个修饰符 static。<br>这意味着无论这个类被初始化多少次，静态变量的值都会在所有类的对象中共享。</p><pre><code class="line-numbers language-Java">Writer w1 = new Writer(&quot;沉默王二&quot;,18);
Writer w2 = new Writer(&quot;沉默王三&quot;,16);

System.out.println(Writer.countOfWriters);
</code></pre><p>按照上面的逻辑，你应该能推理得出，countOfWriters 的值此时应该为 2 而不是 1。从内存的角度来看，静态变量将会存储在 Java 虚拟机中一个名叫“Metaspace”（元空间，Java 8 之后）的特定池中。<br>静态变量和成员变量有着很大的不同，成员变量的值属于某个对象，不同的对象之间，值是不共享的；但静态变量不是的，它可以用来统计对象的数量，因为它是共享的。就像上面例子中的 countOfWriters，创建一个对象的时候，它的值为 1，创建两个对象的时候，它的值就为 2。<br>简单小结一下：<br>（1）由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问；<br><img src="https://www.qyihe.xyz/images/post/10.45.jpg"><br>（2）不需要初始化类就可以访问静态变量。</p><pre><code class="line-numbers language-Java">public class WriterDemo &#123;
    public static void main(String[] args) &#123;
        System.out.println(Writer.countOfWriters); // 输出 0
    &#125;
&#125;
</code></pre><h2 id="02、静态方法"><a href="#02、静态方法" class="headerlink" title="02、静态方法"></a>02、静态方法</h2><p>静态方法也叫类方法，它和静态变量类似，属于一个类，而不是这个类的对象。</p><pre><code class="line-numbers language-Java">public static void setCountOfWriters(int countOfWriters) &#123;
    Writer.countOfWriters = countOfWriters;
&#125;
</code></pre><p>setCountOfWriters() 就是一个静态方法，它由 static 关键字修饰。<br>如果你用过 java.lang.Math 类或者 Apache 的一些工具类（比如说 StringUtils）的话，对静态方法一定不会感动陌生。<br><img src="https://www.qyihe.xyz/images/post/10.46.jpg"><br>Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。<br><img src="https://www.qyihe.xyz/images/post/10.47.jpg"><br>简单小结一下：<br>（1）Java 中的静态方法在编译时解析，因为静态方法不能被重写（方法重写发生在运行时阶段，为了多态）。<br>（2）抽象方法不能是静态的。<br><img src="https://www.qyihe.xyz/images/post/10.48.jpg"><br>（3）静态方法不能使用 this 和 super 关键字。<br>（4）成员方法可以直接访问其他成员方法和成员变量。<br>（5）成员方法也可以直接方法静态方法和静态变量。<br>（6）静态方法可以访问所有其他静态方法和静态变量。<br>（7）静态方法无法直接访问成员方法和成员变量。<br><img src="https://www.qyihe.xyz/images/post/10.49.jpg"></p><h2 id="03、静态代码块"><a href="#03、静态代码块" class="headerlink" title="03、静态代码块"></a>03、静态代码块</h2><p>静态代码块可以用来初始化静态变量，尽管静态方法也可以在声明的时候直接初始化，但有些时候，我们需要多行代码来完成初始化。</p><pre><code class="line-numbers language-Java">public class StaticBlockDemo &#123;
    public static List&lt;String&gt; writes = new ArrayList&lt;&gt;();

    static &#123;
        writes.add(&quot;沉默王二&quot;);
        writes.add(&quot;沉默王三&quot;);
        writes.add(&quot;沉默王四&quot;);

        System.out.println(&quot;第一块&quot;);
    &#125;

    static &#123;
        writes.add(&quot;沉默王五&quot;);
        writes.add(&quot;沉默王六&quot;);

        System.out.println(&quot;第二块&quot;);
    &#125;
&#125;
</code></pre><p>writes 是一个静态的 ArrayList，所以不太可能在声明的时候完成初始化，因此需要在静态代码块中完成初始化。<br>简单小结一下：<br>（1）一个类可以有多个静态代码块。<br>（2）静态代码块的解析和执行顺序和它在类中的位置保持一致。为了验证这个结论，可以在 StaticBlockDemo 类中加入空的 main 方法，执行完的结果如下所示：</p><pre><code class="line-numbers language-Java">第一块
第二块
</code></pre><h2 id="04、静态内部类"><a href="#04、静态内部类" class="headerlink" title="04、静态内部类"></a>04、静态内部类</h2><p>Java 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些变量，使代码更具有条理性和可读性。<br>常见的内部类有四种，成员内部类、局部内部类、匿名内部类和静态内部类，限于篇幅原因，前三种不在我们本次文章的讨论范围，以后有机会再细说。</p><pre><code class="line-numbers language-Java">public class Singleton &#123;
    private Singleton() &#123;&#125;

    private static class SingletonHolder &#123;
        public static final Singleton instance = new Singleton();
    &#125;

    public static Singleton getInstance() &#123;
        return SingletonHolder.instance;
    &#125;
&#125;
</code></pre><p>以上这段代码是不是特别熟悉，对，这就是创建单例的一种方式，第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 getInstance() 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全也能保证 Singleton 类的唯一性。不过，创建单例更优雅的一种方式是使用枚举。<br>简单小结一下：<br>（1）静态内部类不能访问外部类的所有成员变量。<br>（2）静态内部类可以访问外部类的所有静态变量，包括私有静态变量。<br>（3）外部类不能声明为 static。<br><img src="https://www.qyihe.xyz/images/post/10.50.jpg"></p><h1 id="十六、Java-枚举"><a href="#十六、Java-枚举" class="headerlink" title="十六、Java 枚举"></a>十六、Java 枚举</h1><p>开门见山地说吧，enum（枚举）是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，默认继承自 java.lang.Enum。<br>为了证明这一点，我们来新建一个枚举 PlayerType：</p><pre><code class="line-numbers language-Java">public enum PlayerType &#123;
    TENNIS,
    FOOTBALL,
    BASKETBALL
&#125;
</code></pre><p>两个关键字带一个类名，还有大括号，以及三个大写的单词，但没看到继承 Enum 类啊？别着急，心急吃不了热豆腐啊。使用 JAD 查看一下反编译后的字节码，就一清二楚了。</p><pre><code class="line-numbers language-Java">public final class PlayerType extends Enum
&#123;

    public static PlayerType[] values()
    &#123;
        return (PlayerType[])$VALUES.clone();
    &#125;

    public static PlayerType valueOf(String name)
    &#123;
        return (PlayerType)Enum.valueOf(com/cmower/baeldung/enum1/PlayerType, name);
    &#125;

    private PlayerType(String s, int i)
    &#123;
        super(s, i);
    &#125;

    public static final PlayerType TENNIS;
    public static final PlayerType FOOTBALL;
    public static final PlayerType BASKETBALL;
    private static final PlayerType $VALUES[];

    static 
    &#123;
        TENNIS = new PlayerType(&quot;TENNIS&quot;, 0);
        FOOTBALL = new PlayerType(&quot;FOOTBALL&quot;, 1);
        BASKETBALL = new PlayerType(&quot;BASKETBALL&quot;, 2);
        $VALUES = (new PlayerType[] &#123;
            TENNIS, FOOTBALL, BASKETBALL
        &#125;);
    &#125;
&#125;
</code></pre><p>看到没？PlayerType 类是 final 的，并且继承自 Enum 类。这些工作我们程序员没做，编译器帮我们悄悄地做了。此外，它还附带几个有用静态方法，比如说 values() 和 valueOf(String name)。</p><h2 id="01、内部枚举"><a href="#01、内部枚举" class="headerlink" title="01、内部枚举"></a>01、内部枚举</h2><p>好的，小伙伴们应该已经清楚枚举长什么样子了吧？既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。</p><pre><code class="line-numbers language-Java">public class Player &#123;
    private PlayerType type;
    public enum PlayerType &#123;
        TENNIS,
        FOOTBALL,
        BASKETBALL
    &#125;
    
    public boolean isBasketballPlayer() &#123;
      return getType() == PlayerType.BASKETBALL;
    &#125;

    public PlayerType getType() &#123;
        return type;
    &#125;

    public void setType(PlayerType type) &#123;
        this.type = type;
    &#125;
&#125;
</code></pre><p>PlayerType 就相当于 Player 的内部类，isBasketballPlayer() 方法用来判断运动员是否是一个篮球运动员。<br>由于枚举是 final 的，可以确保在 Java 虚拟机中仅有一个常量对象（可以参照反编译后的静态代码块「static 关键字带大括号的那部分代码」），所以我们可以很安全地使用“&#x3D;&#x3D;”运算符来比较两个枚举是否相等，参照 isBasketballPlayer() 方法。<br>那为什么不使用 equals() 方法判断呢？</p><pre><code class="line-numbers language-Java">if(player.getType().equals(Player.PlayerType.BASKETBALL))&#123;&#125;;
if(player.getType() == Player.PlayerType.BASKETBALL)&#123;&#125;;
</code></pre><p>“&#x3D;&#x3D;”运算符比较的时候，如果两个对象都为 null，并不会发生 NullPointerException，而 equals() 方法则会。<br>另外， “&#x3D;&#x3D;”运算符会在编译时进行检查，如果两侧的类型不匹配，会提示错误，而 equals() 方法则不会。<br><img src="https://www.qyihe.xyz/images/post/10.51.jpg"></p><h2 id="02、枚举可用于-switch-语句"><a href="#02、枚举可用于-switch-语句" class="headerlink" title="02、枚举可用于 switch 语句"></a>02、枚举可用于 switch 语句</h2><p>这个我在之前的一篇我去的文章中详细地说明过了，感兴趣的小伙伴可以点击链接跳转过去看一下。</p><pre><code>switch (playerType) &#123;
        case TENNIS:
            return &quot;网球运动员费德勒&quot;;
        case FOOTBALL:
            return &quot;足球运动员C罗&quot;;
        case BASKETBALL:
            return &quot;篮球运动员詹姆斯&quot;;
        case UNKNOWN:
            throw new IllegalArgumentException(&quot;未知&quot;);
        default:
            throw new IllegalArgumentException(
                    &quot;运动员类型: &quot; + playerType);

&#125;
</code></pre><h2 id="03、枚举可以有构造方法"><a href="#03、枚举可以有构造方法" class="headerlink" title="03、枚举可以有构造方法"></a>03、枚举可以有构造方法</h2><p>如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。</p><pre><code class="line-numbers language-Java">public enum PlayerType &#123;
    TENNIS(&quot;网球&quot;),
    FOOTBALL(&quot;足球&quot;),
    BASKETBALL(&quot;篮球&quot;);

    private String name;

    PlayerType(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre><h2 id="04、EnumSet"><a href="#04、EnumSet" class="headerlink" title="04、EnumSet"></a>04、EnumSet</h2><p>EnumSet 是一个专门针对枚举类型的 Set 接口的实现类，它是处理枚举类型数据的一把利器，非常高效（内部实现是位向量，我也搞不懂）。<br>因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法：<br><img src="https://www.qyihe.xyz/images/post/10.52.jpg"><br>下面的示例中使用 noneOf() 创建了一个空的 PlayerType 的 EnumSet；使用 allOf() 创建了一个包含所有 PlayerType 的 EnumSet。</p><pre><code class="line-numbers language-Java">public class EnumSetTest &#123;
    public enum PlayerType &#123;
        TENNIS,
        FOOTBALL,
        BASKETBALL
    &#125;

    public static void main(String[] args) &#123;
        EnumSet&lt;PlayerType&gt; enumSetNone = EnumSet.noneOf(PlayerType.class);
        System.out.println(enumSetNone);

        EnumSet&lt;PlayerType&gt; enumSetAll = EnumSet.allOf(PlayerType.class);
        System.out.println(enumSetAll);
    &#125;
&#125;
</code></pre><p>程序输出结果如下所示：</p><pre><code class="line-numbers language-Java">[]
[TENNIS, FOOTBALL, BASKETBALL]
</code></pre><p>有了 EnumSet 后，就可以使用 Set 的一些方法了：<br><img src="https://www.qyihe.xyz/images/post/10.53.jpg"></p><h2 id="05、EnumMap"><a href="#05、EnumMap" class="headerlink" title="05、EnumMap"></a>05、EnumMap</h2><p>EnumMap 是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。<br>和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字：</p><pre><code class="line-numbers language-Java">EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);
</code></pre><p>有了 EnumMap 对象后就可以使用 Map 的一些方法了：<br><img src="https://www.qyihe.xyz/images/post/10.54.jpg"><br>和 HashMap 的使用方法大致相同，来看下面的例子：</p><pre><code class="line-numbers language-Java">EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);
enumMap.put(PlayerType.BASKETBALL,&quot;篮球运动员&quot;);
enumMap.put(PlayerType.FOOTBALL,&quot;足球运动员&quot;);
enumMap.put(PlayerType.TENNIS,&quot;网球运动员&quot;);
System.out.println(enumMap);

System.out.println(enumMap.get(PlayerType.BASKETBALL));
System.out.println(enumMap.containsKey(PlayerType.BASKETBALL));
System.out.println(enumMap.remove(PlayerType.BASKETBALL));
</code></pre><p>程序输出结果如下所示：</p><pre><code class="line-numbers language-Java">&#123;TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员&#125;
篮球运动员
true
篮球运动员
</code></pre><h2 id="06、单例"><a href="#06、单例" class="headerlink" title="06、单例"></a>06、单例</h2><p>通常情况下，实现一个单例并非易事，不信，来看下面这段代码</p><pre><code class="line-numbers language-Java">public class Singleton &#123;  
    private volatile static Singleton singleton; 
    private Singleton ()&#123;&#125;  
    public static Singleton getSingleton() &#123;  
    if (singleton == null) &#123;
        synchronized (Singleton.class) &#123; 
        if (singleton == null) &#123;  
            singleton = new Singleton(); 
        &#125;  
        &#125;  
    &#125;  
    return singleton;  
    &#125;  
&#125;
</code></pre><p>但枚举的出现，让代码量减少到极致：</p><pre><code class="line-numbers language-Java">public enum EasySingleton&#123;
    INSTANCE;
&#125;
</code></pre><p>完事了，真的超级短，有没有？枚举默认实现了 Serializable 接口，因此 Java 虚拟机可以保证该类为单例，这与传统的实现方式不大相同。传统方式中，我们必须确保单例在反序列化期间不能创建任何新实例。</p><h2 id="07、枚举可与数据库交互"><a href="#07、枚举可与数据库交互" class="headerlink" title="07、枚举可与数据库交互"></a>07、枚举可与数据库交互</h2><p>我们可以配合 Mybatis 将数据库字段转换为枚举类型。现在假设有一个数据库字段 check_type 的类型如下：</p><pre><code class="line-numbers language-Java">`check_type` int(1) DEFAULT NULL COMMENT &#39;检查类型（1：未通过、2：通过）&#39;,
</code></pre><p>它对应的枚举类型为 CheckType，代码如下：</p><pre><code class="line-numbers language-Java">public enum CheckType &#123;
    NO_PASS(0, &quot;未通过&quot;), PASS(1, &quot;通过&quot;);
    private int key;

    private String text;

    private CheckType(int key, String text) &#123;
        this.key = key;
        this.text = text;
    &#125;

    public int getKey() &#123;
        return key;
    &#125;

    public String getText() &#123;
        return text;
    &#125;

    private static HashMap&lt;Integer,CheckType&gt; map = new HashMap&lt;Integer,CheckType&gt;();
    static &#123;
        for(CheckType d : CheckType.values())&#123;
            map.put(d.key, d);
        &#125;
    &#125;
    
    public static CheckType parse(Integer index) &#123;
        if(map.containsKey(index))&#123;
            return map.get(index);
        &#125;
        return null;
    &#125;
&#125;
</code></pre><p>（1）CheckType 添加了构造方法，还有两个字段，key 为 int 型，text 为 String 型。<br>（2）CheckType 中有一个public static CheckType parse(Integer index)方法，可将一个 Integer 通过 key 的匹配转化为枚举类型。<br>那么现在，我们可以在 Mybatis 的配置文件中使用 typeHandler 将数据库字段转化为枚举类型。</p><pre><code class="line-numbers language-Java">&lt;resultMap id=&quot;CheckLog&quot; type=&quot;com.entity.CheckLog&quot;&gt;
  &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
  &lt;result property=&quot;checkType&quot; column=&quot;check_type&quot; typeHandler=&quot;com.CheckTypeHandler&quot;&gt;&lt;/result&gt;
&lt;/resultMap&gt;
</code></pre><p>其中 checkType 字段对应的类如下：</p><pre><code class="line-numbers language-Java">public class CheckLog implements Serializable &#123;

    private String id;
    private CheckType checkType;

    public String getId() &#123;
        return id;
    &#125;

    public void setId(String id) &#123;
        this.id = id;
    &#125;

    public CheckType getCheckType() &#123;
        return checkType;
    &#125;

    public void setCheckType(CheckType checkType) &#123;
        this.checkType = checkType;
    &#125;
&#125;
</code></pre><p>CheckTypeHandler 转换器的类源码如下：</p><pre><code class="line-numbers language-Java">public class CheckTypeHandler extends BaseTypeHandler&lt;CheckType&gt; &#123;

    @Override
    public CheckType getNullableResult(ResultSet rs, String index) throws SQLException &#123;
        return CheckType.parse(rs.getInt(index));
    &#125;

    @Override
    public CheckType getNullableResult(ResultSet rs, int index) throws SQLException &#123;
        return CheckType.parse(rs.getInt(index));
    &#125;

    @Override
    public CheckType getNullableResult(CallableStatement cs, int index) throws SQLException &#123;
        return CheckType.parse(cs.getInt(index));
    &#125;

    @Override
    public void setNonNullParameter(PreparedStatement ps, int index, CheckType val, JdbcType arg3) throws SQLException &#123;
        ps.setInt(index, val.getKey());
    &#125;
&#125;
</code></pre><p>CheckTypeHandler 的核心功能就是调用 CheckType 枚举类的 parse() 方法对数据库字段进行转换。<br><img src="https://www.qyihe.xyz/images/post/10.55.jpg"><br>恕我直言，我觉得小伙伴们肯定会用 Java 枚举了，如果还不会，就过来砍我！</p><h1 id="十七、final-关键字"><a href="#十七、final-关键字" class="headerlink" title="十七、final 关键字"></a>十七、final 关键字</h1><p>尽管继承可以让我们重用现有代码，但有时处于某些原因，我们确实需要对可扩展性进行限制，final 关键字可以帮助我们做到这一点。</p><h2 id="01、final-类"><a href="#01、final-类" class="headerlink" title="01、final 类"></a>01、final 类</h2><p>如果一个类使用了 final 关键字修饰，那么它就无法被继承。如果小伙伴们细心观察的话，Java 就有不少 final 类，比如说最常见的 String 类。</p><pre><code class="line-numbers language-Java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence,
               Constable, ConstantDesc &#123;&#125;
</code></pre><p>为什么 String 类要设计成 final 的呢？原因大致有以下三个：</p><ul><li>为了实现字符串常量池</li><li>为了线程安全</li><li>为了 HashCode 的不可变性</li></ul><p>更详细的原因，可以查看我之前写的一篇文章。<br>任何尝试从 final 类继承的行为将会引发编译错误，为了验证这一点，我们来看下面这个例子，Writer 类是 final 的。</p><pre><code class="line-numbers language-Java">public final class Writer &#123;
    private String name;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre><p>尝试去继承它，编译器会提示以下错误，Writer 类是 final 的，无法继承。<br><img src="https://www.qyihe.xyz/images/post/10.56.jpg"><br>不过，类是 final 的，并不意味着该类的对象是不可变的。</p><pre><code class="line-numbers language-Java">Writer writer = new Writer();
writer.setName(&quot;沉默王二&quot;);
System.out.println(writer.getName()); // 沉默王二
</code></pre><p>Writer 的 name 字段的默认值是 null，但可以通过 settter 方法将其更改为“沉默王二”。也就是说，如果一个类只是 final 的，那么它并不是不可变的全部条件。<br>如果，你想了解不可变类的全部真相，请查看我之前写的文章这次要说不明白immutable类，我就怎么地。突然发现，写系列文章真的妙啊，很多相关性的概念全部涉及到了。我真服了自己了。<br>把一个类设计成 final 的，有其安全方面的考虑，但不应该故意为之，因为把一个类定义成 final 的，意味着它没办法继承，假如这个类的一些方法存在一些问题的话，我们就无法通过重写的方式去修复它。<br><img src="https://www.qyihe.xyz/images/post/10.57.jpg"></p><h2 id="02、final-方法"><a href="#02、final-方法" class="headerlink" title="02、final 方法"></a>02、final 方法</h2><p>被 final 修饰的方法不能被重写。如果我们在设计一个类的时候，认为某些方法不应该被重写，就应该把它设计成 final 的。<br>Thread 类就是一个例子，它本身不是 final 的，这意味着我们可以扩展它，但它的 isAlive() 方法是 final 的：</p><pre><code class="line-numbers language-Java">public class Thread implements Runnable &#123;
    public final native boolean isAlive();
&#125;
</code></pre><p>需要注意的是，该方法是一个本地（native）方法，用于确认线程是否处于活跃状态。而本地方法是由操作系统决定的，因此重写该方法并不容易实现。<br>Actor 类有一个 final 方法 show()：</p><pre><code class="line-numbers language-Java">public class Actor &#123;
    public final void show() &#123;
        
    &#125;
&#125;
</code></pre><p>当我们想要重写该方法的话，就会出现编译错误：<br><img src="https://www.qyihe.xyz/images/post/10.58.jpg"><br>如果一个类中的某些方法要被其他方法调用，则应考虑事被调用的方法称为 final 方法，否则，重写该方法会影响到调用方法的使用。<br>一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？<br>我能想到的一点，就是前者不能被继承，也就是说方法无法被重写；后者呢，可以被继承，然后追加一些非 final 的方法。没毛病吧？看把我聪明的。<br><img src="https://www.qyihe.xyz/images/post/10.59.jpg"></p><h2 id="03、final-变量"><a href="#03、final-变量" class="headerlink" title="03、final 变量"></a>03、final 变量</h2><p>被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。之前被一个小伙伴问过，什么是 effective final，什么是 final，这一点，我在之前的文章也有阐述过，所以这里再贴一下地址：</p><pre><code class="line-numbers language-Java">www.itwanger.com/java/2020/0…
</code></pre><p>（1）final 修饰的基本数据类型<br>来声明一个 final 修饰的 int 类型的变量：</p><pre><code class="line-numbers language-Java">final int age = 18;
</code></pre><p>尝试将它修改为 30，结果编译器生气了：<br><img src="https://www.qyihe.xyz/images/post/10.60.jpg"><br>（2）final 修饰的引用类型<br>现在有一个普通的类 Pig，它有一个字段 name：</p><pre><code class="line-numbers language-Java">public class Pig &#123;
   private String name;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre><p>在测试类中声明一个 final 修饰的 Pig 对象：<br> final Pig pig &#x3D; new Pig();<br>如果尝试将 pig 重新赋值的话，编译器同样会生气：<br><img src="https://www.qyihe.xyz/images/post/10.61.jpg"><br>但我们仍然可以去修改 Pig 的字段值：</p><pre><code class="line-numbers language-Java">final Pig pig = new Pig();
pig.setName(&quot;特立独行&quot;);
System.out.println(pig.getName()); // 特立独行
</code></pre><p>（3）final 修饰的字段<br>final 修饰的字段可以分为两种，一种是 static 的，另外一种是没有 static 的，就像下面这样：</p><pre><code class="line-numbers language-Java">public class Pig &#123;
   private final int age = 1;
   public static final double PRICE = 36.5;
&#125;
</code></pre><p>非 static 的 final 字段必须有一个默认值，否则编译器将会提醒没有初始化：<br><img src="https://www.qyihe.xyz/images/post/10.62.jpg"><br>static 的 final 字段也叫常量，它的名字应该为大写，可以在声明的时候初始化，也可以通过 static 代码块初始化。</p><p>(4) final 修饰的参数</p><p>final 关键字还可以修饰参数，它意味着参数在方法体内不能被再修改：</p><pre><code class="line-numbers language-Java">public class ArgFinalTest &#123;
    public void arg(final int age) &#123;
    &#125;

    public void arg1(final String name) &#123;
    &#125;
&#125;
</code></pre><p>如果尝试去修改它的话，编译器会提示以下错误：<br><img src="https://www.qyihe.xyz/images/post/10.63.jpg"><br>。。。。。。</p><blockquote><p>转载于<a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.im/post/5ee414c76fb9a047dd2768ea#heading-39">沉默王二</a></p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"> <span class="post-copyright-meta">文章作者:</span> <span><a href="/">乔一禾</a></span></div><div class="post-copyright__type"> <span class="post-copyright-meta">文章链接:</span> <span><a href="https://www.isqqq.com/posts/53415/">https://www.isqqq.com/posts/53415/</a></span></div><div class="post-copyright__notice"> <span class="post-copyright-meta">版权声明:</span> <span>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="/">乔一禾</a></span></div></div><div class="tag_share clearfix"><div class="post_share sharethis-inline-share-buttons"></div></div><div class="pagination-post clearfix"><div class="prev-post"> <a href="/posts/224d98f5/"><img src="/img/1.webp" alt=""><div class="pagination-info"><div> 上一篇</div><div> Web记录</div></div></a></div><div class="next-post"> <a href="/posts/5700/"><img src="/img/3.webp" alt=""><div class="pagination-info"><div> 下一篇</div><div> 《解忧杂货店》读后感</div></div></a></div></div></div></div><div class="right"><ul><li class="right-li"><a href="/" class=""><b class="iconfont icon-none"></b><i class="iconfont icon-wenzhang"></i> 文章 <span>12</span></a></li><li class="right-li"><a href="/tags/" class=""><b class="iconfont icon-none"></b><i class="iconfont icon-biaoqian"></i> 标签 <span>9</span></a></li><li class="right-li"><a href="/categories/" class=""><b class="iconfont icon-none"></b><i class="iconfont icon-fenleiorguangchangorqita"></i> 分类 <span>5</span></a></li><li class="right-li"><a href="/photo"><b class="iconfont icon-none"></b><i class="iconfont icon-tuku"></i> 图片 <span class="photoNum">18</span></a></li><li class="right-li right-link"><a href="/link" class=""><b class="iconfont icon-none"></b><i class="iconfont icon-wenzhang"></i> 小伙伴 <span>2</span></a></li></ul><br><div class="right-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-text">一、Java 基本语法简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">01、数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F"><span class="toc-text">02、声明变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">03、数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">04、关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">05、操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E3%80%81%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">①、算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">②、逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E3%80%81%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">③、比较运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06%E3%80%81%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">06、程序结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07%E3%80%81%E7%BC%96%E8%AF%91%E7%84%B6%E5%90%8E%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-text">07、编译然后执行代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="toc-text">二、Java 基本数据类型简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E5%B8%83%E5%B0%94"><span class="toc-text">01、布尔</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81byte"><span class="toc-text">02、byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81short"><span class="toc-text">03、short</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04%E3%80%81int"><span class="toc-text">04、int</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06%E3%80%81float"><span class="toc-text">06、float</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07%E3%80%81double"><span class="toc-text">07、double</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08%E3%80%81char"><span class="toc-text">08、char</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Java-main-%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-text">三、Java main() 方法简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Java-%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">四、Java 的流程控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if-%E8%AF%AD%E5%8F%A5"><span class="toc-text">if 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-else-%E8%AF%AD%E5%8F%A5"><span class="toc-text">if-else 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-else-if-%E8%AF%AD%E5%8F%A5"><span class="toc-text">if-else-if 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-%E5%B5%8C%E5%A5%97%E8%AF%AD%E5%8F%A5"><span class="toc-text">if 嵌套语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-text">switch 语句的格式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E6%AF%94%E8%BE%83"><span class="toc-text">循环语句比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%9A%84-for-%E5%BE%AA%E7%8E%AF"><span class="toc-text">普通的 for 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-each"><span class="toc-text">for-each</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%99%90-for-%E5%BE%AA%E7%8E%AF"><span class="toc-text">无限 for 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="toc-text">while 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-while-%E5%BE%AA%E7%8E%AF"><span class="toc-text">do-while 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break"><span class="toc-text">break</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#continue"><span class="toc-text">continue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Java-%E5%8C%85%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-text">五、Java 包的简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8C%85"><span class="toc-text">01、创建一个包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81%E4%BD%BF%E7%94%A8%E5%8C%85"><span class="toc-text">02、使用包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81%E5%85%A8%E5%90%8D"><span class="toc-text">03、全名</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81Java-%E5%88%B0%E5%BA%95%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-text">六、Java 到底是值传递还是引用传递</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92-VS-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-text">01、值传递 VS 引用传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">02、基本类型的参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">03、引用类型的参数传递</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81Java-%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">七、Java 的类和对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81Java-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">八、Java 构造方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Java-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">九、Java 抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84-5-%E4%B8%AA%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-text">01、抽象类的 5 个关键点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">02、什么时候用抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81%E5%85%B7%E4%BD%93%E7%A4%BA%E4%BE%8B"><span class="toc-text">03、具体示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81Java-%E6%8E%A5%E5%8F%A3"><span class="toc-text">十、Java 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E6%8E%A5%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">01、接口是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">02、定义接口的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">03、接口可以做什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">04、接口与抽象类的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Java-%E7%BB%A7%E6%89%BF"><span class="toc-text">十一、Java 继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81this-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">十二、this 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E6%B6%88%E9%99%A4%E5%AD%97%E6%AE%B5%E6%AD%A7%E4%B9%89"><span class="toc-text">01、消除字段歧义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">02、引用类的其他构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">03、作为参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04%E3%80%81%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-text">04、链式调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05%E3%80%81%E5%9C%A8%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">05、在内部类中访问外部类对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">十三、super 关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-text">十四、重写和重载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">十五、static 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-text">01、静态变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">02、静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">03、静态代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04%E3%80%81%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">04、静态内部类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81Java-%E6%9E%9A%E4%B8%BE"><span class="toc-text">十六、Java 枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81%E5%86%85%E9%83%A8%E6%9E%9A%E4%B8%BE"><span class="toc-text">01、内部枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81%E6%9E%9A%E4%B8%BE%E5%8F%AF%E7%94%A8%E4%BA%8E-switch-%E8%AF%AD%E5%8F%A5"><span class="toc-text">02、枚举可用于 switch 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81%E6%9E%9A%E4%B8%BE%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">03、枚举可以有构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04%E3%80%81EnumSet"><span class="toc-text">04、EnumSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05%E3%80%81EnumMap"><span class="toc-text">05、EnumMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06%E3%80%81%E5%8D%95%E4%BE%8B"><span class="toc-text">06、单例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07%E3%80%81%E6%9E%9A%E4%B8%BE%E5%8F%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%A4%E4%BA%92"><span class="toc-text">07、枚举可与数据库交互</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E3%80%81final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">十七、final 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E3%80%81final-%E7%B1%BB"><span class="toc-text">01、final 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02%E3%80%81final-%E6%96%B9%E6%B3%95"><span class="toc-text">02、final 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%E3%80%81final-%E5%8F%98%E9%87%8F"><span class="toc-text">03、final 变量</span></a></li></ol></li></ol></div></div><div class="btn"><div class="btn-backtotop"><a href="javascript:;" rel="external nofollow noreferrer" class="iconfont icon-tubiaolunkuo-"></a></div></div></div><div class="comments comment-wrapper"><div class="comment-left"><div id="tcomment"></div></div><div class="comment-right"></div></div><script src="https://cdn.staticfile.org/twikoo/1.6.10/twikoo.all.min.js"></script><script>twikoo.init({envId:"yun-9gjlkebg325f1ee7",el:"#tcomment",region:"ap-shanghai"})</script><script>let copyEnable="false";function fn(){document.addEventListener("copy",(function(t){let n=t.clipboardData||window.clipboardData;if(!n)return;let e=window.getSelection().toString();e&&(t.preventDefault(),n.setData("text/plain",e+"\r\n著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。\n作者: 乔一禾\n原文地址: https://www.isqqq.com/posts/53415/"))}))}"true"==copyEnable&&fn()</script><footer><div class="footer wrapper"> <span>本站原创内容版权遵循 CC-BY-NC-SA 协议规定,转载请注明出处.本站部分资源收集于网络,只做学习和交流使用,版权归原作者所有.</span><div class="copyright"> &copy <span>2020</span> - <span>2023</span> By <a href="#">乔一禾</a></div><div class="framework-info"> <span>框架</span> <a href="#">Hexo</a> | <span>主题</span> <a href="https://www.isqqq.com">Star</a></div><div class="footer_custom_text"> <span>HOST</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://cloud.tencent.com/"><img src="https://www.isqqq.com/img/tencent.svg" alt="腾讯云"></a> | CDN <a target="_blank" rel="noopener external nofollow noreferrer" href="https://cloud.tencent.com/"><img src="https://www.isqqq.com/img/tencent.svg" alt="腾讯云"></a> And <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.upyun.com/"><img src="https://www.isqqq.com/img/youpaiyun.png" alt="又拍云"></a><br> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://beian.miit.gov.cn/" class="beian">渝ICP备2022014543号-1</a></div></div></footer><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=642a95d36134c500128ce986&product=inline-share-buttons&source=platform" async="async"></script><script src="/js/index.js"></script><script src="https://cdn.staticfile.org/twikoo/1.6.10/twikoo.all.min.js"></script><script src="/libs/prism/prism.js" async></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>