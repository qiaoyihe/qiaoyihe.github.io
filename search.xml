<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记一次webpack</title>
      <link href="/posts/19b17f74/"/>
      <url>/posts/19b17f74/</url>
      
        <content type="html"><![CDATA[<h2 id="1-webpack概述"><a href="#1-webpack概述" class="headerlink" title="1. webpack概述"></a>1. webpack概述</h2><blockquote><p>webpack 是一个基于 NodeJS 的 <strong>静态模块打包器 (module bundler)</strong><br>集成了 webpack, 所以才能对各类文件进行打包处理 </p></blockquote><p><a href="https://webpack.js.org/">webpack官网</a></p><h3 id="1-1-webpack-能做什么"><a href="#1-1-webpack-能做什么" class="headerlink" title="1.1 webpack 能做什么"></a>1.1 webpack 能做什么</h3><p>webpack是一个 静态模块 打包器</p><ol><li>语法转换<ul><li>less&#x2F;sass转换成css</li><li>ES6转换成ES5</li><li>typescript转换成原生js</li><li>…</li></ul></li><li>html&#x2F;css&#x2F;js 代码压缩合并 (打包)</li><li>webpack可以在开发期间提供一个开发服务器， 提高开发效率</li></ol><h3 id="1-2-webpack-基本使用"><a href="#1-2-webpack-基本使用" class="headerlink" title="1.2 webpack - 基本使用"></a>1.2 webpack - 基本使用</h3><h4 id="1-2-1-webpack-打包演示"><a href="#1-2-1-webpack-打包演示" class="headerlink" title="1.2.1 webpack 打包演示"></a>1.2.1 webpack 打包演示</h4><p> <strong>1.</strong> 建目录  dist    src&#x2F;main.js<br><strong>2.</strong>  初始化</p><pre><code class="line-numbers language-js">   yarn init -y</code></pre><p><strong>3.</strong>  安装依赖包  ( -D: 将安装包作为开发阶段的依赖, 只在开发阶段使用, 实际上线不加)<br>   dependencies  项目依赖<br>   devDependencies 开发依赖</p><pre><code class="line-numbers language-js">yarn add webpack  webpack-cli  -D</code></pre><p><strong>4.</strong>  配置scripts </p><pre><code class="line-numbers language-js">scripts: &#123;    &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;&#125;</code></pre><p>   <strong>–config  webpack.config.js</strong> 这个配置文件名为默认值, 不加也会默认找这个文件</p><p><strong>5.</strong>  提供 webpack.config.js </p><p>   基础版本</p><pre><code class="line-numbers language-jsx">module.exports = &#123;  // 入口:   entry: &#39;./src/main.js&#39;&#125;</code></pre><ol start="6"><li><p>执行脚本</p><pre><code class="line-numbers language-jsx">yarn build</code></pre></li></ol><p>小测试:</p><p>​假定在main.js中导入一个a.js,  多个文件需要打包, wepack会打包成一个文件, 可以节约请求的次数</p><pre><code class="line-numbers language-js">import &#39;./js/a.js&#39;console.log(&#39;这是main模块&#39;)</code></pre><h3 id="1-3-package-json-中-scripts的使用说明"><a href="#1-3-package-json-中-scripts的使用说明" class="headerlink" title="1.3 package.json 中 scripts的使用说明"></a>1.3 package.json 中 scripts的使用说明</h3><p>在package.json文件中, 可以配置 scripts …  配置自己的命令</p><pre><code class="line-numbers language-js">&quot;scripts&quot;: &#123;    &quot;sta&quot;: &quot;yarn add mime&quot;,    &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;&#125;</code></pre><p><strong>运行方式:  yarn xx || npm run xx</strong></p><h3 id="1-4-基本配置-配置入口出口模式"><a href="#1-4-基本配置-配置入口出口模式" class="headerlink" title="1.4 基本配置 - 配置入口出口模式"></a>1.4 基本配置 - 配置入口出口模式</h3><p>参考文档:   <a href="https://webpack.docschina.org/concepts#entry">https://webpack.docschina.org/concepts/#入口-entry-</a> </p><pre><code class="line-numbers language-js">const path = require(&#39;path&#39;)module.exports = &#123;  // entry: 配置入口文件 (从哪个文件开始打包)   entry: &#39;./src/main.js&#39;,  // output: 配置输出 (打包到哪去)  output: &#123;    // 打包输出的目录 (必须是绝对路径)    path: path.join(__dirname, &#39;dist&#39;),    // 打包生成的文件名    filename: &#39;main.js&#39;  &#125;,  // 打包模式 production 压缩/development 不压缩  mode: &#39;development&#39;&#125;</code></pre><h2 id="2-webpack-插件-和-loaders的配置"><a href="#2-webpack-插件-和-loaders的配置" class="headerlink" title="2. webpack - 插件 和 loaders的配置"></a>2. webpack - 插件 和 loaders的配置</h2><h3 id="2-1-自动生成html-html-webpack-plugin-插件"><a href="#2-1-自动生成html-html-webpack-plugin-插件" class="headerlink" title="2.1 自动生成html - html-webpack-plugin 插件"></a>2.1 <strong>自动生成html</strong> - <code>html-webpack-plugin</code> 插件</h3><p>每次都要将 public&#x2F;index.html 手动拷贝到 dist 目录， 手动引入打包后的 js， 太麻烦</p><p>所以一般会用一个插件, 会自动拷贝到 dist下, 并自动引入</p><ol><li><p>下载  </p><pre><code class="line-numbers language-js">yarn add html-webpack-plugin  -D</code></pre></li><li><p><strong>在<code>webpack.config.js</code>文件中，引入这个模块</strong> :</p><pre><code class="line-numbers language-js">// 引入自动生成 html 的插件const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)</code></pre></li><li><p>配置</p><pre><code class="line-numbers language-js">plugins: [  new HtmlWebpackPlugin(&#123; template: &#39;./public/index.html&#39; &#125;)]</code></pre></li></ol><blockquote><p><strong>配置好了之后, public 目录的 index.html 就不需要引入打包后的文件了, 会自动被插件生成 html 引入</strong></p></blockquote><p><code>public/index.html</code></p><pre><code class="line-numbers language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;  &lt;ul&gt;    &lt;li&gt;我是第1个li&lt;/li&gt;    &lt;li&gt;我是第2个li&lt;/li&gt;    &lt;li&gt;我是第3个li&lt;/li&gt;    &lt;li&gt;我是第4个li&lt;/li&gt;    &lt;li&gt;我是第5个li&lt;/li&gt;    &lt;li&gt;我是第6个li&lt;/li&gt;    &lt;li&gt;我是第7个li&lt;/li&gt;    &lt;li&gt;我是第8个li&lt;/li&gt;    &lt;li&gt;我是第9个li&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;!-- 打包后的文件会被自动引入, 不需要手动引入了 --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="2-2-webpack中处理-css-文件-css-loader"><a href="#2-2-webpack中处理-css-文件-css-loader" class="headerlink" title="2.2 webpack中处理 css 文件 - css-loader"></a>2.2 webpack中处理 css 文件 - <code>css-loader</code></h3><p>webpack默认只认识 js 文件和 json文件, 但是webpack 可以使用 <a href="https://www.webpackjs.com/concepts/loaders">loader</a> 来加载预处理文件, 允许webpack也可以打包 js之外的静态资源。</p><p>所以webpack如果要处理其他文件类型, <strong>记得要先配置对应的 loader</strong></p><p><strong>需求: 去掉小圆点, 新建 css 目录</strong></p><ol><li><p>安装依赖</p><pre><code class="line-numbers language-js">yarn add style-loader css-loader -D</code></pre></li><li><p>配置</p><pre><code class="line-numbers language-js">module: &#123;  // loader的规则  rules: [    &#123;      // 正则表达式，用于匹配所有的css文件      test: /\.css$/,      // 先用 css-loader 让webpack能够识别 css 文件的内容      // 再用 style-loader 将样式, 以动态创建style标签的方式添加到页面中去      use: [ &quot;style-loader&quot;, &quot;css-loader&quot;]    &#125;  ]&#125;,</code></pre></li></ol><h3 id="2-3-分离-css-文件-mini-css-extract-plugin"><a href="#2-3-分离-css-文件-mini-css-extract-plugin" class="headerlink" title="2.3 分离 css 文件 mini-css-extract-plugin"></a>2.3 分离 css 文件 <code>mini-css-extract-plugin</code></h3><p>我们上面的操作，使得<code>css</code>和<code>js</code>文件混杂在一起了，那有没有什么办法把<code>css</code>分离出来呢？ </p><p>插件:</p><pre><code class="line-numbers language-js">mini-css-extract-plugin</code></pre><ol><li><p>安装依赖包</p><pre><code class="line-numbers language-js">yarn add mini-css-extract-plugin -D</code></pre></li><li><p><strong>在<code>webpack.config.js</code>文件中，引入这个模块</strong> </p><pre><code class="line-numbers language-js">// 引入分离 css 文件的 模块const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)</code></pre></li><li><p>配置loaders</p><pre><code class="line-numbers language-js">// 模块加载module: &#123;  // loader的规则  rules: [    // 配置 css 文件的解析    &#123;      test: /\.css$/,      use: [ // 根据官方文档写的，注意&#39;css-loader&#39;的书写位置        MiniCssExtractPlugin.loader,        &#39;css-loader&#39;      ]    &#125;,  ],&#125;</code></pre></li><li><p>插件的配置</p><pre><code class="line-numbers language-js">plugins: [  new HtmlWebpackPlugin(&#123; template: &#39;./public/index.html&#39; &#125;),    // 定义打包好的文件的存放路径和文件名  new MiniCssExtractPlugin(&#123;          filename:&#39;css/index.css&#39;  &#125;)  ],</code></pre></li></ol><h3 id="2-4-webpack-中处理-less-less-loader"><a href="#2-4-webpack-中处理-less-less-loader" class="headerlink" title="2.4 webpack 中处理 less - less-loader"></a>2.4 webpack 中处理 less - <code>less-loader</code></h3><ol><li><p>下载依赖包</p><p>注意: 解析less文件需要识别 less 语法, 所以除了 <code>less-loader</code>  需要额外下载 <code>less</code> 包  </p><p>less-loader: 将less转换成 css</p><pre><code class="line-numbers language-js">yarn add less  less-loader  -D</code></pre></li><li><p>配置</p><pre><code class="line-numbers language-js">// 配置 less 文件的解析&#123;  test: /\.less$/,  use: [    // 分离出 css 内容    MiniCssExtractPlugin.loader,     &#39;css-loader&#39;,    &#39;less-loader&#39;   ]&#125;</code></pre></li></ol><h3 id="2-5-webpack-中处理图片-内置的-asset-module"><a href="#2-5-webpack-中处理图片-内置的-asset-module" class="headerlink" title="2.5 webpack 中处理图片 - 内置的 asset module"></a>2.5 webpack 中处理图片 - 内置的 asset module</h3><p>我们试了一下，在项目中使用一下 img 图片。结果就报错了，难道<code>webpack</code>连图片也认不出来吗？</p><pre><code class="line-numbers language-jsx">import imgObj from &#39;./imgs/01.jpg&#39;const img = document.creatreElement(&#39;img&#39;)img.src = imgObjapp.appendChild(img)</code></pre><p>没有错，的确认不出来,   此时需要用webpack5 内置的 asset 资源处理模块，来处理图片资源。</p><p>webpack5 处理资源： <a href="https://webpack.docschina.org/guides/asset-modules/">https://webpack.docschina.org/guides/asset-modules/</a></p><p><code>tips</code>: webpack4 中来处理图片的问题,  主要用到 <code>url-loader</code>  和   <code>file-loader</code> 两个模块， 现 webpack5 已集成，无需安装。</p><p>*<em>配置 rules 基本规则：</em></p><pre><code class="line-numbers language-js">&#123;  test: /\.(png|jpg|gif|jpeg)$/i,  type: &#39;asset&#39;&#125;</code></pre><p>（1）对于小于 8k 的图片，会自动转 base64 字符串（节约请求次数，成本：放大约30%的图片体积大小）</p><p>（2）对于大于 8k 的图片，会生成单独文件引入。</p><p><strong>配置图片的打包输出目录：</strong></p><p>默认是直接输出到了 dist 根目录, 可以通过  generator  进行配置</p><pre><code class="line-numbers language-js">&#123;  test: /\.(png|jpg|gif|jpeg)$/i,  type: &#39;asset&#39;,  generator: &#123;    filename: &#39;images/[hash][ext]&#39;  &#125;&#125;</code></pre><h3 id="2-6-webpack-配置字体图标-和图片一致"><a href="#2-6-webpack-配置字体图标-和图片一致" class="headerlink" title="2.6 webpack 配置字体图标 - 和图片一致"></a>2.6 webpack 配置字体图标 - 和图片一致</h3><p>字体图标 和 图片的配置一致</p><pre><code class="line-numbers language-js">// 处理字体图标的解析&#123;  test: /\.(eot|svg|ttf|woff|woff2)$/,  type: &#39;asset&#39;,  generator: &#123;    filename: &#39;fonts/[hash][ext]&#39;  &#125;&#125;</code></pre><h3 id="2-7-webpack-使用-babel-处理高版本的-js-语法"><a href="#2-7-webpack-使用-babel-处理高版本的-js-语法" class="headerlink" title="2.7 webpack 使用 babel 处理高版本的 js 语法"></a>2.7 webpack 使用 babel 处理高版本的 js 语法</h3><p>webpack 默认仅内置了 模块化的 兼容性处理   <code>import  export</code></p><p>babel 的介绍 &#x3D;&gt; 用于处理高版本 js语法 的兼容性</p><ol><li><p>安装包</p><pre><code class="line-numbers language-js">yarn add -D babel-loader @babel/core @babel/preset-env</code></pre></li><li><p>配置规则</p><pre><code class="line-numbers language-js">module: &#123;  rules: [    &#123;      test: /\.js$/,      exclude: /(node_modules)/,      use: &#123;        loader: &#39;babel-loader&#39;,        options: &#123;          presets: [&#39;@babel/preset-env&#39;]        &#125;      &#125;    &#125;  ]&#125;</code></pre></li></ol><h3 id="2-8-webpack-Source-Map"><a href="#2-8-webpack-Source-Map" class="headerlink" title="2.8 webpack - Source Map"></a>2.8 webpack - Source Map</h3><h4 id="2-8-1-什么是Source-Map"><a href="#2-8-1-什么是Source-Map" class="headerlink" title="2.8.1 什么是Source Map?"></a>2.8.1 什么是Source Map?</h4><p><strong>Source Map 就是一个信息文件，里面储存着位置信息。</strong></p><p>也就是说，Source Map 文件中存储着代码压缩混淆前后的对应关系。有了它，出错的时候，除错工具将<strong>直接显示原始代码，而不是转换后的代码</strong>，能够极大的方便后期的调试。</p><h4 id="2-8-2-开发环境下的-Source-Map"><a href="#2-8-2-开发环境下的-Source-Map" class="headerlink" title="2.8.2 开发环境下的 Source Map"></a>2.8.2 开发环境下的 Source Map</h4><p>在开发环境下，webpack 默认启用了 Source Map 功能。当程序运行出错时，可以直接在控制台提示错误行的位置，并定位到具体的源代码, 但错误行数有时会对不上:</p><p>需要配置:</p><pre><code class="line-numbers language-js">// eval-source-map 仅限在&quot;开发模式&quot;下使用, 不建议在&quot;生产模式&quot;下使用// 此选项生产的Source Map能够保证&quot;运行时报错的行数&quot;与&quot;源代码的行数&quot;保持一直// devtool: &#39;eval-source-map&#39;,devtool: &#39;eval-source-map&#39;</code></pre><h4 id="2-8-3-生产环境下的-Source-Map"><a href="#2-8-3-生产环境下的-Source-Map" class="headerlink" title="2.8.3 生产环境下的 Source Map"></a>2.8.3 生产环境下的 Source Map</h4><p>在生产环境下，如果没有配置devtool 选项，则最终生成的文件中不启用Source Map功能。这能够防止原始代码通过Source Map 的形式暴露给别有所图之人。</p><p><strong>需求:  在生产环境下，只想定位报错的具体行数，但不想暴露源码。主要是方便快速定位到bug, 快速修复!</strong></p><p>此时可以配置:</p><pre><code class="line-numbers language-js">devtool: &#39;nosources-source-map&#39;</code></pre><h4 id="2-8-4-Source-Map-的最佳实践"><a href="#2-8-4-Source-Map-的最佳实践" class="headerlink" title="2.8.4 Source Map 的最佳实践"></a>2.8.4 Source Map 的最佳实践</h4><ul><li><p>开发环境下： </p><p>建议把 <code>devtool </code>的值设置为 <code>eval-source-map</code>  </p><p>好处：可以精准定位到具体的错误行。</p></li><li><p>生产环境下：</p><p> 建议关闭 <code>Source Map </code>或将 <code>devtool </code>的值设置为 <code>nosources-source-map</code> </p><p>好处：防止源码泄露，提高网站的安全性。</p></li></ul><h3 id="2-9-webpack-watch"><a href="#2-9-webpack-watch" class="headerlink" title="2.9 webpack - watch"></a>2.9 webpack - watch</h3><h4 id="使用watch-mode-观察模式"><a href="#使用watch-mode-观察模式" class="headerlink" title="使用watch mode(观察模式)"></a>使用watch mode(观察模式)</h4><p>直接执行<code>yarn build</code>命令的话，就是执行一次编译一次, 多次调试会显得很麻烦,  我们可以配置<code>watch</code>模式,  来监视项目中的文件更改，并在文件更改时重新编译; </p><p>换句话说，修改了内容之后只要刷新浏览器就可以看到最新的效果,  不需要再手动执行<code>yarn build</code>命令重新编译了。</p><ol><li>运行时在命令后面加<code>--watch</code></li></ol><pre><code class="line-numbers language-js">yarn build --watch</code></pre><ol start="2"><li>webpack.config.js中配置</li></ol><pre><code class="line-numbers language-js">module.exports = &#123;  watch: true, // 启用 watch 模式  watchOptions: &#123;    // 忽略监视node_modules文件夹中的内容变化    ignored: /node_modules/,  &#125;   &#125;  </code></pre><blockquote><p>执行一次编译多次</p><p>只要你修改了相关的文件，就会重新触发编译。这个比较适合多次反复调试的情况。</p></blockquote><h3 id="2-10-webpack-开发服务器"><a href="#2-10-webpack-开发服务器" class="headerlink" title="2.10 webpack - 开发服务器"></a>2.10 webpack - 开发服务器</h3><h4 id="2-11-webpack-dev-server自动刷新"><a href="#2-11-webpack-dev-server自动刷新" class="headerlink" title="2.11 webpack-dev-server自动刷新"></a>2.11 webpack-dev-server自动刷新</h4><ol><li>下载</li></ol><pre><code>yarn add webpack-dev-server -D</code></pre><ol start="2"><li>配置scripts</li></ol><pre><code class="line-numbers language-js">&quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;,    &quot;dev&quot;: &quot;webpack serve --config webpack.config.js&quot;&#125;</code></pre><h4 id="2-12-webpack-dev-server-的配置"><a href="#2-12-webpack-dev-server-的配置" class="headerlink" title="2.12 webpack-dev-server 的配置"></a>2.12 webpack-dev-server 的配置</h4><p>webpack-dev-server配置文档:  <a href="https://webpack.docschina.org/configuration/dev-server/#devserverafter">https://webpack.docschina.org/configuration/dev-server/#devserverafter</a></p><pre><code class="line-numbers language-js">devServer: &#123;  port: 3000, // 端口号  open: true // 自动打开浏览器&#125;</code></pre><blockquote><p>webpack-dev-server和watch的区别:</p><p>webpack-der-server 监测到代码变化后，浏览器可以看到及时更新的效果，但是并没有自动打包修改的代码</p><p>yarn build –watch 在监测到代码变化后自动打包修改的代码</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Star</title>
      <link href="/posts/69e9f52a/"/>
      <url>/posts/69e9f52a/</url>
      
        <content type="html"><![CDATA[<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="本地搜索插件"><a href="#本地搜索插件" class="headerlink" title="本地搜索插件"></a>本地搜索插件</h3><p>如想使用文章搜索：请安装以下插件</p><pre><code class="line-numbers language-x">$ npm install hexo-generator-search --save</code></pre><p>在根目录下的_config.yam 下添加：</p><pre><code class="line-numbers language-Java">search:  path: search.xml  field: post  content: true</code></pre><h2 id="阅读统计"><a href="#阅读统计" class="headerlink" title="阅读统计"></a>阅读统计</h2><p>请安装以下插件</p><pre><code class="line-numbers language-Java">$ npm install hexo-symbols-count-time</code></pre><p>在根目录下的_config.yam 下添加：</p><pre><code class="line-numbers language-Java">symbols_count_time:  symbols: true  time: true  total_symbols: true  total_time: true  exclude_codeblock: false  awl: 2  wpm: 200  suffix: &quot;mins.&quot;</code></pre><h2 id="渲染代码高亮"><a href="#渲染代码高亮" class="headerlink" title="渲染代码高亮"></a>渲染代码高亮</h2><p>须在在根目录下的_config.yam 下添加：</p><pre><code class="line-numbers language-Java">marked:  langPrefix: line-numbers language-</code></pre><p>待更新。。。</p>]]></content>
      
      
      <categories>
          
          <category> Star </category>
          
          <category> Hexo </category>
          
          <category> 主题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Star </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web记录</title>
      <link href="/posts/224d98f5/"/>
      <url>/posts/224d98f5/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="19a85dcd8450e5882843fc49443cce78a75884a1583d240584f31ae01f996b3d">ac0382c3c3a491dd93b3f2bb1edd43d162d60a4b2ee4d08b32ad821cd3b723b16994af76b5ea67724d88577a482ec0f72846241efb47995eeca2a7abad4369ee791d07704a5aabf179eda4e4f3fc27b52d0061a100a4fa60981367151c89094b5bdddf1c4bde6fc869611a0e4879f7eef2dfd9ca0499c211d9adafe4ff20fac9bced90fecabd1f5abda3db381d740a4420045c9052993e6b7b407961c21a72968bc1d797b5db602940d3e8ee8f20f529986e14133fe45957d5b256f52e6b9493043a371b392d0e7a9f5c408b51233475a3590a0cd557a865326adc02aef352ee56e2c207fd2f745a2b35cbecf364ef29b1f32e4de5d3daae79eed817d57e8c8ed11435ad6d5d87aa2e1bf5d4ffa29b04d2625ced68d9a95d86651830e59d92d65ba7d57698f39231fec2d0d001f6df060761b7b4aba7e9a688df550bbb47e5f32f2eaa9c58e13b5a093247bd1765ad6d3fa66a8cfe3e7e511d25955d3d88ba52f350404e23d68b9bca4ddfb02d74ccc0e500206e85fef19021fd0c61c466169c2033539e36d615ee107680d444e0bfbeaef748e60b2bd99793dbb9030d1e35bc330b27c2cabcef36f2fdaa513c662613b25280e29681a8825e5f09d16f6d54deaea52650556b85a6d8f6d6692f67a3ccb8710d61a6f49839afba9eb1878d05285a3180e48d5887afd6d528079f98db120cae5c22f3175ecd341f37b3f1ee90b17bc71c107a3af6a375c446487b7ca36d5bbfb58d14ae0ea0e334ca88210acda68d699df8c33a469ffe200545747342223cac2ca07e0e85a3de26f87c362330e8e073fe801e4d8a899c8199d61197539e1df8915ba392fc7844aa347a9c6430fd60796fd51cef5ea17e06e1fe7523d13b1323cab566c39109f657e799dd43178654a14555968f7b889195c6d5a717afe6b00ba398637299e276e75c07dc1b0710c68e0e3c9374088a58f7fc6669549b8be13a6cb9ae8dbaace71ea0b2453a1d2c136ceaecededf4d59787655da9338710406921a200e0da5d28b4398dfe434951a4ac00bd99d5e45395eb50ec922854ad527bb7c704bf1e149276de8afd7f5f1ce84e7436ad1620a0ce887aea9857904ce131dc52645e68b32c98d2f9c052515fc1ec1b087969f9d18786325834e7ff3e4773bb5413ea8ab2f865104003bd7dc0cec191cda48360362e5c925f3c1d66549879790fdc5be538a7366ed27f031f7351fdac2a539dde4d36f2602624cda46832dfe72dfc8f3604da3dc1322e714b2329d6d01744dac2d3b2db989cf58dc0c804d86dd70c1e87cfb128906b9ac2e26d871ae6230b70208043bd5f97cbbcb7576b7c0354f0a6613372cde13fd85e756ad7fd77e9b427baf9ed757f6b167dc44244048886467bf282b77afa4b61cdf4a35f1690d5e797d1d2e2e446bb91dfc40baa298ff399c4ade390c2cc866ea2fece4a9b59d5364aa46d99773288a4e5d5c09bd07965aaa53a5cad93eaba66754e9fc36c10f9e89e84bcf3eb0da99aca9d5cebc17f724b85bd73c7491d2e7acb4e3f4dd2fd9951a1a834a24ff42e8fc139863d5fcde5461b00744a512196dbe9ea483d178f6eec986c50187957f012c5a016426cffee53ff467e4ae5ceba130f125c9730b0e3e9bdce1f2781e06ae4d2fc9aeffb11ef84c23b3cfac22d820e8168f6e0bf8b263d85931d38547e97640dc5c622d5701bdca88902b14ab86347331234baa58e049acc56d13487a25659d24b57ccb5dfc43cd1f6867940d9ee2b978fd7de4fa77d5d5b9eace0339621140fba213e785e1a17a61e19703af5742f0bdff680bb2c1ad079d9231f2a36d5ef267e2bf32cb7d0819a3534018845c33c6c604e2783c16821a3a5bf930973b26516958a8f83d8c2491fe1424ba5a61db391634f65b885543a7872499ca5b3ef6edad2169643715cbc8064fa989671f6f4385c08547c7b52e7bb406a1b9617e361867d12962a6d6054a0462903d8e43b7fdef246a1d85e1fa058dc6e64878ca215d93e65d0b5585a142aef38f2886f1e55f31dca162365ccaf02b9b530f6981bdb5ce73c072dfa8b4f9822399dc1686ef1bce75174cbce0ce2876d4fb013060b911dc250e129d62ae2908f3c73e1c4f8cf625ace7331e7d88f40a8805df4aa3e756ea2d9479101ae1ef866123ef9355456bddc9b368b75d02667ba67513b8e1f1dfa02f72f3c2d23af3b4adb922d3e0c2a8722c7f273778ef482ff473d1c8578408a0cf72304f49af2ee6db0a3ccfab5a6e53ef8c05ab883f0009253982ad1a59f31c5c6934d2dc13c2799d6289bee9fdd396bcf0b65486def4b68b12ff7fa811cbc478e2db3179d707fa6dbaed16dcfc9e9d672de770b565ab46b36937ad96013ec830140942056f5dad9435ccb31f5af28b158bbf36919cd8dbfebddef3f4e7d03c89bd20199647975f503511dfe710ebebbd906c8dde21e06b79fa0030b5192615f6db74879f7a01ee2074bc1868be2830ad934599ed0310df1e261bb93354d3d2c65f3a7513db2bd72d585f9279a5a4abf76eca6c29a785b030ff911e53dfc3b87a8061a4c6a8f0d36c179d297de0031be90b637adc4056d35fcdc4b3020e1bef786e717f291e3b049688a7c2c60ddfac3b944736550f691647cca29038ce129f6572db34950f60b43bc348b1696ca45b5e0d4b92f02772c078cebab194ceeb861bb0b5c3a0917a46f836967742b2808fa432f649cbbba884302cbbedc32224fb7b68c54aa1b5622e61ff1a95a250c5ec80fdd6351c0321ca1e27e24066b95209b78d661be79538f8cb5b789188a2edd75ccf9bd6f9569fb4cdb68085fea8196443be965c5ef1984f7c47cdac9854715c84a389a93a2727104cc5ab8e0348aebe194b0438d3da5afacfb981bbe3a8e175ac4aedbd09499f43cbf2d9ebcafa32866a2597755ea4680b90995fcfe3a8c6bbbddee68579f292b62070bf6a36b4bca1594b1959e530c03660325982f07622059872e64a0115898fcdff56f16328499ca47866d554531be82a9ad4b58833db38f727e21165b52643f2aa5e0e5e861f30d2cd2c81f1cec2c8b0afa31b12ca7b141486b29f75fe2f0fbe6552cce5ded13caf1aca95e52ed2173d9df6893d1ff73111a2786f99a34479adb846fd1914ca811dc9c78b7f531fcf8bf4defb76565a1531edbe3b994516ccfb698c272a06db020ea619cc3ffeb53a5f2be226f7ba87edf3f18b3d581ab1245fe5b428f02dd19bfed0cec6764f46ce45098515c01335fc97c5f225ebe24327475060a5462faeebed3211cc2dbb74d31133f6f3e6897c0b4ecec2340dd3bde27f3ea68a28a725813137ca473c549075e69acd09574ebcd82796c0a12f50e2edeebadf5f239c264bbd8d64665d4f9cf8c43852c23895c5821cdc0f8b86dd0a931f9709abd6fcaf5da278aba2f66cafdd28fbc1b3efe7db7955c8a32bbe77fe16ea41add72c66318df0810b4e245bb3c9068cfe0ebe85354475d723f9b93c2de31b8696db9c42a5f9c0ee47a05456ddcd4164254af8433c37d387dc697bfa4597dbaeffd7055c0e813487de47897af5fd29756b322447bb4a59b8359f6318fdab4c3b1b94b30770c2faeeb2df12380e832db2b78918989a006f1743d3a468c1591eb4faa76098c5c7e25e82851fce67575dbe28013326b044eb7340dd50c95f8c70b1a929ed6b2074205afbc44c20ad93c5bba00069576f3bf79635c09b12ffe34b236f829b0877f3660c8429e135a9cf5bd4fb3441231a3cc0d9d357b778fe7502d4ba1c5c9c9b4bbfc6f7413239121e79c94be0b4a7c8318cf9d75b60b4021ab5a9d033558decf2c28165102b6580ed5cd6beb04a6fc2608b2bb71e043d1d05f327faf5b51e85734d5e9c0cd210f21bb95b32fb90fabcde4fee9b46b2023197d518dca9606241c3303b2bb5420a0a5634604d70a3661f5148f8b3b7b07ed30586801a73af52d4c86c284e498b8dd105a3bd7c63ae61dd078ca866acc6768398a6185eeddaa1db3789fb5b06b6f5a4d03a14d221d46ac1fedcaebc40f1aad0ee8987e7c0b473bc5c5375c07e6f74a85ae20e59a43b96f149a2c2b5f6b10c3059f243c75b9fe430c4aef686106165449c0630c93dd6311fab9f8e18aaa65ac29f61738723b855dfac2607c5beb6e54f907813401c00dce4abacfc21dccf85ed4fe215634e0878561c07ebdaab031c5b3b38eec12c06489eb2f72c6132b493d5e8fdee713f0d7a745eda03727a880df2e6301c6cdc6fc7144cae59ad58acaa2c8907a569b028b133f3657dba274b5ee5660958ac2ce5d40bba060fd4cbf4dfc3466c9fdd6d2ef71e8608a20f8cb7df5fd09f1afb9d9ed3324f2ccb21f71a020b945e7e0345d1420144671203dd53860669914ffd4d4a03948810f174ffa42d9ca33703f84e518ae14fb3623333a838ee8354f4f5a1de2a98019f2959d67873faf13978be7ca5996ae8708e6697b69be5fee93557dd5b18b9824bfb36c6af732bef3942c993a2add26ad8d089729dbb81b6e049171bb76d2f3c0be5ad8d28048bf5199b34ff5614a5e7235bd66d71c8fee1b3e32251fad07efc7ad4b39cc7b6c28835530d6904cb78071adae69e495105d3a13aa17e0349fb964f8dcae30a020328dfa5df0a12b5c577e0479e6dfcaf90f50f9768e5fc5049631c267737c5048e142bad38cd855dc9cd10dea57b4e4961a19f112e76bbcd2a54865c16c61a03a48c6bd5ce0d48ce6c1ab649642e8f7774bfc59bb1d52914b7c6a19d75b505333cbfa60245554cf5b1ce9df35135704c325da185147bbc12fcf742627288bdbd4a3c8fa7a065da588f3b2c0128e15d958b6db2528ecc4d59af75fdfa40e86d7ec35b6e241cefa383266294d8f89cd84a179ba7ee0184b76f1704ad50683d0cf05a6b3b4b7a30e7d9a495455f5e86ab500ddde882ae571c9612244916575bce319b56ba6b1f447c14945b2b852321dc7aea375f880fd69d7bf5e55e1ec6e0323309036ed7de6b24d709ef270cf807541cc5724f6b0594cb6177c861816b66d2209b62de6d13a5be0de2324e7b8b32ced312431e91db83d8bdf027820c45f82ab8e2b79331eab198cad82eeac42b89f6b9eda9e609a7f7de3cfa7c9adf3b10d37a2e6a74373d2c6d7398b47823e77c0c51415d6aedbfaa7d3a9f19419ce061f836beb8201df17b797e031c89afc7cd5ec346fe325f17307e15baec4566f038f804dd012bc6b13f4bdd55828d540c641dd8df9afa8e247062428b22f3a7c4e461d0b7e649f6933706b777a8fcd93f0aaa30e362a032d1bab9e27ede3c977e9f52f6dcc5bf07fa8644b7fe4f160845c706371d6a18b02bb0d95fdccc649486910eaf6e5bbcae5c0b1cf9cf60e011cfc7b48e2a1b0fe42e650eb476bd5e5ffdb535528a95d0a99862ea397f3a19f4041536897a64039e03ec8f70111b974f0bfa6d61e5c10071b8fc64e62d90d2e5e6f7ffbf9fd57781cb54d46e8cec602066dc8f85a39b4b07f764fe72e7cd67d4945ec4299c297d1209540f77f0bbe0f59a912a6603ed237c620b623282d0866cb010e3a05685bb7ea048ddf50774817d326c097310881a834eec581f32890216d8cdb4b19e573d2245d51e7c7d71ac5a29f55c2565ffabe0aa6d3f28d4797f2cd34daf3f7d91a8334e07c1710b3838871fc20b3e35cebdb2d5ff55c163c6ab9cd72d653dcfa622504b47872aff869158bb5b6f19a1acc183e13125717b40e42d01a86171f90a42e46262e6cfcb4b5bf85fbc7706a528a64888d6aa14a0cdfac91d290fa58f5b3a652428e540fbc33a4a0fd5720061966c8ceab27ae4f20e0c53847b14754d6a8514750defecd28c7032667806ec15becbcdf48f46ac94e501ed8aef1ee2b7bdbb17b465c4cdfff5b08833b783c531c4788dad474827305808f0667db54569a2347bf708bdce59eca90fe3c8f1554893a9f0921eed0801c69177b657ac756411b1650cde7c6810883ada9b0e1c6137bca586b81e1b58c10ab8ec4d6643b7f6bf2ea92f9d5ec1b301158fbd98f3305fe33da2ba3363579260a5681c54365ebc31a14264f7007df69f531308bb19e283ced16ec0f5c50051f01f7edde0240a1f6b6847be84f30c2c5bf3125fbc31dac3f8136533c7fa4f737ee6a8bc71e28d4cb535d6b22eb2910e01969b6daedba2db9e6f6764119a2af6c767abca63d58a85e083c2d427f6d9c20431ed3852bf1ada278c1e35185639111545e40925642ca9bd3619bae6375f99b9d68796582b0bab6692ad209614a197e1df4208902bc79bc9b6df7f8c24166a990d0fae37237d5fe2d006bcb4952d63c7a1a5253da9a3b02e14e553d66b838f1a250fd1d9c80fc41180b4bb30f3cecac4aae387cf644ab474feadd97bb8d6e142a5ad43538fc2171d95af43b1fd2d9065383374d3a719a978e19e079c17464d477a53b70d01f87d3b1c6dc1d409ee7a50ad4292f1ab37389e12ef7504a8c50816be2846499f48f1d4b96139b26aa9653a72a4295d56b98f78659236e5307cd6009adce2e2761bcff28104632b75fe90a02f1f3d6c5308c84c8e92f651372b86eb0dfc9a660f8be0fe8e9122396939a90864f6ff7877af9a88a51b9605ac521975b14baf3c841c624f9056cc9c747af5c4251635cfee6ba3ea247e8673d67c88801a4ee84cadfb31486a2c7827ef40ed240a59a7b697dc63b96a3c3998b575c81ac4279209f75b1c01fc88378dd6235f380449391093f30a87c2b711686150139a3775fa054a7a680cf8f67d7b5904dfcde54c2563ca8cceea218e38241f55c19e3c72468c2f7dba5dab638334f4e539cc3317fff548b71db3ee58274ef493102bb5bfed1ecdd7e0110aed8610a0a7e751c4c161105c7f85695e062d40900219d0479c41416f4aeae20b3524fe96997e8567a84c59fb72696a43f0b60a52fd42c502a659004c8678cbf1ea9db3336cb451d621dac77b3dd6cfa37d6f713c938fa190d25bb29d914f04962b9bdcdcb4eb7db20919a3e7038f1ab0c7eecf9fbaad8d772e9a8f7972e812d4a4eecef54d2c7e08f885a6ade08b6716b59c2425a8269668932f76e8bd3fc2e65b543ffa279bd5760f0499883b85d80243ebcda0877bec0f12b77d68c32b917c46180d7b324b0276dfd69d47f25ad72a3cb7dca2657a4aaf201be3e91992bf9ceba60c27cfa7f9b04ac2e82200362ac2b83391c00e4ac7c7f4b927b60ac9ebf284757e62b6bf934bc86da5f351d6023a37153a8111a4dd3af2905d8828f8dfc5aef24680842ba0997f260e014665bd6bff753d010dadddba50dc741a93a19260313b10335be593fb74b0e1f4fc6eb43fe040e0255e31f38c6af210caf787b72e243ae2087921fb13d2df31abf5cc0189fa4d6e4cee4748044f1209f3f6f183b022f98dd93eb3dad6357fc3307cf95a6c8862f3451c69e3e36ac1376d97c29cd6cdc78e309bc7c8c28e2635a3c5197a56997515a90a136c3f89669d05c83cbb4e25982cdda0c692c45c1bdd3ff540e75ddd99609ea71490b0158a615a121d026f83c1bf5d870538afffa9872b2d74bd57aee22ac04b2c2f48d13f27c46d135334445968a048c4e74762d0fc414c5cbecadcd9d73b56d0f2f9b2e4a32e66bf302425db5af876df066f51f3441688a412e40967ac4046469665398fbd35c6ddc31cde0ceb9edce26f95ee773c4105c7a3663c4f9729cd1ad263a85fbccc6b9c1864d6aa64557d4fcc49bd2ea2dba650218f9756308f090a17a9e7397444967730135c95b61315ab5d47d35a9055baca22485be13eeea13c447a67f3c400d622c03a6c948109f7875bb2748fda7965025501779eb7aa46e904e1fbb8f3b173779063e201c094ee673d9fe6e55800b5a6a6bc02559abe52c4879c422e37d90a3f0e7be6976aeb4027a13be8b2bc44109e95caac2f8d9f7a1aede075ad3f152517347a8027c9153ad379360acad9a64bea25a63eb76f8d3fc7e7f6cc5b6a5a5b27fa2e0de3cff542ea70363d821c6d717df51530d4632d4bea799664fb6da8f17daa19fb47f825b263f3300f539c7b8644af4462f97cd170aad37d0e04dbe2a0aa488d7cb7c02c5e0f5f1ec7a9e906a02987587bcbd05055fc745a7212300fecc65bea3c5658a85d623afdb31c66dde44c3c0edc529e7f4fc246c505b3f17dbe11e186bdfce12a72032347cd258877a46ff59738fb98633e1dfc7fff66d25e2d8850b45f2e55a26bca24eefec6bf87c11393186f7fe127ee9d83f4edca13b1f6cbd54c83a011e7c5942b9bd5648444a0847f2627aa6f86e8afd018d22aa52cb934dbd98b2d6457383dbf944da2d1ae6f43959efe53eb0455b2db404146bcd6dee1bc1cd160a4d47cf14541b057d638c20120eaf711fd88017e5c14f6dabd3a05d0e38391348fcbe92b7fc8ad9da9f047b09fc109d4db8d3a37238458afcd4b716106097b027d8bd54db0fdc906d65850e063a96cff78b250241556557db1d7c02fce1f8c45af80652c3d5176d5b30b7bff2256245798f0b916ca1b2e334d8737bc8d6588809d006e8dd21997965e4f626fdfab34310fa049ab66c0b37da152bd5eb0d99c3eec1433be7700aae336d5365a1adeda4dd771b1d44ba84db2cab514982da7fcde783cafe41fcacbc71cd437b3497ff506a05d9cd440c4de1d44dc899775b89d3cf27a469f83fc2e581f2303ea29d5f7807c5a99f5bd5fea8fe426cc2b32b80bf9919d5b5a3af51e108cd869ccf5245a63769c97ed63a8f86add86f1ca1cc9c4e020e7782934856d02063612eb21ce5fd769dc6d829ca46826f0a1ecc8613c9a8dd45df35485e2801ba5f5ce4f96d386ccc3db74f47460f388f36884736369ac981228d2447b73c632a40c1cabfaba576a0a2b9c960525458e53eebf88c6e1b66202acd088715dbef9a9e5c884449820b632b0294b8d90e79e9c82ce3a7ef6f19e99151678aedc016182720d3045389fa0303980192080d10b6e3cf9afd828bfa0cc3b87f832174ff70eec92cead4b9d30a25aa539c511be7b017b522fe9a7c0b6871c6d9ed0eff178e6a8d464bfbf8a1fbecc8f4630ed916e168ae7ce97890f3225b394f8d3e07c2058cfc01af8d1c6534bafd7335a6893f2ffbeef8e104e38caad1bc640d6739ff541f7f9b74ab95c592caa84858aaf550fd2f351c1113cc17167f5532f0562c83a2409d10fcc3aa7ab0dbd0d93ebeca25272311df48c82b80e23f05d68b0961fe95e93b8032d7c8464cbbc844db24a0e856b4468c2e72d4b263ca0927a356d8e9b7dd806ac8c5efa7f4e21ce503771c84c70e05921d6ff9544893a5449d25b53bc3c37fc820920dbb63f9fa928351c10ae1073225a293d17b3944802aa7c55c74f83857351ebbb97ef7d1a6715b90c764339c627c8189f9a1798c4cbe1daca6c73b715f1d29de40a07c6a9fbcf9e743a42a34fce4157725257d320cdd90c449e9c0b46c2569399b4a5d2c5b632dc2c799baf359b127562442502b39bda141ac6a3b9bde25b6d1f6ebe7f2521f8d722212afbecb0d2b709623d8454ec70eb2e8b433fb29c637920bf07b06288dc31ce3e8399746e20839b4d7bc21d88c61693e876c06b2bbd83fe7bc2c6e5038970a4489fb8ca6b13ac0358cbf8a5af654906b17844ca2123b004712be45e591f65250f5f6f793bd83c5d9c33bb33b6bcf3c02c81e429b3479cfd28f5d474bce5db9992eb516c87c375a918be131806f982732ed865f0e38640b112b1d5485245e2ad1b3324896b236d65d51c8bb6ed244e5d9b433d2e10b46ae14141fc6f95e9a4c565212e4aeb4a04cccd90d2e51e9957dcb8aa71bb8a07f75225a46ad3327edb9dc67c2acd295cf122b0cfaf974a7e0a92d42df92eb83283878ecbfe4ab66cfd3794590b9bbc7504a2e6ee39767e4523cbe12a37c082c8c251cbb2b9f2e66589f28429ffdb7664f144d2c8529845aa8a1a39c9ca56f7f51dd6c85aadffa5bcc5c6ad8e3b877f92e1edb5f2fe87a124345fe26de756d16fa53caedbe29a6559db348d794ade58a1d185880107a8dfb9c7bc90dc0241dfd0a6e91b0954b512300ef8168ea91bd40b30adcd5fbf1a5c4f6bafa35d3b801384a0e29feb0ab3953163e388ec065adc09579931ba75b048bbacbb1b82670cb6b1a7cbd9399e5d2a05e9e34fdbc6de701e523b580e583a1a386362ba9b6fd6c751bded664e04ce023f089aba3914675a8c48cbe5551f8dec772f1eb3d818dbc8a779d1716b2f182a785d89d5f0f95bfb8f4967d85047167c8cdf6080631947dcc23272f8c02b78757423170c9838126a6d91d5bb26fc5f19a4aa1580afbaf956fdca010ad545e9d348f0dfa4fc0758f801c9e70646a52b56143e1c153220b884595f586e9d34af742d4df2dc019780e3f4d07d03c966f4e788fd2a6d01241a6efeb284b23d749afc13f445d7e65c13e170306206e798550d6465282d14b2eea2b61265d7b097a0a1564ae56fd28fa32d305c45ad0f6bc82e475fde759536eb7b30076e627e2c6876a07cac233505cfc5ffb2ac1ba19b2e499d98725962c993cb896724e83f90cfc93a9124d06532544a607d9aa6f8c5136c58b93b9ca5d670776061f978ccd754980a9add48b2c5a562845d226258305dce75543d933db7ca9a116938329e770bb4eff21a9c620bc0fd7e5e9f40d6f6669fca9c58686252a3a24ef3062e12248b7a06e0d64f1d86f90944e499775d701e0e5dff3e4e1934a948f4f5a5b2ecd9b6db60a4d8567e5e12cb988a23207b515fd29de554e725bfa5cc8e161c1081200b5f95d283056ed52d4cbde55c709fda61abedb96b8c3967ac198265aedabb5acf4597743c4f8d100c9526e1368d9e19d60079334c001947948772a52106fbfd41dcc117c9d1c57a2e0829948f2b302f3b985c580623282781f6e44b5332bab42accc25c7b15c50da9c5ae4d189eb05098115e6faa4cef0e36566634c3ba8336e8f2771d9fd1faf963208a5fc10c7f70274d3c491fc4a7b13b0b4125652e6e771f1983adbb24f44ffd5e82d70276a7dd141ba2dec77acd6f819d5fcc54a3f967ac10fe51eca8dffc69c342289ac8071c3c7b650b037d9dbf490488419370000c915dda6beba3abe5189ac188ff7a5f0fd4dcca5482cf720cc44d54e245dea3bc59959c0039e5512dcf26cbad1d9ab44cb7e3999f0fcfa5bc7cfefbe2e44e4917efcc242ee0fe62af6ca3ee749fc580f24a49e3f24032c55af3f3061a5afb8bd01370c307759a6321a431c2bb22c74d64e70daa44c8b8d7e19d558df9984c7c5365af57f6429229c2e3991019c5061e245a132986e21d4d04d7da98e2c47ba22181aed98ba00ff76a2647b7298d96a9e40cc2f30dd3c81538926006c5f9514ab796c2701a485fbc54bb0301028b2dbc3dde63f627a9a79806b13c90ab742f65c1624e93000759455730f778d35288ac68fdd0279a4b4e3ef297f72af672a62195d084efc6a9f9a034aee01e3c8cca01cd8f062daddd7f7e211c3f339a5616ec7b5663730eaf35941a002620d86829a579dc977075887884a832d3755be5cbb6ec9050791aa3c6dca1e02b340275a5dcbf736ca1b88c16122f81a687b0bb9fe8a03703bb5bb64b9e1af58e4d7364966616b676e87d97135fdb1812a4769cb386806f2e330c78cc95e3627153bde375b43ada1ba09b5411a009ac83a05818f9d619b353f340f506d1328598bd066862123391f68096b94272809576192423bec557a6fa4101283b17692f053d6b3543aefce8d1d9bbd058250141beb3ca3a60fc85b78d32b904b2953853e126e5853d953957d781dcf4141e57b2ae7f6987b7687b17eaa262ccca2fb79fcc9c0b70df3a21bd4044f3f49c8c6b30751fffdf1a87255a2481e95397c583d5751eebffa11c206882ca9642f8a6612480fff4dec2668e9ead6bed225358f57fed28d738fa24f603e1e73d7d9825f97f8cc79736950c147b7145328a00bbdf38f998638f8d892419cca2df954c98013d67e223eda37f04593b9c65c27862bea424a4f826ec36da93a62fed3b4ff895d73e7279c96f66301c7f90866c2bc542f7752dc1299de0604c4cac2b583b940584e38d4fe553ec7fb891874b0f66ea443a4695d8f7794e4e59ad87d06c5d63bb521a4fa042fcf901b4abafc68b265f7d2003ee833e1c5d4c32be4ec34e5b5382b87165c17ba1891cdde897ca5956a4bbfd79e95f0c9b38ad6b223b2969f9ed0a9714233314ad128bd8f7f6e0eba45b989230fe8e420596bb20539f36f6274a3f7d41b1e02046f0b9e8505e6f84161fe83d8b6256d98ba04765c0bae3bf00df9614dd5468accf1881b1156bc93105ac9648eaf1221616629676369be735c755310d709f07638b111a60e917fc5dd788028b47850a696e191599116e4979a8935cd40d9bbe05bb639859ae9c9b05664edb7d9ce48ed254688d72db565577bfb897c9662b26cd53175421bb3e5c7256d786250ba12bd2664932b206beb26617810a401aa911f2aa3556962d7244535be923cc18b2041dfc095fb042ed4085754915f7f3c78d836430510ea686ea1cf169d88937b3d684e5ea7c471447c5fe048086bd26ede12e63565bca8c040fa5314aff8559339af8f4f1952c316c6d22123ec0f4d17c6f65b8957d41d3ab4f526cb7acf7d57373f2a29a05cc7aa92cb28075154caaafad40b25030feecee80128b1891b4f005a7fa4b4b609016bbb95123aab62b572c17b75e25f10fc4d85a3efa92b3f1cc405137dffbe13cd0c694f1a68ef0caeee073d2850a38313b1a8b1725a61b5d3413c96dadc66166589600e7d3c25736323558e5ee54f09262642dc018cea1eb1c5adae9b5b2cb76560aa3a76f4ed6a7c2f41b3283958f2450dedc555686f4d98fbac7fb41d49a0c0ff4e6b3943192e68a38c4fe1c1209065e968719df4a8cdb7b3933468262b74ed79562730659d4bb63a6232443894435096cbf27f427d312c2dc45d52cc9ffeff2da5bf64347a82d836a1dbb553da5fd8636238375ed9ac926a2c8902d5c7b9230c5157d4d906f0debfd770e39946cd104b266418bc01e310c3c714393d4491e290cbaeba004e53ec71e7f4001178d6f99f1483b887379655ce558bb15ed7c31b9fd1df5a23402716b08e63ba8673dee8add9e0a6120622d4def04ac6df3221ab019fbd79c307f95efb07bb0a51c3d68f584680792745b4d44d87d25eb07757f7f3fd96d9188adbb745c839f93b309f853cd275d82a31159444828bcab591a7e95c10fd89dcd13363dbf4263312b5a6fd0d875591cb05e042b87ac3519220e332e1e004efed1991cea10617912401cfb988162e09da6b9619a1bba74359eb9c700662a65c6c11192746fec934d69395de09a13838086fc9a490ec929dfa235a2a683bba0bb472a665f34624c732f837e79c65ade0e92e27ebd6a40fe2ecd9f5d20e9c653b26a1051c13d142b8e4f6838d690df05de69f6c20022db6284ceb308c32c58881ecb045d4e8f4312598dd96b2e71da6671ab86e1905ba471c701ff4964501ca1b0ab9d4dfb7dba914587053a1551ef7ea7c98b727b562027b63d630edaef3cf8aba114180a6acd158693a2d9a28e97b91f19650560819c006554024cfef0c6eb4ed784f787ef19871cccf8c40d65c4d4fb1d181a2fcdcc3459c32606fcde48005d7af4d4196042396b3f04134dee643ac15160e04061ba714f3f9a429faef1f616f722ebd9017fe2e23d201b1358e6f07785ffc9ccaeafd22d2d3519531ae515ffe46a4191a11e70b0b191ca2e6d7543be736dcb4305f92ebdb0644e7d7767221a69a607ba22d36aa7cda20af5341631fc6a444111465a819d9bdef3d9050b5417233e90da18b6ae4d33e600face93e9237e32fa8e3b6493d45a17a8bd1f5c025094ebb66ef2398ba425e3454dde64a5d1c4b58520901d176b21e439c5b90e9cd0e250bda1bfa8fa9e0adac104e4b8d9c5d33a2127f1ecb090daf8e3f0932154133d23efa49d6c5b9bf277ebca64fd24b0ccfdf04a6911c927ce266b49ef94df351f561d95c0db89a1ec9b2dc5c9c64507e6e4e5c32911e1b11a9a5840afc505b4b1226167d10db40e30c41e1d5732a834a4860f12172ec6b15ee21a7581d58454193e6366765d1a356c25989d738f4cc83466b606671f6ef89285794a48d615cb240464d54b3c9018664aed8758ee77607ac8fd44717ec0ab22e4d463c3d7d21893f60114df07440f66a95f8999d853dcc7e5e3c00f4c268b0610965e3bf513c0a48b0a2b6bdc69f093e9bbde6cb290d2c7cc1f70a1efba746106a2489f631c90945c63188518e331069bbb9d2ed8f7221e64728e2799dfe8ae09de108e6bd43daf27caf4fb73d6dd50e983f7f010682bcacd3ec327ffeec29214d769827e14efd7aecf680b1b34ad0d8effaddd846e2df0eb32b1bec82c7f5b7599d0b22eaed993fdb0298250ac27348d28b73740480d3355aca114e96364d8e88ba5aa25f042799bb09ca3b0f1ac6f7e43f7ddbb510c7ff758a3fd4305ca94991d8a152cc2087cadbe93e5e2d7320857ee927b9425d62e5bb4fdd07297a551a545b166a8580c83dea50ebb554fdb524d5954aa96bb81125b15e937f4d5dcc1e0138703e0199ea9508732e4af53aec03c1a71a3b76ac4faf237ccdbbe6775d823faa4eb21ec1bf8e9e7e9e50e6cc3a9845112a751f17abbb3c8a83f4e1df4c7161e85d2b43cc41d105f9a590b7e744b0ae72f09febadf887b6a9245c58cfc008081f83f5a781faf2efae4cf413740cc50611e5d665401f6bfe65e16a96792309b8378ea9d4dc0bdbe406335a1ac6a765951792cf8c047879e692eccd33e8f0166fcecbd3e4dcd85930fbd78a262cbcf92275c0fbe5ecb2a39c4abc84ac35a21b3170d34b39cb6fc37ace0a93b4a547a4f5bf8fc61e52c610ce87b0395dc7f66f12b62323e9c91cfc41c7a138c90ab33e862e1e48d7ae5992e8d57240d86463a9c471914abef94b8e86ffd0021ee0c63af21e072714b4650564c6630b9794de134211b90650500e454ab013a391b27fbfa0a58338e4d47846830b2251dcbf24f68ecdeb6c1c4590df098ffc0021411c84ceaa75c542f6295f7b08a4e915de24195114d3b302c92900bde13003ff320a28a4bf1b8343d8430c499c01a2d59b908e70a2233b402419db3f4ea99bcc3fcdab4c1b9c318911fb48a8ce851f60b3d676de331e54f4fa8a328651a11b96cbd257a39c680252963fb51cff0dbf859e6ae3961ab982c45692019fc3a0dacc2c03f6461ae6ef90614410f8dd04c9da072c2df9ddb879f016c46a366760692f1eea750a8e9e6a45f9106f638119e3bf11c8741d8d72543255764532259bb15af98aad3c483f1e3bacfdf6845321496e11588efd940e602ee59604f4db4039eaa61369c9aa0a27152c5870cf1258c879c414e5a7bfb2ea40641a9396b99d3a2df78eb40b1e435334f57035a84c834e59515664238b30953fa55f26217e02be4510e8f64af3c76e22ea5ad2c068794fda1ec55d22c4a2dcf4504169579a2c2b9f87300eab6f9b316c9dff120f8e26fca50627ec1b45f549800795130de133235a6395e24e02f8d42ea713ad655cc929bd01639cceb294e21660a7f9ad2ec01a75afab65d1981787600fd4c7ca1640473b2f9c6aca0031180366d8fb116875ab4d6f4abddf1cc3ae02cbf2b31ab1d93c366b28177e3c3c16257fa35bed2faf891bc3b6326ca52a762448d1db3bc55722ad4ac3e8f56f9dcbdfb62d307f56fc53fe52b423bba0df3e0ab16366ef56f930c442fb2d09390407e4fe7ea22140e9778600224b491fe18e2f8fa9ac0f01600b9060cbd06a01bc89dc38b0a5e6114b4f53f2cfe8429c3c3db1fadd0ac2e5f1dd5240eac3b6c5a62647e583825a6f23e68b701c02deb31a34d491a1bbf336d624c157a60ea000998b6d21a342e9a2f39869cd5dc468cb4a567d33aaaba66cf598f63a7e0473cc4fa9485e4ec26acf2214a60f57af61667468a98d82e6cb8feb5f89c119102a8d32e92f44039ddc557af9bd7f31eb8e1e0572a7fd7978ddcb63c1671955f4c1b689ce161226b0f4758cecf4d9b2df3483db1ddd439f114d3818f552c1c4ffd841460b59d75d4977dd812564b5cf06840202f6715f751dc4365ba94a974bcaf4042c777c5eddfeed7aa07df64a1072e67013923b18fb9fe09fa226217dbac3441e46d27b0d4eb511390121b64246425aae907ecf096a20afcfa976093a9b4fc413eff6538b98afec7c46074c79f1abf3c1417aa5f74d92d2a067cc7d441f1321b5ec7aaf8c5403a9ed143c47977eca3877d3e9e20e94a4dffed9ebe519038cc378a032d777b9240f06bc048a8f9432dbc896870f4631e9785ac2df3523193e0d5a21bc99cf33f591717ec0ac013b10dc99773a0797988e4e5255f54bcdc7cf90ca4a8e96a94ee65612f4813fcb6ea7ea97fd192edfa93593cb5ad9141fda55fd0cff3e859c8706e606d8aa2be012a625e519f1a95636678cf3df9e8d8ec63c3d5d7d7677ed799abb73b8c2c96fa9546a01678b4e9704e07d9342d7d2a4ddd296022807efdccde90722927d1bc82c6a027cdaf6481b54bc3d5697f8d567ac27980fe7b625ec78670ff8838548269956ac91126592532028b2248ae9e34f8966eaa6f0126b48cbf11645cf5020cbde0f6884b70416c546fadabb480de9283a259d961d35eb59921b6b8ab96d47e7d63525f0e233b4f59ab0c81cdd9d159c081ba252d038cbd815e74673eac3f4567a91088869bd774458ee793d4466d85d5031c854be032341b3abd53a2b236cc3ed0705efef53d812aff154c794528e1b40ec070d4affa15e84c1221a8e02ce93b6bbb32af5fcd98adf13ddf932d9a29559ee29cf5bc00fa42b949156555a0cbe2efe34c4cac4109fc3ff8f0abc48a5ce0fdf0fe3efdc9526c697ab8a18af89acc534e64ca63ea9a4dd2066fb4847c0b55b42ae560c95eadd0383a4bcdd5a31c33e6d3bed407d8ea68dc10f0ccd1c217a02d84b66c11ecd146ed487c9cee8eef9493ade127487414d7458613a11f73021a43805b5dcd04046331a6b88b2e3701655cae851ba5ff0020297798a4a1b02cab95b35456bb2b5e7a2d70999e54d038e3c29dad0e49a0dc04e93e6ea05208577e346e102bfa803fbae3027c99b05520e25f21b7c702d5a45a0269d926bfe26c89f02534f5d99793e4f7da4ee8602727149a4c9846cbcae6b73b9e647829c2b899cca0955648eb9b02f1517752128df87e99c7deeecc838ead46264c7e660aeb8a9cc29457a7e1d56dcdc76afbe504aee9f18f23819e74fbcca92a6c63626210d633d0a7b5435f8ae6b53a04b68a42fd70742043f057a6933ead87b8bb9d258c5d5671c116ab23e87dfb8c6a4b7d0201957f1f7c2be34f774ad0f90380ee4db7bd9ae9cc9d55ff3dd07e45a4a089972df1cb476084a5cca159dfb438bef2146789642ef3a302643217594af95908e3db07aeff0d5851d8cc912da9957402e6e433cce721f05d5d16bcd068f5e388a02be9f1e5750e4a9a70b28dd55f5fec940ef0edc33acf0caaec6d9d2a9fb7eb13331da647e5d7a57a17416098e14f21dbdd1ce9f0559cfe8999419cb061d900bcffe3ab8cb7291e3576b92cd2fb649b23c04fc7e97a518d60cd97e7d5320b7e26a3bf17d7a7566342c557ace9a295ff5fd4038ae8a544ac8373adabe6b3e9020a33039cf583ea579fb8c55d91122441c6533864a11a864f94972a0b42dc5aa82b365de4db2c757594a7305bb115e8b0a8907bc697a590f44a9557ad83381d8bec28af878da0ccc167b96c20c0e2a735223ae4db471e67c62bc1d9b4ef9dacd2041f25b0f6d5102b27897a41e17c219bf59acfb4076ed295ecc8f24d60ca8f4d3d8c999df054306b87a1c7b6275e0fd5408a08750e8926eb67b4ea7fe234acb2028d544d56b9d7bedbf61ba1ce048932632ba0dd708143af7569ee197f19ff0cc890debbd1960dd0435101599e9f7fd96551b8c58e645d629ea4cff2797e8e9d8e7d6137ecd70b0ee77849a58846537c5bcab7076d1c2197652f879b975693445f9bec7f28854f169680cadb9fac7628b7fa9e091c64dbbc69017cea5c9c1688528b70386fa28aaf71bf0d58ccc2046ca4b83aa8308341b6326b0e99fdb12806c6457973a95a83c76b73116797c9776305c984315eb5ac434cd6198f78a0d93ba3fa4823301e9b60ed972c87a55244bb725991385c419fa18138b620c5ba9acbb608210f77bf52b6cf97032b49336b0d69cb0c230a0e4146ca8f413d7cc3e52ba958d4494f21459f89c01df1d314bd49b4bee0c8276a6d2df803a147f2ae8791ffd42378040ef9110738bc06125c2377bd92ddd891c458048a1f383d2844a572d504af6a3374ee8462cc531d30f90ddc5b2a1fd5fd66188326897f3300f2eb6b3b4c8322fb76de9dd012519ed574cec7dcaafcd36c7376c61c805bb6a00048262123b0c22864b0c333a103143a7f3a6e6eb432878f47533ee3245094aa298862d4ae5caa5c12dc29f75c7318c1d2f9bc08011267da4316c68d4e998111eb7e09aa77335f95f658b5f52931a01569aad007c4820d898b936d023109bbf33e9202b7309e235654e0309a8ae642a18c67de9d871657633e4bc6f9f8d1fa0acde9bdcade8cba07bdedee57e5911fb0055771b5aac1d980a4d2f411850e9ffd502e7c8acbe660947cebadba3f4c690fe5e34f942216ddc4b67a9401a2e93f8fd5a11c2471f0aed2267738f76ab895a790d78b832993d2833472f2db6dab3d77573e4c8f9632928272158411ea8adf480189c2ac1a8aa93973592fa3be7a9a1414d74aac7f4062c42275e978efec83845b3762ce04f72e6f92e8cbb7a3228aa60e30db7a1b9bf1a8f0863de46c426b43dab8a128212131046585267133e95e1b590cb8cbb39822ee26b23dd411610ce7c69dffdc38ff7111989dddbfd245d743cb2c8616c810de5ef21ed7adb6bf2b0ed61a00b835257628824c0a469720dc98aa3b4594defa3b38825c8bc32591c6e11956743a8a4baec120a44b8f271ebf719c6f26b6cfd0538583f6ee3173c831c1a3eec643cf93d984923d00e384fe6aa067bffc8f2bf5d2660b68add936aeaa9dce24ecd104986e3ef12bcffc16a9ae8b19ddb6918ca5579a1215a892afb1fe6e60772fd914493c777198c9be4d6c254fa28afe876ec06a93fab088103141dcad9d5df435393fa7ff905eab0a577987e49e1890d28f2e6dd9d3d4e8fae362e494c9292055d1e5ab93294245e074e39fefe6012e7d00810089aad2cc1abf53732e986fe28b0e62f02c70501c09a499ee96314d31539da2407613e90f50766564113753ef661c42e38cdaa1592678ca020090b86aeebd6014113ce8cf8b8915f8a3e3f12f1135e7ecc06c68f5e9625edf65657db1ca825e0c17e633685d80e4dd96a2bfa969149499141ef6937485b2d21b8c504ec3cdc8ce0d6b1bb0178478af6ff2173b17cafe656c3051a40edc0d50f8a5f8320953162980ea9c7c142ecbbd3283301a90d71672d78c10d1e346d5a59aa43ea373f63d79135596fa034bb7288be4d0321899b24fc8d5f721bcb2204b89eab08c2982b06c375410d22aeb7eac0b9d3c40ac37d70910155dc8b99f80eba909497f5a92b6ea608d5b9f917fa60f62f9809095f91af4740dc2720a49719af3f185bf442b599b3d71f5feb3eb398db53cb2fcc60a483a02d1708a08fd1da249349b9d679c1e47677e4eac24e875479b5f005b756c219a19cad45d183e3bed8dce812d22c1dcdaa7e5ffbf7c17cd2bc34e1c2b4d125d6b5404e7d0bd33f71abed8c4a5e31d0e00a9a9d77ba209a73baa049af0030333c8a0e5eb84bab7117a7c313f77641324dc950c87c92acb5d97f226b58bc8b288f87193bb4d088fb006819a9a1aa19aaa6862e3eb5a397911867a4fd8f00a620f484e0f86f284e9fe8d8944ee3058482eb50205f93415be9b1ff412458b84fff1abe7d3a0444da9616613b4cad4c949b0526e2b2f238f2fb6f566b8acf8fddb53b64a7bcbcc64e755f9b63853f5ef5e9999bc3dacb529735e3a5799979e1010919bfd17bb596051110e3af9303da12e7c4886b3cdcfe94bb56d91f5c90411fd96b2cf2cb5aaa0deb9d6e673d870d2a84bd801f173796d06fbaae061f081354301482c0f82262e24c1f9ccfea6e2a1c4a5838b2dfe0cebd6aa2dc8b5985f3131be0506bc2f29580b4bfe71da51ccbaee074a33d72613d9961f2762352cfc5a1e58b1df2ba9c29971a8677165df5b8a6a34ff8486f035e2af1621f8eae2757e8d0529b2d5284bb3092ec28e6ccfc383fcc8d490eb3b9bd60d6cc3367390bd07b24dddf7c5e8e15f68e91959be6b0b9c9363f7ee2d97f2bc856cbbcb5954a6683b2c7ace224fe2b7b940dcf8a67c1178a2a17db7ac34cfe92cc2be23258ff3d4a76ba5f0c5609ef7b5a1505f1c4b02a9db5d98f39faeedc9873197ae70639db56b0e632c74cd0ea17c6462edb39dcddf29da4312688526d89dfbc65343307409ccd730e7e456ac251563d54a854e09b31ce23c82d2bd93102cb357434fd0774c25c309aaeb35384cd22374d64cf8ba26df7d51b2068d19b6e7ba97be0868579f4d5c5c76ee1fce19fa5783cecfd7e5080ce1a74044fe8ae3d65fd74888f2466d9fbe65d6fb4e19f2f0e1d11aaaa347f924a688b31bdef192f7a96cc501c2036359e249360522e1f32455363457ffa8bd2c28a2469cd1bb8ceeedfa27fb897e47768aa800bd11ff74cae167e9d2aa610b3e8dfceb464c4d2389b40420c2c34d6471f655543866be9c92ef9e493579db5db3369ab7db5c21af9c2473cb45d5808cb4d1c854ebc77f418e1db5be3f623f36383eca30f636c3b1e8c91509399cef3d127e614bffb881373363ed6f153d647343bdbe78edad442c73565bb6c345da392803ad1d73d8398e91db35da9337e080c50f574e9c0fefc587c8d43abefaebc417023f74cee757c52ee2cae34a92cedb7c7d79a7dc819dd39038b69e54b610ed8c818a7fec35489cff22d0aa3c93dd1150bf6a727afa64d57210e35b5cdddc9b565bd61b06478048a091d3b793c0b7dc81aed38e32adc0606bd2c55e620fcc7920dd5a0bc1cbd702b2d85f5ae21d4e20d34e9255da3772b480740983af720cc241173c6798518c249b2463f8d3288e49426d8f925967b86cf9e6b0642694e07b85cd693b064adcde722ebe872a06d83c3651835400542b0b64857c06068bd33135737f84433de79415085867abb205692fc645099aa88b6e08d20fb78dc804704b9f7f14350ee4709c2a4b3feeef9350fbfc882824e8f172c23b85c48b2df18bcc70e90a0eba3f30c4cd50608b2ddb3f31f498a02b56acd506e2c75cfe6a80530b977632523b7f540d4bf6fde919f1b6db080ed3fd82d60a23c774173245fb38bbc4b50633352ab7dc0c3b7f7dd000cd50c9ef4a13bd94221ccf5f90cad496a75dbb671adfcb73408e5034cf5bded854937b5ab1951b3f76e065aa1f518aa2410c47363d8cb2301bee530b15e6d199160d4ede378643df779a90ba8e48ca465a15002b60c20556ddb22c9bce64598df0c8b7eac1aef7e51e63000862063f39b648f6e4cfad05103dbad2ac3e25685a8b12943a749e6056525c2da617fb4eae262ecfef999ab3a6b8b938c4ca30a094c78df5833b634ee4517ddbec3a2a60f4c1987e854f5056fa812b3a7f2cf2a4f16d26c390f42c1c3d217cc8495083c2697338d38e1b341d1049b6a30e72b0b3ec3c43cf5b4994907125015506e064b21f7aad2f90d00d99c32b3db1844cbb588fd2b9c54cecd96d3c4a7f43eb759d0f0fbcb2e724548d2b40cb0cb300dff4cad4ada6b3debc064c135a37bf7d1bfe52202041b05bd83b5b729852e5b5f562d8a023c1504c5dbe273f6145497088acf720a4c9e34f01869133984e4c7a1fc7b757d786fba3d08da0979a2416f33fc5022eef4186989a08946816029bad6cb757babd09c6289131ef2898d44953ed0a9744f6546ebf6ce8a9d6189ba386e629038c0ead3754d217765bd8a02fd775bfd08fda919ef264de13726bc32f0ea30cf30416bd1c311445e88c893fa8edde5963c1dafee19bc154e13343399b86cc9720b8124a87698f630340675c8c5830524940efd88fd07c24fd83878aeafc021d0b3779403a9f69b4e4981998851445b18f7ab31461191e34bba2ac2fc66f2b99fd1036c79648217d9838037043ccf67f8c2d785acbdcc751ff9aa70eab57fb459dc77bc3531ed9975399f32c62130fba95f77f06636f993ec8fffa91f7621eadb28fb70f631cf9a2c58ebfb190352ce3c455cab6acff5d75ec9096a49cd86e6c4e1824ad41e5a8c2dd1b07dfc0b27175915f88dfbd46437cc1c48a156aa6a12c6a9dfb63a53092b038a7f046279ef3b109058daa7ac682e787eba9216575a21dd1cafeec2c463c44af36e05fa5485856df5584aa7e1e7aef16b994d477c4836ee1ee55de81a60cfc7a9d143c924b10dc3174960a3c0e164038aed3f6609c8e5367b40f9885b685710bca0a2723ef0394a96f8dd147df08bfd20ba2e82ee730e1878bd33c8bb2f618156f47f0da71b7200492f6b51982e1892d62a5ee46c82f7d4b6b14bc4953e633dde010b46e85a45f70aa235f71445fe6528c21d21e2c55eb6f68f4d3320b26925c6c3fbfbf2ad0364f67344ced9ae68f1c2088478f7555fd989e79b065c39688a60901749c2533e23b00df0881aa387f3f1fda4e7a7faa0afc0ee21770ef50524bbcebf4b17bec2f02de1311fc5581537283eb95ebf0d3712be2d90baab3eaef1cd26914bc6ac3fa1e1b2506dea910b3206759c18c784308b26e28b74d7fd0cc603c8b6f638fca2f8b4d790fe18ccac8984908838fc36bc1cda87283bfa80f65122bc0c41a2934b224ba63884d07a1f9931022302620e64dd24a00a202b5a08547cb2cb5deb5114a3464c44a8e7beb51fd97555136a13675fcb118e80ae748d4449096c2e26fa0934915a23736a41ed2eef773fb194c39d25fdca52fabfa53c9e4b045f6f0cf3065f44cf062860d39fcca8b2b8817463e6061b7fdf77dbb053c84dc48aec180495dc875acb3053dae5712883a5f5179c418d23d7f747ed41867f13edfc9b9a8c6390dad4822e71071e365dc21715bd1ba7cd5f51518b457f818b46903e46f6ddf0b6e9d4b4c8de81a36c2834617cf8bda6354f0af25bc11ca3285f7470a0b95165391a7259133b5885f2799e36fee34fcda2cedbd899098e94f2f5571e9d46039d079d0feaa44dfbbf187665c3d6a3f6fc5b66049abf7fcea486464d15a329859efded969b85d48be15ebb5ce2e40e8fea95d8bade4c703643cb2b4cd996404f7cbbd57ab3577e736e18ded3a3b9a6c94a89a308ba3a3356429a5b15556dcec9ba27fa8d45ccf04a7922aeed2d2aa53baa28ad4c84261338b50fa4d2e6a118d93c1c268209102a78b1102f8508d0fa3d65645a4117386b6bd8892a65bf43a142ae9f782d1889c7b7d4eed2e74a87a84d78a3772d70a79806c0ed72ac0ba15ec86790b65414bd036f2fc8816864308cb81df2263a496da6019e788e8ba12a495dfd58e6f9fe3f4d7ce5c76314420c199f207fb6f8fb939dfe593eb11d0f3a95b366649d3f9b447ecb0c40f7fd0882aec71078ebc2e6701bc3140baa2e1e4fdee10388b2d3970b8fbedd1942468c6a803c12b5ff50c88dbd1a538361c6c3333078eb6faa6ce9d31b45226949a0ed70fc55a0e4abf4a40efc2d0466223f0e240e1b6ad4a3f5ccc77335246b97ce8fa8a2fdadebf3316c239ec2709bd8a0194cf8220db321f3324c199d5d137c7adfd8d314edea503456578075dfa4cf1850a282fd0ee943e7e06c079711a8ae4bafa71cbb2d5b63b3e830e47b1835cd26ceac6f92926a79e2b581c46f4548d53d3db8d677938c5fc0b8180d169e1019f917bf838f88e047ee061d70d91b627da8072bb2ed0afddeff7b99bb93eeadc5619caae3eff524df0e2e8b1efec7b41d75640de5101e7a86fe46076ad0568855a90fbdf2bbe29db65dc7f98040a3f55255985020869ceaa6bf32e7bebf3e6a1164b98599401fa958c7dc832aa60503fda2ebcba59a9eb939f3613dc94b5440c2fefb5709de9a5a68c31362c3f5f8ceb420f853c6b6678d97b9a1720378f1518dd97c01afe487e98629a2d731d5c3882812f7add204ffbd7f7382426c0efa3f1cfee09b3e50afa26952bb7a118eb788618904eca7714cfbbcd9e89aae505f35bd3b89e94294f6838aa5c87b26dc2d177ee36bc1886d46d972c95d77c0192499f0906e4b005dae51735011d6db6a9628116a1555f0a5b062fd9609ea06cbf0ed949a02d530a8f9a672d1ce83f9506aee697cd11b3462df789148275ea4a14933252c75daf524af8e539f61eac18254905285454024aaaaa2cb2294929d3842259b192ebdcf911e7cc0257120577610183d5fb9363dde2acce7e7db78ec9d460d291cf5eabc0eb15d180b1f9d64078755660cb758e332d0c1576e5934e9b7512177cdbed9d1f3d69ff8f30d1285d598d9e4d198ac06ea11682bdaee0264df2bc0627bd0e0b40baefc354bd09ce404fc6334b7db3a4444336f30b7c05aacabe8455c84834b17904192d27d14b371d2cba483a320f5cca080fd01bc288b26aead97568cee827363f90dfacbd55036ce31d3c5286537e211944e4698535092980b55be34e6b9521f90a35fa36122faa9caa6c89d1ace70db53d4dc6e390cc098c6c7efe34afda68b5df6400aa4b5ed37159a0cb214f76ee4bf0e5bb120c0fa067cf1bc8a16bcc1f46a67f9d6add55bfe9cafc1f3ffa36d88178fabbcd7e163e26955d00bce4e8b6c5fcab30c2dfe8aae0d05a8451d72967701fcc4a9bb0895f5cd18e6a60a5ff3bf4eebf829b3a7e92190ca3401611bf51af95dfaab92824932d2791c6029f5596aae3d4606b27cf13b22d647356eb09802ffaf2a71b066998a24e70b820571abe7ef83cf35cc2749c1b7bd1a000261f7fb4d8a367cae79af62287867eb95feaa785650545eb5ff94b9a5a5e0cd4182ca9885974e2dbc541965733dce411e804738219f8cd151f3e8d71ab346ebad4377e5ba8eec7722e3d18c667eb59973e5db9b0840f8f2b5e7cbf0382b57c57bedc06daab867a9e64ac4f71168ceadf5d936e36bb560278333c811fafd1c26efd34baf1498599a9270dc3fed1a0b7c591a38ab875b0f2d76f4c170b06bbb82e7e4eefa9b3085c779120d6bb9c740c1dbc23d0f72a95b4cab15812a43be03022fd633c847b2b10cefe9b367896ff68df2283c30cd51a3f29526bc35c5e2c04cba9b1e0ab5cc950ce0449e78b661ad81b6270331a5b82ce8127cd55db781d36241378dfa7443380eba0da01a8a80521c26b445332a4d7749adee8a9ebce4843827fad933e8f2e7e9eed0e449aa5c045213a4a64d85c0297c490446ddb252d3dee76a0072f37b89bf8c75e15194e912dce07975730f6e6ffe6a539563e41d287a4ad3bee3c840f80a8a26abd15d9bbc955ac08b0b3e27a2051771304c468af8c7254df3b7d8cc3f45d2a35a689ca7943339d39011c2fec0dcc50558644f255e97b4c7a675cd848211e068e739f06550d71b90bed1b11a51d05568fa0f0d5d3d9623a39327195fed57adb879fdb7485d6ce5ef24ee42357f010fcee268189eeaf0085ae5c5a4b64d5e98afe0ecc7b5c0c85ef2144bae26eb34fdad429ff753e60b437bd4b3d92a080ea49955c792888f60c40bbb0bdd2b84cfaf901e5c7ae5ff63ed9151bf7774e5ddeeb794eb88791284ab354f6bcf7811c0c46ea76c46cfb60965fe698bfffb45a61979c3850c0bc567e95a5e7bde8c7b30d7edf1711184b0673cb3b71c9d825d6d061ce7663748eb00dcbe0d514a86b7e758b61ad3a33f8cbc666dfd2edd94d41f086c3d0cb3d0e90aed39c67e8a0608e1fbd16600e7cfe1eb9b81bfa6068ec640d8438d98676732b35fdaaf70608236c92e61a7680b5b9b5d2a92887ed2a160f21a73324cce3d69ee18cc7ebe6b250b506930a192682de82b38504ba6d1fc4e1ed22cda2734a728e1fc33ff41d8abf884d9d266d1eea3f4084be41c4ce902a685b765adaa4b61959b3b462bd174fd91db9c7783ee1c30ddfa5f80a76c8ad51b46a764e2e67d874e5fd9583acfcc8d6d8b7c81ad94d7dae3cdbfdad74231f8fe2cabf26288d15c29c2ba051d875cd7b865a6c4fa089ba1998a29c76b4d424ddce39773a8de81e458c627f383d0b3fcd3268166508931be04eb537a61bc68e45ad0b888eb4a677593f5604bb4497cec184a48065b8f097f912e08422f8507ecf2a2479601dc3de6ed6766959c8d5142ab8facf60bdcf3cb3f6b5d3184dab61ff5ca4261eaac764b76db66392b284523cafe92bc9578ef49c84ac1e67e097bb98da7c3d620aae854df00a4cac8de5f7514abc3aeabfd68616c4228829bef50f0148d3a9609671643b04f627ea675965e508bc18391bca9921d04401762610aff1121f70b009f26519ad76eb989c2c2c2b9e1624737e5ba6390fc14a4b5541861a5d4232f1bb20b93ed6985deb7c8317d7b7c6ef50566cb878581f0c6f3821523f62fc359f99b9f3bf73ec1269415d47e16927246286174786c9976981b5ed54e48887e204946ad279df80794b6ae090516fca9fa4e841c12460ca82c08c3e1b12c3e3c2ae1fbca51be104a2014a6577e1aab64f892a8879449109d43560fd1b885e418cafec087aebdac7a1d68a339acc3f4c27aa4b8222f4b07b99a1dc90b15cb5889b09ab342304953a2fa718873f1637f21b3c78a94c27871c8e5246e93bc313829663194454dee2b4df36595dff1cfdc6246f358115c662dcf6c598503f84c65ed7f3f11c4f088d07345eb83e9f0e3596791ab83f1090a9d4cb9813bdb82997e6f68a4c1e9d45282f7bb0b6023af7b157666baab58a3f24f49f89d3ebf3b3c0fe62170d19c201f2d4195f9a21907f27541433611ceeb8bfdce972b6ab337eb2d3c8c1529266dc9980e2f693a7a8ba25273c7a774386205399806d463382b08c2e330c95d201e58b727f8f97ab0b5261a80eeebe386ff9b0514d33ae97badd5d5850040663fc187236614d139cf1ee031b7fff4af57e2c2f4de250efe6c6a1f7b1e46362956a7bbf0c1d1b16913e7895cf3719715bb3618d14d4b0164585ad479b3214697945f33f1af20d004a7f7929a7307f6778bd67f5073724398321e7f30baead1f2e0de37032135b989b96140b4cc2b05239a258a9863c8b858f5e9194791ebb8deed4a70c9b9ddb2dfe904ca0311433249d02f4655b3c60159d16a46423ea28c72b34cd6674a76f3ba4512a1900bbb30ef1995821a11d993c33a8bac9d04dc0dbdef4700a588762f9af0b5867820ced9cd41135764a725130200aad609e56d886e35fdb67e2425668ea198477e4bd2e0124d30ba2ce9bbf77b03af52d62d424d8a42da2f3d3b0acd9db424cc7f513031a8f3b9494efe32bd368ee72308a6d5f2e02c18b281a6529213bf243c179aba4886306400f9de81a022d377f730633dd95a78e71b9c9b8873c2de2510863ac637514db62dd0c83a691f7321aea6840d102a0e1b6265279431a17f7f098e340f817341396e4c4c3e80c0c66983caa1a83e6f1481a2eb8b5be6851622f28cf8beff5b2f8dacbe0ef96b821a8b02c73cade093c6b18af254cc4aded193dd245530d867523eaa3c5bf287d8f9152e0f41ddcf713e96003a8d6a22885e0d2284199b7a67a60c4f0b620594aff7268ed232f5a60c5ad16f5396172a9dc06a6f8e5480df39ed2a8035a935053fe068d33e73e979ce9083461e2f29</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">密码输入框上描述性内容</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java入门阶级,每个 Java 初学者都应该收藏</title>
      <link href="/posts/53415/"/>
      <url>/posts/53415/</url>
      
        <content type="html"><![CDATA[<p>这么说吧，在我眼里，Java 就是最流行的编程语言，没有之一（PHP 往一边站）。不仅岗位多，容易找到工作，关键是薪资水平也到位，不学 Java 亏得慌，对吧？<br>那可能零基础学编程的小伙伴就会头疼了，网上关于 Java 的大部分技术文章都不够幽默，不够风趣，不够系列，急需要一份能看得进去的学习手册，那我觉得我肝的这份手册正好符合要求，并且会一直持续更新下去。<br>第一版的内容暂时包含两方面，Java 基础和 Java 面向对象编程。来吧，先上目录，一睹为快。<br>01、Java 基本语法简介<br>02、Java 基本数据类型简介<br>03、Java main() 方法简介<br>04、Java 的流程控制语句<br>05、Java 包的简介<br>06、Java 到底是值传递还是引用传递<br>07、Java 的类和对象<br>08、Java 构造方法<br>09、Java 抽象类<br>10、Java 接口<br>11、Java 继承<br>12、this 关键字<br>13、super 关键字<br>14、重写和重载<br>15、static 关键字<br>16、Java 枚举<br>17、final 关键字<br>目录欣赏完了，接下来就是拜读精华内容的时间，搬个小板凳，认认真真好好学吧，学到就是赚到！</p><h1 id="一、Java-基本语法简介"><a href="#一、Java-基本语法简介" class="headerlink" title="一、Java 基本语法简介"></a>一、Java 基本语法简介</h1><h2 id="01、数据类型"><a href="#01、数据类型" class="headerlink" title="01、数据类型"></a>01、数据类型</h2><p>Java 有 2 种数据类型，一种是基本数据类型，一种是引用类型。<br>基本数据类型用于存储简单类型的数据，比如说，int、long、byte、short 用于存储整数，float、double 用于存储浮点数，char 用于存储字符，boolean 用于存储布尔值。<br>不同的基本数据类型，有不同的默认值和大小，来个表格感受下。</p><table><thead><tr><th>数据类型</th><th>默认值</th><th>大小</th></tr></thead><tbody><tr><td>boolean</td><td>false</td><td>1比特</td></tr><tr><td>char</td><td>0</td><td>2字节</td></tr><tr><td>byte</td><td>0</td><td>1字节</td></tr><tr><td>short</td><td>0</td><td>2字节</td></tr><tr><td>int</td><td>0</td><td>4字节</td></tr><tr><td>long</td><td>0L</td><td>8字节</td></tr><tr><td>float</td><td>0.0f</td><td>4字节</td></tr><tr><td>double</td><td>0.0</td><td>8字节</td></tr></tbody></table><p>引用类型用于存储对象（null 表示没有值的对象）的引用，String 是引用类型的最佳代表，比如说 String cmower &#x3D; “沉默王二”。</p><h2 id="02、声明变量"><a href="#02、声明变量" class="headerlink" title="02、声明变量"></a>02、声明变量</h2><p>要声明一个变量，必须指定它的名字和类型，来看一个简单的示例：</p><pre><code class="line-numbers language-Java">int age;String name;</code></pre><p>count 和 name 在声明后会得到一个默认值，按照它们的数据类型——不能是局部变量（否则 Java 编译器会在你使用变量的时候提醒要先赋值），必须是类成员变量。</p><pre><code class="line-numbers language-Java">public class SyntaxLocalVariable &#123;    int age;    String name;    public static void main(String[] args) &#123;        SyntaxLocalVariable syntax = new SyntaxLocalVariable();        System.out.println(syntax.age); // 输出 0        System.out.println(syntax.name);  // 输出 null    &#125;&#125;</code></pre><p>也可以在声明一个变量后使用“&#x3D;”操作符进行赋值，就像下面这样：</p><pre><code class="line-numbers language-Java">int age = 18;String name = &quot;沉默王二&quot;;</code></pre><p>我们定义了 2 个变量，int 类型的 age 和 String 类型的 name，age 赋值 18，name 赋值为“沉默王二”。<br>每行代码后面都跟了一个“;”，表示当前语句结束了。<br>在 Java 中，变量最好遵守命名约定，这样能提高代码的可阅读性。</p><ul><li>以字母、下划线（_）或者美元符号（$）开头</li><li>不能使用 Java 的保留字，比如说 int 不能作为变量名</li></ul><h2 id="03、数组"><a href="#03、数组" class="headerlink" title="03、数组"></a>03、数组</h2><p>数组在 Java 中占据着重要的位置，它是很多集合类的底层实现。数组属于引用类型，它用来存储一系列指定类型的数据。<br>声明数组的一般语法如下所示：</p><pre><code class="line-numbers language-Java">type[] identiier = new type[length];</code></pre><p>type 可以是任意的基本数据类型或者引用类型。来看下面这个例子：</p><pre><code class="line-numbers language-Java">public class ArraysDemo &#123;    public static void main(String[] args) &#123;        int [] nums = new int[10];        nums[0] = 18;        nums[1] = 19;        System.out.println(nums[0]);    &#125;&#125;</code></pre><p>数组的索引从 0 开始，第一个元素的索引为 0，第二个元素的索引为 1。为什么要这样设计？感兴趣的话，你可以去探究一下。<br>通过变量名[索引]的方式可以访问数组指定索引处的元素，赋值或者取值是一样的。</p><h2 id="04、关键字"><a href="#04、关键字" class="headerlink" title="04、关键字"></a>04、关键字</h2><p>关键字属于保留字，在 Java 中具有特殊的含义，比如说 public、final、static、new 等等，它们不能用来作为变量名。为了便于你作为参照，我列举了 48 个常用的关键字，你可以瞅一瞅。</p><p>1： abstract： abstract 关键字用于声明抽象类——可以有抽象和非抽象方法。</p><p>2： boolean： boolean 关键字用于将变量声明为布尔值类型，它只有 true 和 false 两个值。</p><p>3： break： break 关键字用于中断循环或 switch 语句。</p><p>4： byte： byte 关键字用于声明一个可以容纳 8 个比特的变量。</p><p>5： case： case 关键字用于在 switch 语句中标记条件的值。</p><p>6： catch： catch 关键字用于捕获 try 语句中的异常。</p><p>7： char： char 关键字用于声明一个可以容纳无符号 16 位比特的 Unicode 字符的变量。</p><p>8： class： class 关键字用于声明一个类。</p><p>9： continue： continue 关键字用于继续下一个循环。它可以在指定条件下跳过其余代码。</p><p>10：default： default 关键字用于指定 switch 语句中除去 case 条件之外的默认代码块。</p><p>11：do： do 关键字通常和 while 关键字配合使用，do 后紧跟循环体。</p><p>12：double： double 关键字用于声明一个可以容纳 64 位浮点数的变量。</p><p>13：else： else 关键字用于指示 if 语句中的备用分支。</p><p>14：enum： enum（枚举）关键字用于定义一组固定的常量。</p><p>15：extends： extends 关键字用于指示一个类是从另一个类或接口继承的。</p><p>16：final： final 关键字用于指示该变量是不可更改的。</p><p>17：finally： finally 关键字和 try-catch 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。</p><p>18：float： float 关键字用于声明一个可以容纳 32 位浮点数的变量。</p><p>19：for： for 关键字用于启动一个 for 循环，如果循环次数是固定的，建议使用 for 循环。</p><p>20：if： if 关键字用于指定条件，如果条件为真，则执行对应代码。</p><p>21：implements： implements 关键字用于实现接口。</p><p>22：import： import 关键字用于导入对应的类或者接口。</p><p>23：instanceof： instanceof 关键字用于判断对象是否属于某个类型（class）。</p><p>24：int： int 关键字用于声明一个可以容纳 32 位带符号的整数变量。</p><p>25：interface： interface 关键字用于声明接口——只能具有抽象方法。</p><p>26：long： long 关键字用于声明一个可以容纳 64 位整数的变量。</p><p>27：native： native 关键字用于指定一个方法是通过调用本机接口（非 Java）实现的。</p><p>28：new： new 关键字用于创建一个新的对象。</p><p>29：null： 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null。</p><p>30：package： package 关键字用于声明类所在的包。</p><p>31：private： private 关键字是一个访问修饰符，表示方法或变量只对当前类可见。</p><p>32：protected： protected 关键字也是一个访问修饰符，表示方法或变量对同一包内的类和所有子类可见。</p><p>33：public： public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。</p><p>34：return： return 关键字用于在代码执行完成后返回（一个值）。</p><p>35：short： short 关键字用于声明一个可以容纳 16 位整数的变量。</p><p>36：static： static 关键字表示该变量或方法是静态变量或静态方法。</p><p>37：strictfp：  strictfp 关键字并不常见，通常用于修饰一个方法，确保方法体内的浮点数运算在每个平台上执行的结果相同。</p><p>38：super： super 关键字可用于调用父类的方法或者变量。</p><p>39：switch： switch 关键字通常用于三个（以上）的条件判断。</p><p>40：synchronized： synchronized 关键字用于指定多线程代码中的同步方法、变量或者代码块。</p><p>41：this： this 关键字可用于在方法或构造函数中引用当前对象。</p><p>42：throw： throw 关键字主动抛出异常。</p><p>43：throws： throws 关键字用于声明异常。</p><p>44：transient： transient 关键字在序列化的使用用到，它修饰的字段不会被序列化。</p><p>45：try： try 关键字用于包裹要捕获异常的代码块。</p><p>46：void： void 关键字用于指定方法没有返回值。</p><p>47：volatile： volatile 关键字保证了不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><p>48：while： 如果循环次数不固定，建议使用 while 循环。<br><img src="https://www.qyihe.xyz/images/post/10.1.jpg"></p><h2 id="05、操作符"><a href="#05、操作符" class="headerlink" title="05、操作符"></a>05、操作符</h2><p>除去“&#x3D;”赋值操作符，Java 中还有很多其他作用的操作符，我们来大致看一下。</p><h3 id="①、算术运算符"><a href="#①、算术运算符" class="headerlink" title="①、算术运算符"></a>①、算术运算符</h3><ul><li>+（加号）</li><li>–（减号）</li><li> *（乘号）</li><li> &#x2F;（除号）</li><li>％（取余）</li></ul><p>来看一个例子：</p><pre><code class="line-numbers language-Java">public class ArithmeticOperator &#123;    public static void main(String[] args) &#123;        int a = 10;        int b = 5;                System.out.println(a + b);//15          System.out.println(a - b);//5          System.out.println(a * b);//50          System.out.println(a / b);//2          System.out.println(a % b);//0      &#125;&#125;</code></pre><p>“+”号比较特殊，还可以用于字符串拼接，来看一个例子：</p><pre><code class="line-numbers language-Java">String result = &quot;沉默王二&quot; + &quot;一枚有趣的程序员&quot;;</code></pre><h3 id="②、逻辑运算符"><a href="#②、逻辑运算符" class="headerlink" title="②、逻辑运算符"></a>②、逻辑运算符</h3><p>逻辑运算符通常用于布尔表达式，常见的有：</p><ul><li>&amp;&amp;（AND）多个条件中只要有一个为 false 结果就为 false</li><li>||（OR）多个条件只要有一个为 true 结果就为 true</li><li>!（NOT）条件如果为 true，加上“!”就为 false，否则，反之。</li></ul><p>来看一个例子：</p><pre><code class="line-numbers language-Java">public class LogicalOperator &#123;    public static void main(String[] args) &#123;        int a=10;        int b=5;        int c=20;        System.out.println(a&lt;b&amp;&amp;a&lt;c);//false        System.out.println(a&gt;b||a&lt;c);//true        System.out.println(!(a&lt;b)); // true    &#125;&#125;</code></pre><h3 id="③、比较运算符"><a href="#③、比较运算符" class="headerlink" title="③、比较运算符"></a>③、比较运算符</h3><ul><li> &lt; (小于)</li><li> &lt;&#x3D; (小于或者等于)</li><li><blockquote><p>(大于)</p></blockquote></li><li> &gt;&#x3D; (大于或者等于)</li><li> &#x3D;&#x3D; (相等)</li><li> !&#x3D; (不等)</li></ul><h2 id="06、程序结构"><a href="#06、程序结构" class="headerlink" title="06、程序结构"></a>06、程序结构</h2><p>Java 中最小的程序单元叫做类，一个类可以有一个或者多个字段（也叫作成员变量），还可以有一个或者多个方法，甚至还可以有一些内部类。<br>如果一个类想要执行，就必须有一个 main 方法——程序运行的入口，就好像人的嘴一样，嗯，可以这么牵强的理解一下。</p><pre><code class="line-numbers language-Java">public class StructureProgram &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;没有成员变量，只有一个 main 方法&quot;);    &#125;&#125;</code></pre><ul><li>类名叫做 StructureProgram，在它里面，只有一个 main 方法。</li><li>{} 之间的代码称之为代码块。</li><li>以上源代码将会保存在一个后缀名为 java 的文件中。</li></ul><h2 id="07、编译然后执行代码"><a href="#07、编译然后执行代码" class="headerlink" title="07、编译然后执行代码"></a>07、编译然后执行代码</h2><p>通常，一些教程在介绍这块内容的时候，建议你通过命令行中先执行 javac 命令将源代码编译成字节码文件，然后再执行 java 命令指定代码。<br>但我不希望这个糟糕的局面再继续下去了——新手安装配置 JDK 真的蛮需要勇气和耐心的，稍有不慎，没入门就先放弃了。况且，在命令行中编译源代码会遇到很多莫名其妙的错误，这对新手是极其致命的——如果你再遇到这种老式的教程，可以吐口水了。<br>好的方法，就是去下载 IntelliJ IDEA，简称 IDEA，它被业界公认为最好的 Java 集成开发工具，尤其在智能代码助手、代码自动提示、代码重构、代码版本管理(Git、SVN、Maven)、单元测试、代码分析等方面有着亮眼的发挥。IDEA 产于捷克（位于东欧），开发人员以严谨著称。IDEA 分为社区版和付费版两个版本，新手直接下载社区版就足够用了。<br>安装成功后，可以开始敲代码了，然后直接右键运行（连保存都省了），结果会在 Run 面板中显示，如下图所示。<br><img src="https://www.qyihe.xyz/images/post/10.2.jpg"><br>想查看反编译后的字节码的话，可以在 src 的同级目录 target&#x2F;classes 的包路径下找到一个 StructureProgram.class 的文件（如果找不到的话，在目录上右键选择「Reload from Disk」）。<br>可以双击打开它。</p><pre><code class="line-numbers language-Java">//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.cmower.baeldung.basic;public class StructureProgram &#123;    public StructureProgram() &#123;    &#125;    public static void main(String[] args) &#123;        System.out.println(&quot;没有成员变量，只有一个 main 方法&quot;);    &#125;&#125;</code></pre><p>IDEA 默认会用 Fernflower 将 class 字节码反编译为我们可以看得懂的 Java 代码。实际上，class 字节码（请安装 show bytecode 插件）长下面这个样子：</p><pre><code class="line-numbers language-Java">// class version 57.65535 (-65479)// access flags 0x21public class com/cmower/baeldung/basic/StructureProgram &#123;  // compiled from: StructureProgram.java  // access flags 0x1  public &lt;init&gt;()V   L0    LINENUMBER 3 L0    ALOAD 0    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V    RETURN   L1    LOCALVARIABLE this Lcom/cmower/baeldung/basic/StructureProgram; L0 L1 0    MAXSTACK = 1    MAXLOCALS = 1  // access flags 0x9  public static main([Ljava/lang/String;)V   L0    LINENUMBER 5 L0    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;    LDC &quot;\u6ca1\u6709\u6210\u5458\u53d8\u91cf\uff0c\u53ea\u6709\u4e00\u4e2a main \u65b9\u6cd5&quot;    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V   L1    LINENUMBER 6 L1    RETURN   L2    LOCALVARIABLE args [Ljava/lang/String; L0 L2 0    MAXSTACK = 2    MAXLOCALS = 1&#125;</code></pre><p>新手看起来还是有些懵逼的，建议过过眼瘾就行了。<br><img src="https://www.qyihe.xyz/images/post/10.3.jpg"></p><h1 id="二、Java-基本数据类型简介"><a href="#二、Java-基本数据类型简介" class="headerlink" title="二、Java 基本数据类型简介"></a>二、Java 基本数据类型简介</h1><h2 id="01、布尔"><a href="#01、布尔" class="headerlink" title="01、布尔"></a>01、布尔</h2><p>布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：</p><pre><code class="line-numbers language-Java">boolean flag = true;</code></pre><h2 id="02、byte"><a href="#02、byte" class="headerlink" title="02、byte"></a>02、byte</h2><p>byte 的取值范围在 -128 和 127 之间，包含 127。最小值为 -128，最大值为 127，默认值为 0。<br>在网络传输的过程中，为了节省空间，常用字节来作为数据的传输方式。代码示例：</p><pre><code class="line-numbers language-Java">byte a = 10;byte b = -10;</code></pre><h2 id="03、short"><a href="#03、short" class="headerlink" title="03、short"></a>03、short</h2><p>short 的取值范围在 -32,768 和 32,767 之间，包含 32,767。最小值为 -32,768，最大值为 32,767，默认值为 0。代码示例：</p><pre><code class="line-numbers language-Java">short s = 10000;short r = -5000;</code></pre><h2 id="04、int"><a href="#04、int" class="headerlink" title="04、int"></a>04、int</h2><p>int 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间，默认值为 0。如果没有特殊需求，整形数据就用 int。代码示例：</p><pre><code class="line-numbers language-Java">int a = 100000;int b = -200000;```Java## 05、longlong 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间，默认值为 0。如果 int 存储不下，就用 long，整形数据就用 int。代码示例：```Javalong a = 100000L; long b = -200000L;</code></pre><p>为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。</p><h2 id="06、float"><a href="#06、float" class="headerlink" title="06、float"></a>06、float</h2><p>float 是单精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围是无限的，默认值为 0.0f。float 不适合用于精确的数值，比如说货币。代码示例：</p><pre><code class="line-numbers language-Java">float f1 = 234.5f;</code></pre><p>为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。</p><h2 id="07、double"><a href="#07、double" class="headerlink" title="07、double"></a>07、double</h2><p>double 是双精度的浮点数，遵循 IEEE 754（二进制浮点数算术标准），取值范围也是无限的，默认值为 0.0。double 同样不适合用于精确的数值，比如说货币。代码示例：</p><pre><code class="line-numbers language-Java">double d1 = 12.3</code></pre><p>那精确的数值用什么表示呢？最好使用 BigDecimal，它可以表示一个任意大小且精度完全准确的浮点数。针对货币类型的数值，也可以先乘以 100 转成整形进行处理。<br>Tips：单精度是这样的格式，1 位符号，8 位指数，23 位小数，有效位数为 7 位。<br><img src="https://www.qyihe.xyz/images/post/10.4.jpg"><br>双精度是这样的格式，1 位符号，11 位指数，52 为小数，有效位数为 16 位。<br><img src="https://www.qyihe.xyz/images/post/10.5.jpg"><br>取值范围取决于指数位，计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。</p><blockquote><p>一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。</p></blockquote><h2 id="08、char"><a href="#08、char" class="headerlink" title="08、char"></a>08、char</h2><p>char 可以表示一个 16 位的 Unicode 字符，其值范围在 ‘\u0000’（0）和 ‘\uffff’（65,535）（包含）之间。代码示例：</p><pre><code class="line-numbers language-Java">char letterA = &#39;A&#39;; // 用英文的单引号包裹住。</code></pre><h1 id="三、Java-main-方法简介"><a href="#三、Java-main-方法简介" class="headerlink" title="三、Java main() 方法简介"></a>三、Java main() 方法简介</h1><p>每个程序都需要一个入口，对于 Java 程序来说，入口就是 main 方法。</p><pre><code>public static void main(String[] args) &#123;&#125;</code></pre><ul><li><p>public、static、void 这 3 个关键字在前面的内容已·经介绍过了，如果觉得回去找比较麻烦的话，这里再贴一下：</p></li><li><p>public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。main() 方法必须声明为 public。</p></li><li><p>static 关键字表示该变量或方法是静态变量或静态方法，可以直接通过类访问，不需要实例化对象来访问。</p></li><li><p>void 关键字用于指定方法没有返回值。</p></li></ul><p>另外，main 关键字为方法的名字，Java 虚拟机在执行程序时会寻找这个标识符；args 为 main() 方法的参数名，它的类型为一个 String 数组，也就是说，在使用 java 命令执行程序的时候，可以给 main() 方法传递字符串数组作为参数。</p><pre><code class="line-numbers language-Java">java HelloWorld 沉默王二 沉默王三</code></pre><p>javac 命令用来编译程序，java 命令用来执行程序，HelloWorld 为这段程序的类名，沉默王二和沉默王三为字符串数组，中间通过空格隔开，然后就可以在 main() 方法中通过 args[0] 和 args[1] 获取传递的参数值了。</p><pre><code class="line-numbers language-Java">public class HelloWorld &#123;    public static void main(String[] args) &#123;        if (&quot;沉默王二&quot;.equals(args[0])) &#123;                    &#125;                if (&quot;沉默王三&quot;.equals(args[1])) &#123;                    &#125;    &#125;&#125;</code></pre><p>main() 方法的写法并不是唯一的，还有其他几种变体，尽管它们可能并不常见，可以简单来了解一下。</p><p>第二种，把方括号 [] 往 args 靠近而不是 String 靠近：</p><pre><code class="line-numbers language-Java">public static void main(String []args) &#123; &#125;</code></pre><p>第三种，把方括号 [] 放在 args 的右侧：</p><pre><code class="line-numbers language-Java">public static void main(String args[]) &#123;&#125;</code></pre><p>第四种，还可以把数组形式换成可变参数的形式：</p><pre><code class="line-numbers language-Java">public static void main(String...args) &#123; &#125;</code></pre><p>第五种，在 main() 方法上添加另外一个修饰符 strictfp，用于强调在处理浮点数时的兼容性：</p><pre><code class="line-numbers language-Java">public strictfp static void main(String[] args) &#123; &#125;</code></pre><p>也可以在 main() 方法上添加 final 关键字或者 synchronized 关键字。</p><p>第六种，还可以为 args 参数添加 final 关键字：</p><pre><code class="line-numbers language-Java">public static void main(final String[] args) &#123; &#125;</code></pre><p>第七种，最复杂的一种，所有可以添加的关键字统统添加上：</p><pre><code class="line-numbers language-Java">final static synchronized strictfp void main(final String[] args) &#123; &#125;</code></pre><p>当然了，并不需要为了装逼特意把 main() 方法写成上面提到的这些形式，使用 IDE 提供的默认形式就可以了。</p><h1 id="四、Java-的流程控制语句"><a href="#四、Java-的流程控制语句" class="headerlink" title="四、Java 的流程控制语句"></a>四、Java 的流程控制语句</h1><ul><li><p>在 Java 中，有三种类型的流程控制语句：</p></li><li><p>条件分支，用于在两个或者多个条件之间做出选择，常见的有 if&#x2F;else&#x2F;else if、三元运算符和 switch 语句。</p></li><li><p>循环或者遍历，常见的有 for、while 和 do-while。</p></li><li><p>break 和 continue，用于跳出循环或者跳过进入下一轮循环。</p></li></ul><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>if 语句的格式如下：</p><pre><code class="line-numbers language-Java">if(布尔表达式)&#123;  // 如果条件为 true，则执行这块代码&#125; </code></pre><p>画个流程图表示一下：<br><img src="https://www.qyihe.xyz/images/post/10.6.jpg"><br>来写个示例：</p><pre><code class="line-numbers language-Java">public class IfExample &#123;    public static void main(String[] args) &#123;        int age = 20;        if (age &lt; 30) &#123;            System.out.println(&quot;青春年华&quot;);        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">青春年华</code></pre><h2 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a>if-else 语句</h2><p>if-else 语句的格式如下:</p><pre><code class="line-numbers language-Java">if(布尔表达式)&#123;  // 条件为 true 时执行的代码块&#125;else&#123;  // 条件为 false  时执行的代码块&#125;  </code></pre><p>画个流程图表示一下：<br><img src="https://www.qyihe.xyz/images/post/10.7.jpg"><br>来写个示例：</p><pre><code class="line-numbers language-Java">public class IfElseExample &#123;    public static void main(String[] args) &#123;        int age = 31;        if (age &lt; 30) &#123;            System.out.println(&quot;青春年华&quot;);        &#125; else &#123;            System.out.println(&quot;而立之年&quot;);        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">而立之年</code></pre><p>除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：</p><pre><code class="line-numbers language-Java">public class LeapYear &#123;    public static void main(String[] args) &#123;        int year = 2020;        if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) &#123;            System.out.println(&quot;闰年&quot;);        &#125; else &#123;            System.out.println(&quot;普通年份&quot;);        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code>闰年```Java如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。</code></pre><p>public class IfElseTernaryExample {<br>    public static void main(String[] args) {<br>        int num &#x3D; 13;<br>        String result &#x3D; (num % 2 &#x3D;&#x3D; 0) ? “偶数” : “奇数”;<br>        System.out.println(result);<br>    }<br>}</p><pre><code>输出：```Java奇数</code></pre><h2 id="if-else-if-语句"><a href="#if-else-if-语句" class="headerlink" title="if-else-if 语句"></a>if-else-if 语句</h2><p>if-else-if 语句的格式如下：</p><pre><code class="line-numbers language-Java">if(条件1)&#123;  // 条件1 为 true 时执行的代码&#125;else if(条件2)&#123;  // 条件2 为 true 时执行的代码&#125;  else if(条件3)&#123;  // 条件3 为 true 时执行的代码&#125;  ...  else&#123;  // 以上条件均为 false 时执行的代码&#125; </code></pre><p>画个流程图表示一下：<br><img src="https://www.qyihe.xyz/images/post/10.8.jpg"><br>来写个示例：</p><pre><code class="line-numbers language-Java">public class IfElseIfExample &#123;    public static void main(String[] args) &#123;        int age = 31;        if (age &lt; 30) &#123;            System.out.println(&quot;青春年华&quot;);        &#125; else if (age &gt;= 30 &amp;&amp; age &lt; 40 ) &#123;            System.out.println(&quot;而立之年&quot;);        &#125; else if (age &gt;= 40 &amp;&amp; age &lt; 50 ) &#123;            System.out.println(&quot;不惑之年&quot;);        &#125; else &#123;            System.out.println(&quot;知天命&quot;);        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">而立之年</code></pre><h2 id="if-嵌套语句"><a href="#if-嵌套语句" class="headerlink" title="if 嵌套语句"></a>if 嵌套语句</h2><p>if 嵌套语句的格式如下：</p><pre><code class="line-numbers language-Java">if(外侧条件)&#123;         // 外侧条件为 true 时执行的代码           if(内侧条件)&#123;               // 内侧条件为 true 时执行的代码    &#125;    &#125;  </code></pre><p>画个流程图表示一下：<br><img src="https://www.qyihe.xyz/images/post/10.9.jpg"><br>来写个示例：</p><pre><code class="line-numbers language-Java">public class NestedIfExample &#123;    public static void main(String[] args) &#123;        int age = 20;        boolean isGirl = true;        if (age &gt;= 20) &#123;            if (isGirl) &#123;                System.out.println(&quot;女生法定结婚年龄&quot;);            &#125;        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">女生法定结婚年龄</code></pre><h2 id="switch-语句的格式："><a href="#switch-语句的格式：" class="headerlink" title="switch 语句的格式："></a>switch 语句的格式：</h2><pre><code class="line-numbers language-Java">switch(变量) &#123;    case 可选值1:     // 可选值1匹配后执行的代码;     break;  // 该关键字是可选项case 可选值2:     // 可选值2匹配后执行的代码;     break;  // 该关键字是可选项......        default: // 该关键字是可选项      // 所有可选值都不匹配后执行的代码 &#125;    </code></pre><ul><li><p>变量可以有 1 个或者 N 个值。</p></li><li><p>值类型必须和变量类型是一致的，并且值是确定的。</p></li><li><p>值必须是唯一的，不能重复，否则编译会出错。</p></li><li><p>break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。</p></li><li><p>default 关键字也是可选的。<br><img src="https://www.qyihe.xyz/images/post/10.10.jpg"><br>画个流程图：</p></li></ul><p>来个示例：</p><pre><code class="line-numbers language-Java">public class Switch1 &#123;    public static void main(String[] args) &#123;        int age = 20;        switch (age) &#123;            case 20 :                System.out.println(&quot;上学&quot;);                break;            case 24 :                System.out.println(&quot;苏州工作&quot;);                break;            case 30 :                System.out.println(&quot;洛阳工作&quot;);                break;            default:                System.out.println(&quot;未知&quot;);                break; // 可省略        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">上学</code></pre><p>当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：</p><pre><code class="line-numbers language-Java">public class Switch2 &#123;    public static void main(String[] args) &#123;        String name = &quot;沉默王二&quot;;        switch (name) &#123;            case &quot;詹姆斯&quot;:                System.out.println(&quot;篮球运动员&quot;);                break;            case &quot;穆里尼奥&quot;:                System.out.println(&quot;足球教练&quot;);                break;            case &quot;沉默王二&quot;:            case &quot;沉默王三&quot;:                System.out.println(&quot;乒乓球爱好者&quot;);                break;            default:                throw new IllegalArgumentException(                        &quot;名字没有匹配项&quot;);        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">乒乓球爱好者</code></pre><p>枚举作为 switch 语句的变量也很常见，来看例子：</p><pre><code class="line-numbers language-Java">public class SwitchEnumDemo &#123;    public enum PlayerTypes &#123;        TENNIS,        FOOTBALL,        BASKETBALL,        UNKNOWN    &#125;    public static void main(String[] args) &#123;        System.out.println(createPlayer(PlayerTypes.BASKETBALL));    &#125;    private static String createPlayer(PlayerTypes playerType) &#123;        switch (playerType) &#123;            case TENNIS:                return &quot;网球运动员费德勒&quot;;            case FOOTBALL:                return &quot;足球运动员C罗&quot;;            case BASKETBALL:                return &quot;篮球运动员詹姆斯&quot;;            case UNKNOWN:                throw new IllegalArgumentException(&quot;未知&quot;);            default:                throw new IllegalArgumentException(                        &quot;运动员类型: &quot; + playerType);        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">篮球运动员詹姆斯</code></pre><h2 id="循环语句比较"><a href="#循环语句比较" class="headerlink" title="循环语句比较"></a>循环语句比较</h2><table><thead><tr><th>比较方式</th><th>for</th><th>while</th><th>do-while</th></tr></thead><tbody><tr><td>简介</td><td>for 循环的次数是固定的</td><td>while 循环的次数是不固定的，并且需要条件为 true</td><td>do-while 循环的次数也不固定，但会至少执行一次循环，无聊条件是否为 true</td></tr><tr><td>何时使用</td><td>循环次数固定的</td><td>循环次数是不固定的</td><td>循环次数不固定，并且循环体至少要执行一次</td></tr><tr><td>语法</td><td>for(init:condition;++&#x2F;–) {&#x2F;&#x2F; 要执行的代码}</td><td>while(condition){&#x2F;&#x2F; 要执行的代码}</td><td>do{&#x2F;&#x2F;要执行的代码}while(condition);</td></tr></tbody></table><h2 id="普通的-for-循环"><a href="#普通的-for-循环" class="headerlink" title="普通的 for 循环"></a>普通的 for 循环</h2><p>普通的 for 循环可以分为 4 个部分：<br>（1）初始变量：循环开始执行时的初始条件。<br>（2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。<br>（3）循环体：循环每次要执行的代码块，直到条件变为 false。<br>（4）自增&#x2F;自减：初识变量变化的方式。<br>来看一下普通 for 循环的格式：</p><pre><code class="line-numbers language-Java">for(初识变量;条件;自增/自减)&#123;  // 循环体&#125;  </code></pre><p>画个流程图：<br><img src="https://www.qyihe.xyz/images/post/10.11.jpg"><br>来个示例：</p><pre><code>public class ForExample &#123;    public static void main(String[] args) &#123;        for (int i = 0; i &lt; 5; i++) &#123;            System.out.println(&quot;沉默王二好帅啊&quot;);        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">沉默王二好帅啊沉默王二好帅啊沉默王二好帅啊沉默王二好帅啊沉默王二好帅啊</code></pre><p>循环语句还可以嵌套呢，这样就可以打印出更好玩的呢。</p><pre><code class="line-numbers language-Java">public class PyramidForExample &#123;    public static void main(String[] args) &#123;        for (int i = 0; i &lt; 5; i++) &#123;            for (int j = 0;j&lt;= i;j++) &#123;                System.out.print(&quot;❤&quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;</code></pre><p>打印出什么玩意呢？</p><pre><code class="line-numbers language-Java">❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤</code></pre><h2 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h2><p>for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：</p><pre><code class="line-numbers language-Java">for(元素类型 元素 : 数组或集合)&#123;  // 要执行的代码&#125;  </code></pre><p>来看一下示例：</p><pre><code class="line-numbers language-Java">public class ForEachExample &#123;    public static void main(String[] args) &#123;        String[] strs = &#123;&quot;沉默王二&quot;, &quot;一枚有趣的程序员&quot;&#125;;        for (String str : strs) &#123;            System.out.println(str);        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">沉默王二一枚有趣的程序员</code></pre><h2 id="无限-for-循环"><a href="#无限-for-循环" class="headerlink" title="无限 for 循环"></a>无限 for 循环</h2><p>想不想体验一下无限 for 循环的威力，也就是死循环？</p><pre><code class="line-numbers language-Java">public class InfinitiveForExample &#123;    public static void main(String[] args) &#123;        for(;;)&#123;            System.out.println(&quot;停不下来。。。。&quot;);        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">停不下来。。。。停不下来。。。。停不下来。。。。停不下来。。。。</code></pre><p>一旦运行起来，就停不下来了，除非强制停止。</p><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><pre><code class="line-numbers language-Java">while(条件)&#123;  //循环体  &#125;  </code></pre><p>画个流程图：<br><img src="https://www.qyihe.xyz/images/post/10.12.jpg"><br>来个示例：</p><pre><code class="line-numbers language-Java">public class WhileExample &#123;    public static void main(String[] args) &#123;        int i = 0;        while (true) &#123;            System.out.println(&quot;沉默王二&quot;);            i++;            if (i == 5) &#123;                break;            &#125;        &#125;    &#125;&#125;</code></pre><p>猜猜会输出几次？</p><pre><code class="line-numbers language-Java">沉默王二沉默王二沉默王二沉默王二沉默王二</code></pre><h2 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h2><pre><code class="line-numbers language-Java">do&#123;  // 循环体&#125;while(提交); </code></pre><p>画个流程图：<br><img src="https://www.qyihe.xyz/images/post/10.13.jpg"><br>来个示例：</p><pre><code>public class DoWhileExample &#123;    public static void main(String[] args) &#123;        int i = 0;        do &#123;            System.out.println(&quot;沉默王二&quot;);            i++;            if (i == 5) &#123;                break;            &#125;        &#125; while (true);    &#125;&#125;</code></pre><p>程序输出结果如下所示：</p><pre><code class="line-numbers language-Java">沉默王二沉默王二沉默王二沉默王二沉默王二</code></pre><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>break 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。<br>可以将 break 关键字用于所有类型循环语句中，比如说 for 循环，while 循环，以及 do-while 循环。<br>来画个流程图感受一下：<br><img src="https://www.qyihe.xyz/images/post/10.14.jpg"><br>用在 for 循环中的示例：</p><pre><code class="line-numbers language-Java">for (int i = 1; i &lt;= 10; i++) &#123;    if (i == 5) &#123;        break;    &#125;    System.out.println(i);&#125;</code></pre><p>用在嵌套 for 循环中的示例：</p><pre><code class="line-numbers language-Java">for (int i = 1; i &lt;= 3; i++) &#123;    for (int j = 1; j &lt;= 3; j++) &#123;        if (i == 2 &amp;&amp; j == 2) &#123;            break;        &#125;        System.out.println(i + &quot; &quot; + j);    &#125;&#125;</code></pre><p>用在 while 循环中的示例：</p><pre><code class="line-numbers language-Java">int i = 1;while (i &lt;= 10) &#123;    if (i == 5) &#123;        i++;        break;    &#125;    System.out.println(i);    i++;&#125;</code></pre><p>用在 do-while 循环中的示例：</p><pre><code class="line-numbers language-Java">int j = 1;do &#123;    if (j == 5) &#123;         j++;        break;    &#125;    System.out.println(j);    j++;&#125; while (j &lt;= 10);</code></pre><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。<br>来个示例：</p><pre><code class="line-numbers language-Java">public class ContinueDemo &#123;    public static void main(String[] args) &#123;        for (int i = 1; i &lt;= 10; i++) &#123;            if (i == 5) &#123;                // 使用 continue 关键字                continue;// 5 将会被跳过            &#125;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">1234678910</code></pre><p>5 真的被跳过了。<br>再来个循环嵌套的例子。</p><pre><code class="line-numbers language-Java">public class ContinueInnerDemo &#123;    public static void main(String[] args) &#123;        for (int i = 1; i &lt;= 3; i++) &#123;            for (int j = 1; j &lt;= 3; j++) &#123;                if (i == 2 &amp;&amp; j == 2) &#123;                    //  当i=2，j=2时跳过                    continue;                &#125;                System.out.println(i + &quot; &quot; + j);            &#125;        &#125;    &#125;&#125;</code></pre><p>打印出什么玩意呢？</p><pre><code class="line-numbers language-Java">1 11 21 32 12 33 13 23 3</code></pre><p>“2 2” 没有输出，被跳过了。<br>再来看一下 while 循环时 continue 的使用示例：</p><pre><code class="line-numbers language-Java">public class ContinueWhileDemo &#123;    public static void main(String[] args) &#123;        int i = 1;        while (i &lt;= 10) &#123;            if (i == 5) &#123;                i++;                continue;            &#125;            System.out.println(i);            i++;        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">1234678910</code></pre><p>注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。<br>最后，再来看一下 do-while 循环时 continue 的使用示例：</p><pre><code class="line-numbers language-Java">public class ContinueDoWhileDemo &#123;    public static void main(String[] args) &#123;        int i=1;        do&#123;            if(i==5)&#123;                i++;                continue;            &#125;            System.out.println(i);            i++;        &#125;while(i&lt;=10);    &#125;&#125;</code></pre><p>输出：</p><pre><code class="line-numbers language-Java">1234678910</code></pre><p>注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。</p><h1 id="五、Java-包的简介"><a href="#五、Java-包的简介" class="headerlink" title="五、Java 包的简介"></a>五、Java 包的简介</h1><p>在 Java 中，我们使用 package（包）对相关的类、接口和子包进行分组。这样做的好处有：</p><ul><li>使相关类型更容易查找</li><li>避免命名冲突，比如说 com.itwanger.Hello 和 com.itwangsan.Hello 不同</li><li>通过包和访问权限控制符来限定类的可见性</li></ul><h2 id="01、创建一个包"><a href="#01、创建一个包" class="headerlink" title="01、创建一个包"></a>01、创建一个包</h2><pre><code class="line-numbers language-Java">package com.itwanger;</code></pre><p>可以使用 package 关键字来定义一个包名，需要注意的是，这行代码必须处于一个类中的第一行。强烈建议在包中声明类，不要缺省，否则就失去了包结构的带来的好处。<br>包的命名应该遵守以下规则：</p><ul><li>应该全部是小写字母</li><li>可以包含多个单词，单词之间使用“.”连接，比如说 java.lang</li><li>名称由公司名或者组织名确定，采用倒序的方式，比如说，我个人博客的域名是 <a href="http://www.itwanger.com,所以我创建的包名是就是/">www.itwanger.com，所以我创建的包名是就是</a> com.itwanger.xxxx。</li></ul><p>每个包或者子包都在磁盘上有自己的目录结构，如果 Java 文件时在 com.itwanger.xxxx 包下，那么该文件所在的目录结构就应该是 com-&gt;itwanger-&gt;xxxx。</p><h2 id="02、使用包"><a href="#02、使用包" class="headerlink" title="02、使用包"></a>02、使用包</h2><p>让我们在名为 test 的子包里新建一个 Cmower 类：</p><pre><code class="line-numbers language-Java">package com.itwanger.test;public class Cmower &#123;    private String name;    private int age;&#125;</code></pre><p>如果需要在另外一个包中使用 Cmower 类，就需要通过 import 关键字将其引入。有两种方式可供选择，第一种，使用 * 导入包下所有的类：</p><pre><code class="line-numbers language-Java">import com.itwanger.test.*;</code></pre><p>第二种，使用类名导入该类：</p><pre><code class="line-numbers language-Java">import com.itwanger.test.Cmower;</code></pre><p>Java 和第三方类库提供了很多包可供使用，可以通过上述的方式导入类库使用。</p><pre><code class="line-numbers language-Java">package com.itwanger.test;import java.util.ArrayList;import java.util.List;public class CmowerTest &#123;    public static void main(String[] args) &#123;        List&lt;Cmower&gt; list = new ArrayList&lt;&gt;();        list.add(new Cmower());    &#125;&#125;</code></pre><h2 id="03、全名"><a href="#03、全名" class="headerlink" title="03、全名"></a>03、全名</h2><p>有时，我们可能会使用来自不同包下的两个具有相同名称的类。例如，我们可能同时使用 java.sql.Date 和 java.util.Date。当我们遇到命名冲突时，我们需要对至少一个类使用全名（包名+类名）。</p><pre><code class="line-numbers language-Java">List&lt;com.itwanger.test.Cmower&gt; list1 = new ArrayList&lt;&gt;();list.add(new com.itwanger.test.Cmower());</code></pre><h1 id="六、Java-到底是值传递还是引用传递"><a href="#六、Java-到底是值传递还是引用传递" class="headerlink" title="六、Java 到底是值传递还是引用传递"></a>六、Java 到底是值传递还是引用传递</h1><p>将参数传递给方法有两种常见的方式，一种是“值传递”，一种是“引用传递”。C 语言本身只支持值传递，它的衍生品 C++ 既支持值传递，也支持引用传递，而 Java 只支持值传递。</p><h2 id="01、值传递-VS-引用传递"><a href="#01、值传递-VS-引用传递" class="headerlink" title="01、值传递 VS 引用传递"></a>01、值传递 VS 引用传递</h2><p>首先，我们必须要搞清楚，到底什么是值传递，什么是引用传递，否则，讨论 Java 到底是值传递还是引用传递就显得毫无意义。<br>当一个参数按照值的方式在两个方法之间传递时，调用者和被调用者其实是用的两个不同的变量——被调用者中的变量（原始值）是调用者中变量的一份拷贝，对它们当中的任何一个变量修改都不会影响到另外一个变量。<br>而当一个参数按照引用传递的方式在两个方法之间传递时，调用者和被调用者其实用的是同一个变量，当该变量被修改时，双方都是可见的。<br>Java 程序员之所以容易搞混值传递和引用传递，主要是因为 Java 有两种数据类型，一种是基本类型，比如说 int，另外一种是引用类型，比如说 String。<br>基本类型的变量存储的都是实际的值，而引用类型的变量存储的是对象的引用——指向了对象在内存中的地址。值和引用存储在 stack（栈）中，而对象存储在 heap（堆）中。<br><img src="https://www.qyihe.xyz/images/post/10.15.jpg"><br>之所以有这个区别，是因为：</p><ul><li>栈的优势是，存取速度比堆要快，仅次于直接位于 CPU 中的寄存器。但缺点是，栈中的数据大小与生存周期必须是确定的。</li><li>堆的优势是可以动态地分配内存大小，生存周期也不必事先告诉编译器，Java 的垃圾回收器会自动收走那些不再使用的数据。但由于要在运行时动态分配内存，存取速度较慢。</li></ul><h2 id="02、基本类型的参数传递"><a href="#02、基本类型的参数传递" class="headerlink" title="02、基本类型的参数传递"></a>02、基本类型的参数传递</h2><p>众所周知，Java 有 8 种基本数据类型，分别是 int、long、byte、short、float、double 、char 和 boolean。它们的值直接存储在栈中，每当作为参数传递时，都会将原始值（实参）复制一份新的出来，给形参用。形参将会在被调用方法结束时从栈中清除。<br>来看下面这段代码：</p><pre><code class="line-numbers language-Java">public class PrimitiveTypeDemo &#123;    public static void main(String[] args) &#123;        int age = 18;        modify(age);        System.out.println(age);    &#125;    private static void modify(int age1) &#123;        age1 = 30;    &#125;&#125;</code></pre><p>（1）main 方法中的 age 是基本类型，所以它的值 18 直接存储在栈中。<br>（2）调用 modify() 方法的时候，将为实参 age 创建一个副本（形参 age1），它的值也为 18，不过是在栈中的其他位置。<br>（3）对形参 age 的任何修改都只会影响它自身而不会影响实参。<br><img src="https://www.qyihe.xyz/images/post/10.16.jpg"></p><h2 id="03、引用类型的参数传递"><a href="#03、引用类型的参数传递" class="headerlink" title="03、引用类型的参数传递"></a>03、引用类型的参数传递</h2><p>来看一段创建引用类型变量的代码：</p><pre><code class="line-numbers language-Java">Writer writer = new Writer(18, &quot;沉默王二&quot;);</code></pre><p>writer 是对象吗？还是对象的引用？为了搞清楚这个问题，我们可以把上面的代码拆分为两行代码：</p><pre><code class="line-numbers language-Java">Writer writer;writer = new Writer(18, &quot;沉默王二&quot;);</code></pre><p>假如 writer 是对象的话，就不需要通过 new 关键字创建对象了，对吧？那也就是说，writer 并不是对象，在“&#x3D;”操作符执行之前，它仅仅是一个变量。那谁是对象呢？new Writer(18, “沉默王二”)，它是对象，存储于堆中；然后，“&#x3D;”操作符将对象的引用赋值给了 writer 变量，于是 writer 此时应该叫对象引用，它存储在栈中，保存了对象在堆中的地址。<br>每当引用类型作为参数传递时，都会创建一个对象引用（实参）的副本（形参），该形参保存的地址和实参一样。<br>来看下面这段代码：</p><pre><code class="line-numbers language-Java">public class ReferenceTypeDemo &#123;    public static void main(String[] args) &#123;        Writer a = new Writer(18);        Writer b = new Writer(18);        modify(a, b);        System.out.println(a.getAge());        System.out.println(b.getAge());    &#125;    private static void modify(Writer a1, Writer b1) &#123;        a1.setAge(30);        b1 = new Writer(18);        b1.setAge(30);    &#125;&#125;</code></pre><p>（1）在调用 modify() 方法之前，实参 a 和 b 指向的对象是不一样的，尽管 age 都为 18。<br><img src="https://www.qyihe.xyz/images/post/10.17.jpg"><br>（2）在调用 modify() 方法时，实参 a 和 b 都在栈中创建了一个新的副本，分别是 a1 和 b1，但指向的对象是一致的（a 和 a1 指向对象 a，b 和 b1 指向对象 b）。<br><img src="https://www.qyihe.xyz/images/post/10.18.jpg"><br>（3）在 modify() 方法中，修改了形参 a1 的 age 为 30，意味着对象 a 的 age 从 18 变成了 30，而实参 a 指向的也是对象 a，所以 a 的 age 也变成了 30；形参 b1 指向了一个新的对象，随后 b1 的 age 被修改为 30。<br><img src="https://www.qyihe.xyz/images/post/10.19.jpg"><br>修改 a1 的 age，意味着同时修改了 a 的 age，因为它们指向的对象是一个；修改 b1 的 age，对 b 却没有影响，因为它们指向的对象是两个。<br>程序输出的结果如下所示：</p><pre><code class="line-numbers language-Java">3018</code></pre><p>果然和我们的分析是吻合的。</p><h1 id="七、Java-的类和对象"><a href="#七、Java-的类和对象" class="headerlink" title="七、Java 的类和对象"></a>七、Java 的类和对象</h1><p>类和对象是 Java 中最基本的两个概念，可以说撑起了面向对象编程（OOP）的一片天。对象可以是现实中看得见的任何物体（一只特立独行的猪），也可以是想象中的任何虚拟物体（能七十二变的孙悟空），Java 通过类（class）来定义这些物体，有什么状态（通过字段，或者叫成员变量定义，比如说猪的颜色是纯色还是花色），有什么行为（通过方法定义，比如说猪会吃，会睡觉）。<br>来，让我来定义一个简单的类给你看看。</p><pre><code class="line-numbers language-Java">public class Pig &#123;    private String color;    public void eat() &#123;        System.out.println(&quot;吃&quot;);    &#125;&#125;</code></pre><p>默认情况下，每个 Java 类都会有一个空的构造方法，尽管它在源代码中是缺省的，但却可以通过反编译字节码看到它。</p><pre><code class="line-numbers language-Java">public class Pig &#123;    private String color;    public Pig() &#123;    &#125;    public void eat() &#123;        System.out.println(&quot;吃&quot;);    &#125;&#125;</code></pre><p>没错，就是多出来的那个 public Pig() {}，参数是空的，方法体是空的。我们可以通过 new 关键字利用这个构造方法来创建一个对象，代码如下所示：</p><pre><code class="line-numbers language-Java">Pig pig = new Pig();</code></pre><p>当然了，我们也可以主动添加带参的构造方法。</p><pre><code class="line-numbers language-Java">public class Pig &#123;    private String color;    public Pig(String color) &#123;        this.color = color;    &#125;    public void eat() &#123;        System.out.println(&quot;吃&quot;);    &#125;&#125;</code></pre><p>这时候，再查看反编译后的字节码时，你会发现缺省的无参构造方法消失了——和源代码一模一样。</p><pre><code class="line-numbers language-Java">public class Pig &#123;    private String color;    public Pig(String color) &#123;        this.color = color;    &#125;    public void eat() &#123;        System.out.println(&quot;吃&quot;);    &#125;&#125;</code></pre><p>这意味着无法通过 new Pig() 来创建对象了——编译器会提醒你追加参数。<br><img src="https://www.qyihe.xyz/images/post/10.20.jpg"><br>比如说你将代码修改为 new Pig(“纯白色”)，或者添加无参的构造方法。</p><pre><code class="line-numbers language-Java">public class Pig &#123;    private String color;    public Pig(String color) &#123;        this.color = color;    &#125;    public Pig() &#123;    &#125;    public void eat() &#123;        System.out.println(&quot;吃&quot;);    &#125;&#125;</code></pre><p>使用无参构造方法创建的对象状态默认值为 null（color 字符串为引用类型），如果是基本类型的话，默认值为对应基本类型的默认值，比如说 int 为 0，更详细的见下图。<br><img src="https://www.qyihe.xyz/images/post/10.21.jpg"><br>（图片中有一处错误，boolean 的默认值为 false）<br>接下来，我们来创建多个 Pig 对象，它的颜色各不相同。</p><pre><code class="line-numbers language-Java">public class PigTest &#123;    public static void main(String[] args) &#123;        Pig pigNoColor = new Pig();        Pig pigWhite = new Pig(&quot;纯白色&quot;);        Pig pigBlack = new Pig(&quot;纯黑色&quot;);    &#125;&#125;</code></pre><p>你看，我们创建了 3 个不同花色的 Pig 对象，全部来自于一个类，由此可见类的重要性，只需要定义一次，就可以多次使用。<br>那假如我想改变对象的状态呢？该怎么办？目前毫无办法，因为没有任何可以更改状态的方法，直接修改 color 是行不通的，因为它的访问权限修饰符是 private 的。<br>最好的办法就是为 Pig 类追加 getter&#x2F;setter 方法，就像下面这样：</p><pre><code class="line-numbers language-Java">public String getColor() &#123;    return color;&#125;public void setColor(String color) &#123;    this.color = color;&#125;</code></pre><p>通过 setColor() 方法来修改，通过 getColor() 方法获取状态，它们的权限修饰符是 public 的。</p><pre><code class="line-numbers language-Java">Pig pigNoColor = new Pig();pigNoColor.setColor(&quot;花色&quot;);System.out.println(pigNoColor.getColor()); // 花色</code></pre><p>为什么要这样设计呢？可以直接将 color 字段的访问权限修饰符换成是 public 的啊，不就和 getter&#x2F;setter 一样的效果了吗？<br>因为有些情况，某些字段是不允许被随意修改的，它只有在对象创建的时候初始化一次，比如说猪的年龄，它只能每年长一岁（举个例子），没有月光宝盒让它变回去。</p><pre><code class="line-numbers language-Java">private int age;public int getAge() &#123;    return age;&#125;public void increaseAge() &#123;    this.age++;&#125;</code></pre><p>你看，age 就没有 setter 方法，只有一个每年可以调用一次的 increaseAge() 方法和 getter 方法。如果把 age 的访问权限修饰符更改为 public，age 就完全失去控制了，可以随意将其重置为 0 或者负数。<br>访问权限修饰符对于 Java 来说，非常重要，目前共有四种：public、private、protected 和 default（缺省）。<br>一个类只能使用 public 或者 default 修饰，public 修饰的类你之前已经见到过了，现在我来定义一个缺省权限修饰符的类给你欣赏一下。</p><pre><code class="line-numbers language-Java">class Dog &#123;&#125;</code></pre><p>哈哈，其实也没啥可以欣赏的。缺省意味着这个类可以被同一个包下的其他类进行访问；而 public 意味着这个类可以被所有包下的类进行访问。<br>假如硬要通过 private 和 protected 来修饰类的话，编译器会生气的，它不同意。<br><img src="https://www.qyihe.xyz/images/post/10.22.jpg"><br>private 可以用来修饰类的构造方法、字段和方法，只能被当前类进行访问。protected 也可以用来修饰类的构造方法、字段和方法，但它的权限范围更宽一些，可以被同一个包中的类进行访问，或者当前类的子类。<br>可以通过下面这张图来对比一下四个权限修饰符之间的差别：<br><img src="https://www.qyihe.xyz/images/post/10.23.jpg"></p><ul><li>同一个类中，不管是哪种权限修饰符，都可以访问；</li><li>同一个包下，private 修饰的无法访问；</li><li>子类可以访问 public 和 protected 修饰的；</li><li>public 修饰符面向世界，哈哈，可以被所有的地方访问到。<br><img src="https://www.qyihe.xyz/images/post/10.24.jpg"></li></ul><h1 id="八、Java-构造方法"><a href="#八、Java-构造方法" class="headerlink" title="八、Java 构造方法"></a>八、Java 构造方法</h1><p>假设现在有一个 Writer 类，它有两个字段，姓名和年纪：</p><pre><code class="line-numbers language-Java">public class Writer &#123;    private String name;    private int age;    @Override    public String toString() &#123;        return &quot;Writer&#123;&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p>重写了 toString() 方法，用于打印 Writer 类的详情。由于没有构造方法，意味着当我们创建 Writer 对象时，它的字段值并没有初始化：</p><pre><code class="line-numbers language-Java">Writer writer = new Writer();System.out.println(writer.toString());</code></pre><p>输出结果如下所示：</p><pre><code class="line-numbers language-Java">Writer&#123;name=&#39;null&#39;, age=0&#125;</code></pre><p>name 是字符串类型，所以默认值为 null，age 为 int 类型，所以默认值为 0。<br>让我们为 Writer 类主动加一个无参的构造方法：</p><pre><code class="line-numbers language-Java">public Writer() &#123;    this.name = &quot;&quot;;    this.age = 0;&#125;</code></pre><p>构造方法也是一个方法，只不过它没有返回值，默认返回创建对象的类型。需要注意的是，当前构造方法没有参数，它被称为无参构造方法。如果我们没有主动创建无参构造方法的话，编译器会隐式地自动添加一个无参的构造方法。这就是为什么，一开始虽然没有构造方法，却可以使用 new Writer() 创建对象的原因，只不过，所有的字段都被初始化成了默认值。<br>接下来，让我们添加一个有参的构造方法：</p><pre><code class="line-numbers language-Java">public Writer(String name, int age) &#123;    this.name = name;    this.age = age;&#125;</code></pre><p>现在，我们创建 Writer 对象的时候就可以通过对字段值初始化值了。</p><pre><code class="line-numbers language-Java">Writer writer1 = new Writer(&quot;沉默王二&quot;,18);System.out.println(writer1.toString());</code></pre><p>来看一下打印结果：</p><pre><code class="line-numbers language-Java">Writer&#123;name=&#39;沉默王二&#39;, age=18&#125;</code></pre><p>可以根据字段的数量添加不同参数数量的构造方法，比如说，我们可以单独为 name 字段添加一个构造方法：</p><pre><code class="line-numbers language-Java">public Writer(String name) &#123;    this.name = name;&#125;</code></pre><p>为了能够兼顾 age 字段，我们可以通过 this 关键字调用其他的构造方法：</p><pre><code class="line-numbers language-Java">public Writer(String name) &#123;    this(name,18);&#125;</code></pre><p>把作者的年龄都默认初始化为 18。如果需要使用父类的构造方法，还可以使用 super 关键字，手册后面有详细的介绍。</p><h1 id="九、Java-抽象类"><a href="#九、Java-抽象类" class="headerlink" title="九、Java 抽象类"></a>九、Java 抽象类</h1><p>当我们要完成的任务是确定的，但具体的方式需要随后开个会投票的话，Java 的抽象类就派上用场了。这句话怎么理解呢？搬个小板凳坐好，听我来给你讲讲。<br><img src="https://www.qyihe.xyz/images/post/10.25.jpg"></p><h2 id="01、抽象类的-5-个关键点"><a href="#01、抽象类的-5-个关键点" class="headerlink" title="01、抽象类的 5 个关键点"></a>01、抽象类的 5 个关键点</h2><p>（1）定义抽象类的时候需要用到关键字 abstract，放在 class 关键字前。</p><pre><code class="line-numbers language-Java">public abstract class AbstractPlayer &#123;&#125;</code></pre><p>关于抽象类的命名，阿里出品的 Java 开发手册上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，记住了哦。<br>（2）抽象类不能被实例化，但可以有子类。<br>尝试通过 new 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。<br><img src="https://www.qyihe.xyz/images/post/10.26.jpg"><br>通过 extends 关键字可以继承抽象类，继承后，BasketballPlayer 类就是 AbstractPlayer 的子类。</p><pre><code class="line-numbers language-Java">public class BasketballPlayer extends AbstractPlayer &#123;&#125;</code></pre><p>（3）如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。<br>当在一个普通类（没有使用 abstract 关键字修饰）中定义了抽象方法，编译器就会有两处错误提示。<br>第一处在类级别上，提醒你“这个类必须通过 abstract 关键字定义”，or 的那个信息没必要，见下图。<br><img src="https://www.qyihe.xyz/images/post/10.27.jpg"><br>第二处在方法级别上，提醒你“抽象方法所在的类不是抽象的”，见下图。<br><img src="https://www.qyihe.xyz/images/post/10.28.jpg"><br>（4）抽象类可以同时声明抽象方法和具体方法，也可以什么方法都没有，但没必要。就像下面这样：</p><pre><code class="line-numbers language-Java">public abstract class AbstractPlayer &#123;    abstract void play();        public void sleep() &#123;        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);    &#125;&#125;</code></pre><p>（5）抽象类派生的子类必须实现父类中定义的抽象方法。比如说，抽象类中定义了 play() 方法，子类中就必须实现。</p><pre><code class="line-numbers language-Java">public class BasketballPlayer extends AbstractPlayer &#123;    @Override    void play() &#123;        System.out.println(&quot;我是张伯伦，篮球场上得过 100 分&quot;);    &#125;&#125;</code></pre><p>如果没有实现的话，编译器会提醒你“子类必须实现抽象方法”，见下图。<br><img src="https://www.qyihe.xyz/images/post/10.29.jpg"></p><h2 id="02、什么时候用抽象类"><a href="#02、什么时候用抽象类" class="headerlink" title="02、什么时候用抽象类"></a>02、什么时候用抽象类</h2><p>与抽象类息息相关的还有一个概念，就是接口，我们留到下一篇文章中详细说，因为要说的知识点还是蛮多的。你现在只需要有这样一个概念就好，接口是对行为的抽象，抽象类是对整个类（包含成员变量和行为）进行抽象。<br>（是不是有点明白又有点不明白，别着急，翘首以盼地等下一篇文章出炉吧）<br>除了接口之外，还有一个概念就是具体的类，就是不通过 abstract 修饰的普通类，见下面这段代码中的定义。</p><pre><code class="line-numbers language-Java">public class BasketballPlayer &#123;   public void play() &#123;        System.out.println(&quot;我是詹姆斯，现役第一人&quot;);    &#125;&#125;</code></pre><p>有接口，有具体类，那什么时候该使用抽象类呢？<br>（1）我们希望一些通用的功能被多个子类复用。比如说，AbstractPlayer 抽象类中有一个普通的方法 sleep()，表明所有运动员都需要休息，那么这个方法就可以被子类复用。</p><pre><code class="line-numbers language-Java">public abstract class AbstractPlayer &#123;    public void sleep() &#123;        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);    &#125;&#125;</code></pre><p>虽然 AbstractPlayer 类可以不是抽象类——把 abstract 修饰符去掉也能满足这种场景。但 AbstractPlayer 类可能还会有一个或者多个抽象方法。<br>BasketballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。</p><pre><code class="line-numbers language-Java">public class BasketballPlayer extends AbstractPlayer &#123;&#125;</code></pre><p>BasketballPlayer 对象可以直接调用 sleep() 方法：</p><pre><code class="line-numbers language-Java">BasketballPlayer basketballPlayer = new BasketballPlayer();basketballPlayer.sleep();</code></pre><p>FootballPlayer 继承了 AbstractPlayer 类，也就拥有了 sleep() 方法。</p><pre><code class="line-numbers language-Java">public class FootballPlayer extends AbstractPlayer &#123;&#125;</code></pre><p>FootballPlayer 对象也可以直接调用 sleep() 方法：</p><pre><code class="line-numbers language-Java">FootballPlayer footballPlayer = new FootballPlayer();footballPlayer.sleep();</code></pre><p>（2）我们需要在抽象类中定义好 API，然后在子类中扩展实现。比如说，AbstractPlayer  抽象类中有一个抽象方法 play()，定义所有运动员都可以从事某项运动，但需要对应子类去扩展实现。</p><pre><code class="line-numbers language-Java">public abstract class AbstractPlayer &#123;    abstract void play();&#125;</code></pre><p>BasketballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</p><pre><code class="line-numbers language-Java">public class BasketballPlayer extends AbstractPlayer &#123;    @Override    void play() &#123;        System.out.println(&quot;我是张伯伦，我篮球场上得过 100 分，&quot;);    &#125;&#125;```FootballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。```Javapublic class FootballPlayer extends AbstractPlayer &#123;    @Override    void play() &#123;        System.out.println(&quot;我是C罗，我能接住任意高度的头球&quot;);    &#125;&#125;</code></pre><p>（3）如果父类与子类之间的关系符合 is-a 的层次关系，就可以使用抽象类，比如说篮球运动员是运动员，足球运动员是运动员。</p><h2 id="03、具体示例"><a href="#03、具体示例" class="headerlink" title="03、具体示例"></a>03、具体示例</h2><p>为了进一步展示抽象类的特性，我们再来看一个具体的示例。假设现在有一个文件，里面的内容非常简单——“Hello World”，现在需要有一个读取器将内容读取出来，最好能按照大写的方式，或者小写的方式。<br>这时候，最好定义一个抽象类，比如说 BaseFileReader：</p><pre><code class="line-numbers language-Java">public abstract class BaseFileReader &#123;    protected Path filePath;    protected BaseFileReader(Path filePath) &#123;        this.filePath = filePath;    &#125;    public List&lt;String&gt; readFile() throws IOException &#123;        return Files.lines(filePath)                .map(this::mapFileLine).collect(Collectors.toList());    &#125;    protected abstract String mapFileLine(String line);&#125;</code></pre><p>filePath 为文件路径，使用 protected 修饰，表明该成员变量可以在需要时被子类访问。<br>readFile() 方法用来读取文件，方法体里面调用了抽象方法 mapFileLine()——需要子类扩展实现大小写的方式。<br>你看，BaseFileReader 设计的就非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了。<br>小写的方式：</p><pre><code class="line-numbers language-Java">public class LowercaseFileReader extends BaseFileReader &#123;    protected LowercaseFileReader(Path filePath) &#123;        super(filePath);    &#125;    @Override    protected String mapFileLine(String line) &#123;        return line.toLowerCase();    &#125;&#125;</code></pre><p>大写的方式：</p><pre><code class="line-numbers language-Java">public class UppercaseFileReader extends BaseFileReader &#123;    protected UppercaseFileReader(Path filePath) &#123;        super(filePath);    &#125;    @Override    protected String mapFileLine(String line) &#123;        return line.toUpperCase();    &#125;&#125;</code></pre><p>你看，从文件里面一行一行读取内容的代码被子类复用了——抽象类 BaseFileReader 类中定义的普通方法 readFile()。与此同时，子类只需要专注于自己该做的工作，LowercaseFileReader 以小写的方式读取文件内容，UppercaseFileReader 以大写的方式读取文件内容。<br>接下来，我们来新建一个测试类 FileReaderTest：</p><pre><code class="line-numbers language-Java">public class FileReaderTest &#123;    public static void main(String[] args) throws URISyntaxException, IOException &#123;        URL location = FileReaderTest.class.getClassLoader().getResource(&quot;helloworld.txt&quot;);        Path path = Paths.get(location.toURI());        BaseFileReader lowercaseFileReader = new LowercaseFileReader(path);        BaseFileReader uppercaseFileReader = new UppercaseFileReader(path);        System.out.println(lowercaseFileReader.readFile());        System.out.println(uppercaseFileReader.readFile());    &#125;&#125;</code></pre><p>项目的 resource 目录下有一个文本文件，名字叫 helloworld.txt。<br><img src="https://www.qyihe.xyz/images/post/10.30.jpg"><br>可以通过 ClassLoader.getResource() 的方式获取到该文件的 URI 路径，然后就可以使用 LowercaseFileReader 和 UppercaseFileReader 两种方式读取到文本内容了。<br>输出结果如下所示：</p><pre><code class="line-numbers language-Java">[hello world][HELLO WORLD]</code></pre><h1 id="十、Java-接口"><a href="#十、Java-接口" class="headerlink" title="十、Java 接口"></a>十、Java 接口</h1><p>对于面向对象编程来说，抽象是一个极具魅力的特征。如果一个程序员的抽象思维很差，那他在编程中就会遇到很多困难，无法把业务变成具体的代码。在 Java 中，可以通过两种形式来达到抽象的目的，一种是抽象类，另外一种就是接口。<br>如果你现在就想知道抽象类与接口之间的区别，我可以提前给你说一个：</p><ul><li>一个类只能继承一个抽象类，但却可以实现多个接口。</li></ul><p>当然了，在没有搞清楚接口到底是什么，它可以做什么之前，这个区别理解起来会有点难度。</p><h2 id="01、接口是什么"><a href="#01、接口是什么" class="headerlink" title="01、接口是什么"></a>01、接口是什么</h2><p>接口是通过 interface 关键字定义的，它可以包含一些常量和方法，来看下面这个示例。</p><pre><code class="line-numbers language-Java">public interface Electronic &#123;    // 常量    String LED = &quot;LED&quot;;    // 抽象方法    int getElectricityUse();    // 静态方法    static boolean isEnergyEfficient(String electtronicType) &#123;        return electtronicType.equals(LED);    &#125;    // 默认方法    default void printDescription() &#123;        System.out.println(&quot;电子&quot;);    &#125;&#125;</code></pre><p>（1）接口中定义的变量会在编译的时候自动加上 public static final 修饰符，也就是说 LED 变量其实是一个常量。<br>Java 官方文档上有这样的声明：</p><pre><code class="line-numbers language-Java">Every field declaration in the body of an interface is implicitly public, static, and final.</code></pre><p>换句话说，接口可以用来作为常量类使用，还能省略掉 public static final，看似不错的一种选择，对吧？<br>不过，这种选择并不可取。因为接口的本意是对方法进行抽象，而常量接口会对子类中的变量造成命名空间上的“污染”。<br>（2）没有使用 private、default 或者 static 关键字修饰的方法是隐式抽象的，在编译的时候会自动加上 public abstract 修饰符。也就是说 getElectricityUse() 其实是一个抽象方法，没有方法体——这是定义接口的本意。<br>（3）从 Java 8 开始，接口中允许有静态方法，比如说 isEnergyEfficient() 方法。<br>静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口的名字来调用，比如说 Electronic.isEnergyEfficient(“LED”)。<br>接口中定义静态方法的目的是为了提供一种简单的机制，使我们不必创建对象就能调用方法，从而提高接口的竞争力。<br>（4）接口中允许定义 default 方法也是从 Java 8 开始的，比如说 printDescription()，它始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现，也就是说，无法直接使用一个“;”号来结束默认方法——编译器会报错的。<br><img src="https://www.qyihe.xyz/images/post/10.31.jpg"><br>允许在接口中定义默认方法的理由是很充分的，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 default 方法的帮助下，我们就必须挨个对实现类进行修改。<br>来看一下 Electronic 接口反编译后的字节码吧，你会发现，接口中定义的所有变量或者方法，都会自动添加上 public 关键字——假如你想知道编译器在背后都默默做了哪些辅助，记住反编译字节码就对了。</p><pre><code class="line-numbers language-Java">public interface Electronic&#123;    public abstract int getElectricityUse();    public static boolean isEnergyEfficient(String electtronicType)    &#123;        return electtronicType.equals(&quot;LED&quot;);    &#125;    public void printDescription()    &#123;        System.out.println(&quot;\u7535\u5B50&quot;);    &#125;    public static final String LED = &quot;LED&quot;;&#125;</code></pre><p>有些读者可能会问，“二哥，为什么我反编译后的字节码和你的不一样，你用了什么反编译工具？”其实没有什么秘密，微信搜「沉默王二」回复关键字「JAD」就可以免费获取了，超级好用。</p><h2 id="02、定义接口的注意事项"><a href="#02、定义接口的注意事项" class="headerlink" title="02、定义接口的注意事项"></a>02、定义接口的注意事项</h2><p>由之前的例子我们就可以得出下面这些结论：</p><ul><li>接口中允许定义变量</li><li>接口中允许定义抽象方法</li><li>接口中允许定义静态方法（Java 8 之后）</li><li>接口中允许定义默认方法（Java 8 之后）</li></ul><p>除此之外，我们还应该知道：<br>（1）接口不允许直接实例化。<br><img src="https://www.qyihe.xyz/images/post/10.32.jpg"><br>需要定义一个类去实现接口，然后再实例化。</p><pre><code class="line-numbers language-Java">public class Computer implements Electronic &#123;    public static void main(String[] args) &#123;        new Computer();    &#125;    @Override    public int getElectricityUse() &#123;        return 0;    &#125;&#125;</code></pre><p>（2）接口可以是空的，既不定义变量，也不定义方法。</p><pre><code class="line-numbers language-Java">public interface Serializable &#123;&#125;</code></pre><p>Serializable 是最典型的一个空的接口，我之前分享过一篇文章《Java Serializable：明明就一个空的接口嘛》，感兴趣的读者可以去我的个人博客看一看，你就明白了空接口的意义。</p><pre><code class="line-numbers language-Java">www.itwanger.com/java/2019/1…</code></pre><p>（3）不要在定义接口的时候使用 final 关键字，否则会报编译错误，因为接口就是为了让子类实现的，而 final 阻止了这种行为。<br><img src="https://www.qyihe.xyz/images/post/10.33.jpg"><br>（4）接口的抽象方法不能是 private、protected 或者 final。<br><img src="https://www.qyihe.xyz/images/post/10.34.jpg"><br><img src="https://www.qyihe.xyz/images/post/10.35.jpg"><br><img src="https://www.qyihe.xyz/images/post/10.36.jpg"><br>（5）接口的变量是隐式 public static final，所以其值无法改变。</p><h2 id="03、接口可以做什么"><a href="#03、接口可以做什么" class="headerlink" title="03、接口可以做什么"></a>03、接口可以做什么</h2><p>（1）使某些实现类具有我们想要的功能，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了 Comparable 或者 Comparator 的类具有比较功能。<br>Cloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。实现了 Cloneable 接口的类可以使用 Object.clone() 方法，否则会抛出 CloneNotSupportedException。</p><pre><code class="line-numbers language-Java">public class CloneableTest implements Cloneable &#123;    @Override    protected Object clone() throws CloneNotSupportedException &#123;        return super.clone();    &#125;    public static void main(String[] args) throws CloneNotSupportedException &#123;        CloneableTest c1 = new CloneableTest();        CloneableTest c2 = (CloneableTest) c1.clone();    &#125;&#125;</code></pre><p>运行后没有报错。现在把 implements Cloneable 去掉。</p><pre><code class="line-numbers language-Java">public class CloneableTest &#123;    @Override    protected Object clone() throws CloneNotSupportedException &#123;        return super.clone();    &#125;    public static void main(String[] args) throws CloneNotSupportedException &#123;        CloneableTest c1 = new CloneableTest();        CloneableTest c2 = (CloneableTest) c1.clone();    &#125;&#125;</code></pre><p>运行后抛出 CloneNotSupportedException：</p><pre><code class="line-numbers language-Java">Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException: com.cmower.baeldung.interface1.CloneableTest    at java.base/java.lang.Object.clone(Native Method)    at com.cmower.baeldung.interface1.CloneableTest.clone(CloneableTest.java:6)    at com.cmower.baeldung.interface1.CloneableTest.main(CloneableTest.java:11)</code></pre><p>至于 Comparable 和 Comparator 的用法，感兴趣的读者可以参照我之前写的另外一篇文章《来吧，一文彻底搞懂Java中的Comparable和Comparator》。</p><pre><code class="line-numbers language-Java">www.itwanger.com/java/2020/0…</code></pre><p>（2）Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。<br>可能有些读者会问，“二哥，为什么 Java 只支持单一继承？”简单来解释一下。<br>如果有两个类共同继承（extends）一个有特定方法的父类，那么该方法会被两个子类重写。然后，如果你决定同时继承这两个子类，那么在你调用该重写方法时，编译器不能识别你要调用哪个子类的方法。这也正是著名的菱形问题，见下图。<br><img src="https://www.qyihe.xyz/images/post/10.37.jpg"><br>ClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重载的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。<br>接口没有这方面的困扰。来定义两个接口，Fly 会飞，Run 会跑。</p><pre><code class="line-numbers language-Java">public interface Fly &#123;    void fly();&#125;public interface Run &#123;    void run();&#125;</code></pre><p>然后让一个类同时实现这两个接口。</p><pre><code class="line-numbers language-Java">public class Pig implements Fly,Run&#123;    @Override    public void fly() &#123;        System.out.println(&quot;会飞的猪&quot;);    &#125;    @Override    public void run() &#123;        System.out.println(&quot;会跑的猪&quot;);    &#125;&#125;</code></pre><p>这就在某种形式上达到了多重继承的目的：现实世界里，猪的确只会跑，但在雷军的眼里，站在风口的猪就会飞，这就需要赋予这只猪更多的能力，通过抽象类是无法实现的，只能通过接口。<br>（3）实现多态。<br>什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。<br>多态可以通过继承（extends）的关系实现，也可以通过接口的形式实现。来看这样一个例子。<br>Shape 是表示一个形状。</p><pre><code class="line-numbers language-Java">public interface Shape &#123;    String name();&#125;</code></pre><p>圆是一个形状。</p><pre><code class="line-numbers language-Java">public class Circle implements Shape &#123;    @Override    public String name() &#123;        return &quot;圆&quot;;    &#125;&#125;</code></pre><p>正方形也是一个形状。</p><pre><code class="line-numbers language-Java">public class Square implements Shape &#123;    @Override    public String name() &#123;        return &quot;正方形&quot;;    &#125;&#125;</code></pre><p>然后来看测试类。</p><pre><code class="line-numbers language-Java">List&lt;Shape&gt; shapes = new ArrayList&lt;&gt;();Shape circleShape = new Circle();Shape squareShape = new Square();shapes.add(circleShape);shapes.add(squareShape);for (Shape shape : shapes) &#123;    System.out.println(shape.name());&#125;</code></pre><p>多态的存在 3 个前提：<br>1、要有继承关系，Circle 和 Square 都实现了 Shape 接口<br>2、子类要重写父类的方法，Circle 和 Square 都重写了 name() 方法<br>3、父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle 对象，后者指向的是 Square 对象。<br>然后，我们来看一下测试结果：</p><pre><code class="line-numbers language-Java">圆正方形</code></pre><p>也就意味着，尽管在 for 循环中，shape 的类型都为 Shape，但在调用 name() 方法的时候，它知道 Circle 对象应该调用 Circle 类的 name() 方法，Square 对象应该调用 Square 类的 name() 方法。</p><h2 id="04、接口与抽象类的区别"><a href="#04、接口与抽象类的区别" class="headerlink" title="04、接口与抽象类的区别"></a>04、接口与抽象类的区别</h2><p>好了，关于接口的一切，你应该都搞清楚了。现在回到读者春夏秋冬的那条留言，“兄弟，说说抽象类和接口之间的区别？”<br>（1）语法层面上</p><ul><li>接口中不能有 public 和 protected 修饰的方法，抽象类中可以有。</li><li>接口中的变量只能是隐式的常量，抽象类中可以有任意类型的变量。</li><li>一个类只能继承一个抽象类，但却可以实现多个接口。</li></ul><p>（2）设计层面上<br>抽象类是对类的一种抽象，继承抽象类的类和抽象类本身是一种 is-a 的关系。<br>接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，所有的类都可以实现 Serializable 接口，从而具有序列化的功能。<br>就这么多吧，能说道这份上，我相信面试官就不会为难你了。</p><h1 id="十一、Java-继承"><a href="#十一、Java-继承" class="headerlink" title="十一、Java 继承"></a>十一、Java 继承</h1><p>在 Java 中，一个类可以继承另外一个类或者实现多个接口，我想这一点，大部分的读者应该都知道了。还有一点，我不确定大家是否知道，就是一个接口也可以继承另外一个接口，就像下面这样：</p><pre><code class="line-numbers language-Java">public interface OneInterface extends Cloneable &#123;&#125;</code></pre><p>这样做有什么好处呢？我想有一部分读者应该已经猜出来了，就是实现了 OneInterface 接口的类，也可以使用 Object.clone() 方法了。</p><pre><code class="line-numbers language-Java">public class TestInterface implements OneInterface &#123;    public static void main(String[] args) throws CloneNotSupportedException &#123;        TestInterface c1 = new TestInterface();        TestInterface c2 = (TestInterface) c1.clone();    &#125;&#125;</code></pre><p>除此之外，我们还可以在 OneInterface 接口中定义其他一些抽象方法（比如说深拷贝），使该接口拥有 Cloneable 所不具有的功能。</p><pre><code class="line-numbers language-Java">public interface OneInterface extends Cloneable &#123;    void deepClone();&#125;</code></pre><p>看到了吧？这就是继承的好处：子接口拥有了父接口的方法，使得子接口具有了父接口相同的行为；同时，子接口还可以在此基础上自由发挥，添加属于自己的行为。<br>以上，把“接口”换成“类”，结论同样成立。让我们来定义一个普通的父类 Wanger：</p><pre><code class="line-numbers language-Java">public class Wanger &#123;    int age;    String name;    void write() &#123;        System.out.println(&quot;我写了本《基督山伯爵》&quot;);    &#125;&#125;</code></pre><p>然后，我们再来定义一个子类 Wangxiaoer，使用关键字 extends 来继承父类 Wanger：</p><pre><code class="line-numbers language-Java">public class Wangxiaoer extends Wanger&#123;    @Override    void write() &#123;        System.out.println(&quot;我写了本《茶花女》&quot;);    &#125;&#125;</code></pre><p>我们可以将通用的方法和成员变量放在父类中，达到代码复用的目的；然后将特殊的方法和成员变量放在子类中，除此之外，子类还可以覆盖父类的方法（比如write() 方法）。这样，子类也就焕发出了新的生命力。<br>Java 只支持单一继承，这一点，我在上一篇接口的文章中已经提到过了。如果一个类在定义的时候没有使用 extends 关键字，那么它隐式地继承了 java.lang.Object 类——在我看来，这恐怕就是 Java 号称万物皆对象的真正原因了。<br>那究竟子类继承了父类的什么呢？<br>子类可以继承父类的非 private 成员变量，为了验证这一点，我们来看下面这个示例。</p><pre><code class="line-numbers language-Java">public class Wanger &#123;    String defaultName;    private String privateName;    public String publicName;    protected String protectedName;&#125;</code></pre><p>父类 Wanger 定义了四种类型的成员变量，缺省的 defaultName、私有的 privateName、共有的 publicName、受保护的 protectedName。<br>在子类 Wangxiaoer 中定义一个测试方法 testVariable()：<br><img src="https://www.qyihe.xyz/images/post/10.38.jpg"><br>可以确认，除了私有的 privateName，其他三种类型的成员变量都可以继承到。<br>同理，子类可以继承父类的非 private 方法，为了验证这一点，我们来看下面这个示例。</p><pre><code class="line-numbers language-Java">public class Wanger &#123;    void write() &#123;    &#125;    private void privateWrite() &#123;    &#125;    public void publicWrite() &#123;    &#125;    protected void protectedWrite() &#123;    &#125;&#125;</code></pre><p>父类 Wanger 定义了四种类型的方法，缺省的 write、私有的 privateWrite()、共有的 publicWrite()、受保护的 protectedWrite()。<br>在子类 Wangxiaoer 中定义一个 main 方法，并使用 new 关键字新建一个子类对象：<br><img src="https://www.qyihe.xyz/images/post/10.39.jpg"><br>可以确认，除了私有的 privateWrite()，其他三种类型的方法都可以继承到。<br>不过，子类无法继承父类的构造方法。如果父类的构造方法是带有参数的，代码如下所示：</p><pre><code class="line-numbers language-Java">public class Wanger &#123;    int age;    String name;    public Wanger(int age, String name) &#123;        this.age = age;        this.name = name;    &#125;&#125;</code></pre><p>则必须在子类的构造器中显式地通过 super 关键字进行调用，否则编译器将提示以下错误：<br><img src="https://www.qyihe.xyz/images/post/10.40.jpg"><br>修复后的代码如下所示：</p><pre><code class="line-numbers language-Java">public class Wangxiaoer extends Wanger&#123;    public Wangxiaoer(int age, String name) &#123;        super(age, name);    &#125;&#125;</code></pre><p>is-a 是继承的一个明显特征，就是说子类的对象引用类型可以是一个父类类型。</p><pre><code>public class Wangxiaoer extends Wanger&#123;    public static void main(String[] args) &#123;        Wanger wangxiaoer = new Wangxiaoer();    &#125;&#125;</code></pre><p>同理，子接口的实现类的对象引用类型也可以是一个父接口类型。</p><pre><code class="line-numbers language-Java">public interface OneInterface extends Cloneable &#123;&#125;public class TestInterface implements OneInterface &#123;    public static void main(String[] args) &#123;        Cloneable c1 = new TestInterface();    &#125;&#125;</code></pre><p>尽管一个类只能继承一个类，但一个类却可以实现多个接口，这一点，我在上一篇文章也提到过了。另外，还有一点我也提到了，就是 Java 8 之后，接口中可以定义 default 方法，这很方便，但也带来了新的问题：</p><blockquote><p>如果一个类实现了多个接口，而这些接口中定义了相同签名的 default 方法，那么这个类就要重写该方法，否则编译无法通过。</p></blockquote><p>FlyInterface 是一个会飞的接口，里面有一个签名为 sleep() 的默认方法：</p><pre><code class="line-numbers language-Java">public interface FlyInterface &#123;    void fly();    default void sleep() &#123;        System.out.println(&quot;睡着飞&quot;);    &#125;&#125;</code></pre><p>RunInterface 是一个会跑的接口，里面也有一个签名为 sleep() 的默认方法：</p><pre><code class="line-numbers language-Java">public interface RunInterface &#123;    void run();    default void sleep() &#123;        System.out.println(&quot;睡着跑&quot;);    &#125;&#125;</code></pre><p>Pig 类实现了 FlyInterface 和 RunInterface 两个接口，但这时候编译出错了。<br><img src="https://www.qyihe.xyz/images/post/10.41.jpg"><br>原本，default 方法就是为实现该接口而不覆盖该方法的类提供默认实现的，现在，相同方法签名的 sleep() 方法把编译器搞懵逼了，只能重写了。</p><pre><code class="line-numbers language-Java">public class Pig implements FlyInterface, RunInterface &#123;    @Override    public void fly() &#123;        System.out.println(&quot;会飞的猪&quot;);    &#125;    @Override    public void sleep() &#123;        System.out.println(&quot;只能重写了&quot;);    &#125;    @Override    public void run() &#123;        System.out.println(&quot;会跑的猪&quot;);    &#125;&#125;</code></pre><p>类虽然不能继承多个类，但接口却可以继承多个接口，这一点，我不知道有没有触及到一些读者的知识盲区。</p><pre><code class="line-numbers language-Java">public interface WalkInterface extends FlyInterface,RunInterface&#123;    void walk();&#125;</code></pre><h1 id="十二、this-关键字"><a href="#十二、this-关键字" class="headerlink" title="十二、this 关键字"></a>十二、this 关键字</h1><p>在 Java 中，this 关键字指的是当前对象（它的方法正在被调用）的引用，能理解吧，各位亲？不理解的话，我们继续往下看。<br>看完再不明白，你过来捶爆我，我保证不还手，只要不打脸。</p><h2 id="01、消除字段歧义"><a href="#01、消除字段歧义" class="headerlink" title="01、消除字段歧义"></a>01、消除字段歧义</h2><p>我敢赌一毛钱，所有的读者，不管男女老少，应该都知道这种用法，毕竟写构造方法的时候经常用啊。谁要不知道，过来，我给你发一毛钱红包，只要你脸皮够厚。</p><pre><code class="line-numbers language-Java">public class Writer &#123;    private int age;    private String name;    public Writer(int age, String name) &#123;        this.age = age;        this.name = name;    &#125;&#125;</code></pre><p>Writer 类有两个成员变量，分别是 age 和 name，在使用有参构造函数的时候，如果参数名和成员变量的名字相同，就需要使用 this 关键字消除歧义：this.age 是指成员变量，age 是指构造方法的参数。</p><h2 id="02、引用类的其他构造方法"><a href="#02、引用类的其他构造方法" class="headerlink" title="02、引用类的其他构造方法"></a>02、引用类的其他构造方法</h2><p>当一个类的构造方法有多个，并且它们之间有交集的话，就可以使用 this 关键字来调用不同的构造方法，从而减少代码量。<br>比如说，在无参构造方法中调用有参构造方法：</p><pre><code class="line-numbers language-Java">public class Writer &#123;    private int age;    private String name;    public Writer(int age, String name) &#123;        this.age = age;        this.name = name;    &#125;    public Writer() &#123;        this(18, &quot;沉默王二&quot;);    &#125;&#125;</code></pre><p>也可以在有参构造方法中调用无参构造方法：</p><pre><code class="line-numbers language-Java">public class Writer &#123;    private int age;    private String name;    public Writer(int age, String name) &#123;        this();        this.age = age;        this.name = name;    &#125;    public Writer() &#123;    &#125;&#125;</code></pre><p>需要注意的是，this() 必须是构造方法中的第一条语句，否则就会报错。<br><img src="https://www.qyihe.xyz/images/post/10.42.jpg"></p><h2 id="03、作为参数传递"><a href="#03、作为参数传递" class="headerlink" title="03、作为参数传递"></a>03、作为参数传递</h2><p>在下例中，有一个无参的构造方法，里面调用了 print() 方法，参数只有一个 this 关键字。</p><pre><code class="line-numbers language-Java">public class ThisTest &#123;    public ThisTest() &#123;        print(this);    &#125;    private void print(ThisTest thisTest) &#123;        System.out.println(&quot;print &quot; +thisTest);    &#125;    public static void main(String[] args) &#123;        ThisTest test = new ThisTest();        System.out.println(&quot;main &quot; + test);    &#125;&#125;</code></pre><p>来打印看一下结果：</p><pre><code class="line-numbers language-Java">print com.cmower.baeldung.this1.ThisTest@573fd745main com.cmower.baeldung.this1.ThisTest@573fd745</code></pre><p>从结果中可以看得出来，this 就是我们在 main() 方法中使用 new 关键字创建的 ThisTest 对象。</p><h2 id="04、链式调用"><a href="#04、链式调用" class="headerlink" title="04、链式调用"></a>04、链式调用</h2><p>学过 JavaScript，或者 jQuery 的读者可能对链式调用比较熟悉，类似于 a.b().c().d()，仿佛能无穷无尽调用下去。<br>在 Java 中，对应的专有名词叫 Builder 模式，来看一个示例。</p><pre><code class="line-numbers language-Java">public class Writer &#123;    private int age;    private String name;    private String bookName;        public Writer(WriterBuilder builder) &#123;        this.age = builder.age;        this.name = builder.name;        this.bookName = builder.bookName;    &#125;    public static class WriterBuilder &#123;        public String bookName;        private int age;        private String name;        public WriterBuilder(int age, String name) &#123;            this.age = age;            this.name = name;        &#125;        public WriterBuilder writeBook(String bookName) &#123;            this.bookName = bookName;            return this;        &#125;        public Writer build() &#123;            return new Writer(this);        &#125;    &#125;&#125;</code></pre><p>Writer 类有三个成员变量，分别是 age、name 和 bookName，还有它们仨对应的一个构造方法，参数是一个内部静态类 WriterBuilder。<br>内部类 WriterBuilder 也有三个成员变量，和 Writer 类一致，不同的是，WriterBuilder 类的构造方法里面只有 age 和 name 赋值了，另外一个成员变量 bookName 通过单独的方法 writeBook() 来赋值，注意，该方法的返回类型是 WriterBuilder，最后使用 return 返回了 this 关键字。<br>最后的 build() 方法用来创建一个 Writer 对象，参数为 this 关键字，也就是当前的 WriterBuilder 对象。<br>这时候，创建 Writer 对象就可以通过链式调用的方式。</p><pre><code class="line-numbers language-Java">Writer writer = new Writer.WriterBuilder(18,&quot;沉默王二&quot;)                .writeBook(&quot;《Web全栈开发进阶之路》&quot;)                .build();</code></pre><h2 id="05、在内部类中访问外部类对象"><a href="#05、在内部类中访问外部类对象" class="headerlink" title="05、在内部类中访问外部类对象"></a>05、在内部类中访问外部类对象</h2><p>说实话，自从 Java 8 的函数式编程出现后，就很少用到 this 在内部类中访问外部类对象了。来看一个示例：</p><pre><code class="line-numbers language-Java">public class ThisInnerTest &#123;    private String name;        class InnerClass &#123;        public InnerClass() &#123;            ThisInnerTest thisInnerTest = ThisInnerTest.this;            String outerName = thisInnerTest.name;        &#125;    &#125;&#125;</code></pre><p>在内部类 InnerClass 的构造方法中，通过外部类.this 可以获取到外部类对象，然后就可以使用外部类的成员变量了，比如说 name。</p><h1 id="十三、super-关键字"><a href="#十三、super-关键字" class="headerlink" title="十三、super 关键字"></a>十三、super 关键字</h1><p>简而言之，super 关键字就是用来访问父类的。<br>先来看父类：</p><pre><code class="line-numbers language-Java">public class SuperBase &#123;    String message = &quot;父类&quot;;    public SuperBase(String message) &#123;        this.message = message;    &#125;    public SuperBase() &#123;    &#125;    public void printMessage() &#123;        System.out.println(message);    &#125;&#125;</code></pre><p>再来看子类：</p><pre><code class="line-numbers language-Java">public class SuperSub extends SuperBase &#123;    String message = &quot;子类&quot;;    public SuperSub(String message) &#123;        super(message);    &#125;    public SuperSub() &#123;        super.printMessage();        printMessage();    &#125;    public void getParentMessage() &#123;        System.out.println(super.message);    &#125;    public void printMessage() &#123;        System.out.println(message);    &#125;&#125;</code></pre><p>（1）super 关键字可用于访问父类的构造方法<br>你看，子类可以通过 super(message) 来调用父类的构造方法。现在来新建一个 SuperSub 对象，看看输出结果是什么：</p><pre><code class="line-numbers language-Java">SuperSub superSub = new SuperSub(&quot;子类的message&quot;);</code></pre><p>new 关键字在调用构造方法创建子类对象的时候，会通过 super 关键字初始化父类的 message，所以此此时父类的 message 会输出“子类的message”。<br>（2）super 关键字可以访问父类的变量<br>上述例子中的 SuperSub 类中就有，getParentMessage() 通过 super.message 方法父类的同名成员变量 message。<br>（3）当方法发生重写时，super 关键字可以访问父类的同名方法<br>上述例子中的 SuperSub 类中就有，无参的构造方法 SuperSub() 中就使用 super.printMessage() 调用了父类的同名方法。</p><h1 id="十四、重写和重载"><a href="#十四、重写和重载" class="headerlink" title="十四、重写和重载"></a>十四、重写和重载</h1><p>先来看一段重写的代码吧。</p><pre><code class="line-numbers language-Java">class LaoWang&#123;    public void write() &#123;        System.out.println(&quot;老王写了一本《基督山伯爵》&quot;);    &#125;&#125;public class XiaoWang extends LaoWang &#123;    @Override    public void write() &#123;        System.out.println(&quot;小王写了一本《茶花女》&quot;);    &#125;&#125;</code></pre><p>重写的两个方法名相同，方法参数的个数也相同；不过一个方法在父类中，另外一个在子类中。就好像父类 LaoWang 有一个 write() 方法（无参），方法体是写一本《基督山伯爵》；子类 XiaoWang 重写了父类的 write() 方法（无参），但方法体是写一本《茶花女》。<br>来写一段测试代码。</p><pre><code class="line-numbers language-Java">public class OverridingTest &#123;    public static void main(String[] args) &#123;        LaoWang wang = new XiaoWang();        wang.write();    &#125;&#125;</code></pre><p>大家猜结果是什么？</p><pre><code class="line-numbers language-Java">小王写了一本《茶花女》</code></pre><p>在上面的代码中，们声明了一个类型为 LaoWang 的变量 wang。在编译期间，编译器会检查 LaoWang 类是否包含了 write() 方法，发现 LaoWang 类有，于是编译通过。在运行期间，new 了一个 XiaoWang 对象，并将其赋值给 wang，此时 Java 虚拟机知道 wang 引用的是 XiaoWang 对象，所以调用的是子类 XiaoWang 中的 write() 方法而不是父类 LaoWang  中的 write() 方法，因此输出结果为“小王写了一本《茶花女》”。<br>再来看一段重载的代码吧。</p><pre><code class="line-numbers language-Java">class LaoWang&#123;    public void read() &#123;        System.out.println(&quot;老王读了一本《Web全栈开发进阶之路》&quot;);    &#125;        public void read(String bookname) &#123;        System.out.println(&quot;老王读了一本《&quot; + bookname + &quot;》&quot;);    &#125;&#125;</code></pre><p>重载的两个方法名相同，但方法参数的个数不同，另外也不涉及到继承，两个方法在同一个类中。就好像类 LaoWang 有两个方法，名字都是 read()，但一个有参数（书名），另外一个没有（只能读写死的一本书）。<br>来写一段测试代码。</p><pre><code class="line-numbers language-Java">public class OverloadingTest &#123;    public static void main(String[] args) &#123;        LaoWang wang = new LaoWang();        wang.read();        wang.read(&quot;金瓶梅&quot;);    &#125;&#125;</code></pre><p>这结果就不用猜了。变量 wang 的类型为 LaoWang，wang.read() 调用的是无参的 read() 方法，因此先输出“老王读了一本《Web全栈开发进阶之路》”；wang.read(“金瓶梅”) 调用的是有参的 read(bookname) 方法，因此后输出“老王读了一本《金瓶梅》”。在编译期间，编译器就知道这两个 read() 方法时不同的，因为它们的方法签名（&#x3D;方法名称+方法参数）不同。<br>简单的来总结一下：<br>（1）编译器无法决定调用哪个重写的方法，因为只从变量的类型上是无法做出判断的，要在运行时才能决定；但编译器可以明确地知道该调用哪个重载的方法，因为引用类型是确定的，参数个数决定了该调用哪个方法。<br>（2）多态针对的是重写，而不是重载。<br><img src="https://www.qyihe.xyz/images/post/10.43.jpg"><br>哎，后悔啊，早年我要是能把这道面试题吃透的话，也不用被老马刁难了。吟一首诗感慨一下人生吧。</p><blockquote><p>青青园中葵，朝露待日晞。<br>阳春布德泽，万物生光辉。<br>常恐秋节至，焜黄华叶衰。<br>百川东到海，何时复西归?<br>少壮不努力，老大徒伤悲</p></blockquote><p>另外，我想要告诉大家的是，重写（Override）和重载（Overload）是 Java 中两个非常重要的概念，新手经常会被它们俩迷惑，因为它们俩的英文名字太像了，中文翻译也只差一个字。难，太难了。<br><img src="https://www.qyihe.xyz/images/post/10.44.jpg"></p><h1 id="十五、static-关键字"><a href="#十五、static-关键字" class="headerlink" title="十五、static 关键字"></a>十五、static 关键字</h1><p>先来个提纲挈领（唉呀妈呀，成语区博主上线了）吧：</p><blockquote><p>static 关键字可用于变量、方法、代码块和内部类，表示某个特定的成员只属于某个类本身，而不是该类的某个对象。</p></blockquote><h2 id="01、静态变量"><a href="#01、静态变量" class="headerlink" title="01、静态变量"></a>01、静态变量</h2><p>静态变量也叫类变量，它属于一个类，而不是这个类的对象。</p><pre><code class="line-numbers language-Java">public class Writer &#123;    private String name;    private int age;    public static int countOfWriters;    public Writer(String name, int age) &#123;        this.name = name;        this.age = age;        countOfWriters++;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;</code></pre><p>其中，countOfWriters 被称为静态变量，它有别于 name 和 age 这两个成员变量，因为它前面多了一个修饰符 static。<br>这意味着无论这个类被初始化多少次，静态变量的值都会在所有类的对象中共享。</p><pre><code class="line-numbers language-Java">Writer w1 = new Writer(&quot;沉默王二&quot;,18);Writer w2 = new Writer(&quot;沉默王三&quot;,16);System.out.println(Writer.countOfWriters);</code></pre><p>按照上面的逻辑，你应该能推理得出，countOfWriters 的值此时应该为 2 而不是 1。从内存的角度来看，静态变量将会存储在 Java 虚拟机中一个名叫“Metaspace”（元空间，Java 8 之后）的特定池中。<br>静态变量和成员变量有着很大的不同，成员变量的值属于某个对象，不同的对象之间，值是不共享的；但静态变量不是的，它可以用来统计对象的数量，因为它是共享的。就像上面例子中的 countOfWriters，创建一个对象的时候，它的值为 1，创建两个对象的时候，它的值就为 2。<br>简单小结一下：<br>（1）由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问；<br><img src="https://www.qyihe.xyz/images/post/10.45.jpg"><br>（2）不需要初始化类就可以访问静态变量。</p><pre><code class="line-numbers language-Java">public class WriterDemo &#123;    public static void main(String[] args) &#123;        System.out.println(Writer.countOfWriters); // 输出 0    &#125;&#125;</code></pre><h2 id="02、静态方法"><a href="#02、静态方法" class="headerlink" title="02、静态方法"></a>02、静态方法</h2><p>静态方法也叫类方法，它和静态变量类似，属于一个类，而不是这个类的对象。</p><pre><code class="line-numbers language-Java">public static void setCountOfWriters(int countOfWriters) &#123;    Writer.countOfWriters = countOfWriters;&#125;</code></pre><p>setCountOfWriters() 就是一个静态方法，它由 static 关键字修饰。<br>如果你用过 java.lang.Math 类或者 Apache 的一些工具类（比如说 StringUtils）的话，对静态方法一定不会感动陌生。<br><img src="https://www.qyihe.xyz/images/post/10.46.jpg"><br>Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。<br><img src="https://www.qyihe.xyz/images/post/10.47.jpg"><br>简单小结一下：<br>（1）Java 中的静态方法在编译时解析，因为静态方法不能被重写（方法重写发生在运行时阶段，为了多态）。<br>（2）抽象方法不能是静态的。<br><img src="https://www.qyihe.xyz/images/post/10.48.jpg"><br>（3）静态方法不能使用 this 和 super 关键字。<br>（4）成员方法可以直接访问其他成员方法和成员变量。<br>（5）成员方法也可以直接方法静态方法和静态变量。<br>（6）静态方法可以访问所有其他静态方法和静态变量。<br>（7）静态方法无法直接访问成员方法和成员变量。<br><img src="https://www.qyihe.xyz/images/post/10.49.jpg"></p><h2 id="03、静态代码块"><a href="#03、静态代码块" class="headerlink" title="03、静态代码块"></a>03、静态代码块</h2><p>静态代码块可以用来初始化静态变量，尽管静态方法也可以在声明的时候直接初始化，但有些时候，我们需要多行代码来完成初始化。</p><pre><code class="line-numbers language-Java">public class StaticBlockDemo &#123;    public static List&lt;String&gt; writes = new ArrayList&lt;&gt;();    static &#123;        writes.add(&quot;沉默王二&quot;);        writes.add(&quot;沉默王三&quot;);        writes.add(&quot;沉默王四&quot;);        System.out.println(&quot;第一块&quot;);    &#125;    static &#123;        writes.add(&quot;沉默王五&quot;);        writes.add(&quot;沉默王六&quot;);        System.out.println(&quot;第二块&quot;);    &#125;&#125;</code></pre><p>writes 是一个静态的 ArrayList，所以不太可能在声明的时候完成初始化，因此需要在静态代码块中完成初始化。<br>简单小结一下：<br>（1）一个类可以有多个静态代码块。<br>（2）静态代码块的解析和执行顺序和它在类中的位置保持一致。为了验证这个结论，可以在 StaticBlockDemo 类中加入空的 main 方法，执行完的结果如下所示：</p><pre><code class="line-numbers language-Java">第一块第二块</code></pre><h2 id="04、静态内部类"><a href="#04、静态内部类" class="headerlink" title="04、静态内部类"></a>04、静态内部类</h2><p>Java 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些变量，使代码更具有条理性和可读性。<br>常见的内部类有四种，成员内部类、局部内部类、匿名内部类和静态内部类，限于篇幅原因，前三种不在我们本次文章的讨论范围，以后有机会再细说。</p><pre><code class="line-numbers language-Java">public class Singleton &#123;    private Singleton() &#123;&#125;    private static class SingletonHolder &#123;        public static final Singleton instance = new Singleton();    &#125;    public static Singleton getInstance() &#123;        return SingletonHolder.instance;    &#125;&#125;</code></pre><p>以上这段代码是不是特别熟悉，对，这就是创建单例的一种方式，第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 getInstance() 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全也能保证 Singleton 类的唯一性。不过，创建单例更优雅的一种方式是使用枚举。<br>简单小结一下：<br>（1）静态内部类不能访问外部类的所有成员变量。<br>（2）静态内部类可以访问外部类的所有静态变量，包括私有静态变量。<br>（3）外部类不能声明为 static。<br><img src="https://www.qyihe.xyz/images/post/10.50.jpg"></p><h1 id="十六、Java-枚举"><a href="#十六、Java-枚举" class="headerlink" title="十六、Java 枚举"></a>十六、Java 枚举</h1><p>开门见山地说吧，enum（枚举）是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，默认继承自 java.lang.Enum。<br>为了证明这一点，我们来新建一个枚举 PlayerType：</p><pre><code class="line-numbers language-Java">public enum PlayerType &#123;    TENNIS,    FOOTBALL,    BASKETBALL&#125;</code></pre><p>两个关键字带一个类名，还有大括号，以及三个大写的单词，但没看到继承 Enum 类啊？别着急，心急吃不了热豆腐啊。使用 JAD 查看一下反编译后的字节码，就一清二楚了。</p><pre><code class="line-numbers language-Java">public final class PlayerType extends Enum&#123;    public static PlayerType[] values()    &#123;        return (PlayerType[])$VALUES.clone();    &#125;    public static PlayerType valueOf(String name)    &#123;        return (PlayerType)Enum.valueOf(com/cmower/baeldung/enum1/PlayerType, name);    &#125;    private PlayerType(String s, int i)    &#123;        super(s, i);    &#125;    public static final PlayerType TENNIS;    public static final PlayerType FOOTBALL;    public static final PlayerType BASKETBALL;    private static final PlayerType $VALUES[];    static     &#123;        TENNIS = new PlayerType(&quot;TENNIS&quot;, 0);        FOOTBALL = new PlayerType(&quot;FOOTBALL&quot;, 1);        BASKETBALL = new PlayerType(&quot;BASKETBALL&quot;, 2);        $VALUES = (new PlayerType[] &#123;            TENNIS, FOOTBALL, BASKETBALL        &#125;);    &#125;&#125;</code></pre><p>看到没？PlayerType 类是 final 的，并且继承自 Enum 类。这些工作我们程序员没做，编译器帮我们悄悄地做了。此外，它还附带几个有用静态方法，比如说 values() 和  valueOf(String name)。</p><h2 id="01、内部枚举"><a href="#01、内部枚举" class="headerlink" title="01、内部枚举"></a>01、内部枚举</h2><p>好的，小伙伴们应该已经清楚枚举长什么样子了吧？既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。</p><pre><code class="line-numbers language-Java">public class Player &#123;    private PlayerType type;    public enum PlayerType &#123;        TENNIS,        FOOTBALL,        BASKETBALL    &#125;        public boolean isBasketballPlayer() &#123;      return getType() == PlayerType.BASKETBALL;    &#125;    public PlayerType getType() &#123;        return type;    &#125;    public void setType(PlayerType type) &#123;        this.type = type;    &#125;&#125;</code></pre><p>PlayerType 就相当于 Player 的内部类，isBasketballPlayer() 方法用来判断运动员是否是一个篮球运动员。<br>由于枚举是 final 的，可以确保在 Java 虚拟机中仅有一个常量对象（可以参照反编译后的静态代码块「static 关键字带大括号的那部分代码」），所以我们可以很安全地使用“&#x3D;&#x3D;”运算符来比较两个枚举是否相等，参照 isBasketballPlayer() 方法。<br>那为什么不使用 equals() 方法判断呢？</p><pre><code class="line-numbers language-Java">if(player.getType().equals(Player.PlayerType.BASKETBALL))&#123;&#125;;if(player.getType() == Player.PlayerType.BASKETBALL)&#123;&#125;;</code></pre><p>“&#x3D;&#x3D;”运算符比较的时候，如果两个对象都为 null，并不会发生 NullPointerException，而 equals() 方法则会。<br>另外， “&#x3D;&#x3D;”运算符会在编译时进行检查，如果两侧的类型不匹配，会提示错误，而 equals() 方法则不会。<br><img src="https://www.qyihe.xyz/images/post/10.51.jpg"></p><h2 id="02、枚举可用于-switch-语句"><a href="#02、枚举可用于-switch-语句" class="headerlink" title="02、枚举可用于 switch 语句"></a>02、枚举可用于 switch 语句</h2><p>这个我在之前的一篇我去的文章中详细地说明过了，感兴趣的小伙伴可以点击链接跳转过去看一下。</p><pre><code>switch (playerType) &#123;        case TENNIS:            return &quot;网球运动员费德勒&quot;;        case FOOTBALL:            return &quot;足球运动员C罗&quot;;        case BASKETBALL:            return &quot;篮球运动员詹姆斯&quot;;        case UNKNOWN:            throw new IllegalArgumentException(&quot;未知&quot;);        default:            throw new IllegalArgumentException(                    &quot;运动员类型: &quot; + playerType);&#125;</code></pre><h2 id="03、枚举可以有构造方法"><a href="#03、枚举可以有构造方法" class="headerlink" title="03、枚举可以有构造方法"></a>03、枚举可以有构造方法</h2><p>如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。</p><pre><code class="line-numbers language-Java">public enum PlayerType &#123;    TENNIS(&quot;网球&quot;),    FOOTBALL(&quot;足球&quot;),    BASKETBALL(&quot;篮球&quot;);    private String name;    PlayerType(String name) &#123;        this.name = name;    &#125;&#125;</code></pre><h2 id="04、EnumSet"><a href="#04、EnumSet" class="headerlink" title="04、EnumSet"></a>04、EnumSet</h2><p>EnumSet 是一个专门针对枚举类型的 Set 接口的实现类，它是处理枚举类型数据的一把利器，非常高效（内部实现是位向量，我也搞不懂）。<br>因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法：<br><img src="https://www.qyihe.xyz/images/post/10.52.jpg"><br>下面的示例中使用 noneOf() 创建了一个空的 PlayerType 的 EnumSet；使用 allOf() 创建了一个包含所有 PlayerType 的 EnumSet。</p><pre><code class="line-numbers language-Java">public class EnumSetTest &#123;    public enum PlayerType &#123;        TENNIS,        FOOTBALL,        BASKETBALL    &#125;    public static void main(String[] args) &#123;        EnumSet&lt;PlayerType&gt; enumSetNone = EnumSet.noneOf(PlayerType.class);        System.out.println(enumSetNone);        EnumSet&lt;PlayerType&gt; enumSetAll = EnumSet.allOf(PlayerType.class);        System.out.println(enumSetAll);    &#125;&#125;</code></pre><p>程序输出结果如下所示：</p><pre><code class="line-numbers language-Java">[][TENNIS, FOOTBALL, BASKETBALL]</code></pre><p>有了 EnumSet 后，就可以使用 Set 的一些方法了：<br><img src="https://www.qyihe.xyz/images/post/10.53.jpg"></p><h2 id="05、EnumMap"><a href="#05、EnumMap" class="headerlink" title="05、EnumMap"></a>05、EnumMap</h2><p>EnumMap 是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。<br>和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字：</p><pre><code class="line-numbers language-Java">EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);</code></pre><p>有了 EnumMap 对象后就可以使用 Map 的一些方法了：<br><img src="https://www.qyihe.xyz/images/post/10.54.jpg"><br>和 HashMap 的使用方法大致相同，来看下面的例子：</p><pre><code class="line-numbers language-Java">EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);enumMap.put(PlayerType.BASKETBALL,&quot;篮球运动员&quot;);enumMap.put(PlayerType.FOOTBALL,&quot;足球运动员&quot;);enumMap.put(PlayerType.TENNIS,&quot;网球运动员&quot;);System.out.println(enumMap);System.out.println(enumMap.get(PlayerType.BASKETBALL));System.out.println(enumMap.containsKey(PlayerType.BASKETBALL));System.out.println(enumMap.remove(PlayerType.BASKETBALL));</code></pre><p>程序输出结果如下所示：</p><pre><code class="line-numbers language-Java">&#123;TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员&#125;篮球运动员true篮球运动员</code></pre><h2 id="06、单例"><a href="#06、单例" class="headerlink" title="06、单例"></a>06、单例</h2><p>通常情况下，实现一个单例并非易事，不信，来看下面这段代码</p><pre><code class="line-numbers language-Java">public class Singleton &#123;      private volatile static Singleton singleton;     private Singleton ()&#123;&#125;      public static Singleton getSingleton() &#123;      if (singleton == null) &#123;        synchronized (Singleton.class) &#123;         if (singleton == null) &#123;              singleton = new Singleton();         &#125;          &#125;      &#125;      return singleton;      &#125;  &#125;</code></pre><p>但枚举的出现，让代码量减少到极致：</p><pre><code class="line-numbers language-Java">public enum EasySingleton&#123;    INSTANCE;&#125;</code></pre><p>完事了，真的超级短，有没有？枚举默认实现了 Serializable 接口，因此 Java 虚拟机可以保证该类为单例，这与传统的实现方式不大相同。传统方式中，我们必须确保单例在反序列化期间不能创建任何新实例。</p><h2 id="07、枚举可与数据库交互"><a href="#07、枚举可与数据库交互" class="headerlink" title="07、枚举可与数据库交互"></a>07、枚举可与数据库交互</h2><p>我们可以配合 Mybatis 将数据库字段转换为枚举类型。现在假设有一个数据库字段 check_type 的类型如下：</p><pre><code class="line-numbers language-Java">`check_type` int(1) DEFAULT NULL COMMENT &#39;检查类型（1：未通过、2：通过）&#39;,</code></pre><p>它对应的枚举类型为 CheckType，代码如下：</p><pre><code class="line-numbers language-Java">public enum CheckType &#123;    NO_PASS(0, &quot;未通过&quot;), PASS(1, &quot;通过&quot;);    private int key;    private String text;    private CheckType(int key, String text) &#123;        this.key = key;        this.text = text;    &#125;    public int getKey() &#123;        return key;    &#125;    public String getText() &#123;        return text;    &#125;    private static HashMap&lt;Integer,CheckType&gt; map = new HashMap&lt;Integer,CheckType&gt;();    static &#123;        for(CheckType d : CheckType.values())&#123;            map.put(d.key, d);        &#125;    &#125;        public static CheckType parse(Integer index) &#123;        if(map.containsKey(index))&#123;            return map.get(index);        &#125;        return null;    &#125;&#125;</code></pre><p>（1）CheckType 添加了构造方法，还有两个字段，key 为 int 型，text 为 String 型。<br>（2）CheckType 中有一个public static CheckType parse(Integer index)方法，可将一个 Integer 通过 key 的匹配转化为枚举类型。<br>那么现在，我们可以在 Mybatis 的配置文件中使用 typeHandler 将数据库字段转化为枚举类型。</p><pre><code class="line-numbers language-Java">&lt;resultMap id=&quot;CheckLog&quot; type=&quot;com.entity.CheckLog&quot;&gt;  &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;  &lt;result property=&quot;checkType&quot; column=&quot;check_type&quot; typeHandler=&quot;com.CheckTypeHandler&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;</code></pre><p>其中 checkType 字段对应的类如下：</p><pre><code class="line-numbers language-Java">public class CheckLog implements Serializable &#123;    private String id;    private CheckType checkType;    public String getId() &#123;        return id;    &#125;    public void setId(String id) &#123;        this.id = id;    &#125;    public CheckType getCheckType() &#123;        return checkType;    &#125;    public void setCheckType(CheckType checkType) &#123;        this.checkType = checkType;    &#125;&#125;</code></pre><p>CheckTypeHandler 转换器的类源码如下：</p><pre><code class="line-numbers language-Java">public class CheckTypeHandler extends BaseTypeHandler&lt;CheckType&gt; &#123;    @Override    public CheckType getNullableResult(ResultSet rs, String index) throws SQLException &#123;        return CheckType.parse(rs.getInt(index));    &#125;    @Override    public CheckType getNullableResult(ResultSet rs, int index) throws SQLException &#123;        return CheckType.parse(rs.getInt(index));    &#125;    @Override    public CheckType getNullableResult(CallableStatement cs, int index) throws SQLException &#123;        return CheckType.parse(cs.getInt(index));    &#125;    @Override    public void setNonNullParameter(PreparedStatement ps, int index, CheckType val, JdbcType arg3) throws SQLException &#123;        ps.setInt(index, val.getKey());    &#125;&#125;</code></pre><p>CheckTypeHandler 的核心功能就是调用 CheckType 枚举类的 parse() 方法对数据库字段进行转换。<br><img src="https://www.qyihe.xyz/images/post/10.55.jpg"><br>恕我直言，我觉得小伙伴们肯定会用 Java 枚举了，如果还不会，就过来砍我！</p><h1 id="十七、final-关键字"><a href="#十七、final-关键字" class="headerlink" title="十七、final 关键字"></a>十七、final 关键字</h1><p>尽管继承可以让我们重用现有代码，但有时处于某些原因，我们确实需要对可扩展性进行限制，final 关键字可以帮助我们做到这一点。</p><h2 id="01、final-类"><a href="#01、final-类" class="headerlink" title="01、final 类"></a>01、final 类</h2><p>如果一个类使用了 final 关键字修饰，那么它就无法被继承。如果小伙伴们细心观察的话，Java 就有不少 final 类，比如说最常见的 String 类。</p><pre><code class="line-numbers language-Java">public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence,               Constable, ConstantDesc &#123;&#125;</code></pre><p>为什么 String 类要设计成 final 的呢？原因大致有以下三个：</p><ul><li>为了实现字符串常量池</li><li>为了线程安全</li><li>为了 HashCode 的不可变性</li></ul><p>更详细的原因，可以查看我之前写的一篇文章。<br>任何尝试从 final 类继承的行为将会引发编译错误，为了验证这一点，我们来看下面这个例子，Writer 类是 final 的。</p><pre><code class="line-numbers language-Java">public final class Writer &#123;    private String name;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;</code></pre><p>尝试去继承它，编译器会提示以下错误，Writer 类是 final 的，无法继承。<br><img src="https://www.qyihe.xyz/images/post/10.56.jpg"><br>不过，类是 final 的，并不意味着该类的对象是不可变的。</p><pre><code class="line-numbers language-Java">Writer writer = new Writer();writer.setName(&quot;沉默王二&quot;);System.out.println(writer.getName()); // 沉默王二</code></pre><p>Writer 的 name 字段的默认值是 null，但可以通过 settter 方法将其更改为“沉默王二”。也就是说，如果一个类只是 final 的，那么它并不是不可变的全部条件。<br>如果，你想了解不可变类的全部真相，请查看我之前写的文章这次要说不明白immutable类，我就怎么地。突然发现，写系列文章真的妙啊，很多相关性的概念全部涉及到了。我真服了自己了。<br>把一个类设计成 final 的，有其安全方面的考虑，但不应该故意为之，因为把一个类定义成 final 的，意味着它没办法继承，假如这个类的一些方法存在一些问题的话，我们就无法通过重写的方式去修复它。<br><img src="https://www.qyihe.xyz/images/post/10.57.jpg"></p><h2 id="02、final-方法"><a href="#02、final-方法" class="headerlink" title="02、final 方法"></a>02、final 方法</h2><p>被 final 修饰的方法不能被重写。如果我们在设计一个类的时候，认为某些方法不应该被重写，就应该把它设计成 final 的。<br>Thread 类就是一个例子，它本身不是 final 的，这意味着我们可以扩展它，但它的 isAlive() 方法是 final 的：</p><pre><code class="line-numbers language-Java">public class Thread implements Runnable &#123;    public final native boolean isAlive();&#125;</code></pre><p>需要注意的是，该方法是一个本地（native）方法，用于确认线程是否处于活跃状态。而本地方法是由操作系统决定的，因此重写该方法并不容易实现。<br>Actor 类有一个 final 方法 show()：</p><pre><code class="line-numbers language-Java">public class Actor &#123;    public final void show() &#123;            &#125;&#125;</code></pre><p>当我们想要重写该方法的话，就会出现编译错误：<br><img src="https://www.qyihe.xyz/images/post/10.58.jpg"><br>如果一个类中的某些方法要被其他方法调用，则应考虑事被调用的方法称为 final 方法，否则，重写该方法会影响到调用方法的使用。<br>一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？<br>我能想到的一点，就是前者不能被继承，也就是说方法无法被重写；后者呢，可以被继承，然后追加一些非 final 的方法。没毛病吧？看把我聪明的。<br><img src="https://www.qyihe.xyz/images/post/10.59.jpg"></p><h2 id="03、final-变量"><a href="#03、final-变量" class="headerlink" title="03、final 变量"></a>03、final 变量</h2><p>被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。之前被一个小伙伴问过，什么是 effective final，什么是 final，这一点，我在之前的文章也有阐述过，所以这里再贴一下地址：</p><pre><code class="line-numbers language-Java">www.itwanger.com/java/2020/0…</code></pre><p>（1）final 修饰的基本数据类型<br>来声明一个 final 修饰的 int 类型的变量：</p><pre><code class="line-numbers language-Java">final int age = 18;</code></pre><p>尝试将它修改为 30，结果编译器生气了：<br><img src="https://www.qyihe.xyz/images/post/10.60.jpg"><br>（2）final 修饰的引用类型<br>现在有一个普通的类 Pig，它有一个字段 name：</p><pre><code class="line-numbers language-Java">public class Pig &#123;   private String name;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;</code></pre><p>在测试类中声明一个 final 修饰的 Pig 对象：<br> final Pig pig &#x3D; new Pig();<br>如果尝试将 pig 重新赋值的话，编译器同样会生气：<br><img src="https://www.qyihe.xyz/images/post/10.61.jpg"><br>但我们仍然可以去修改 Pig 的字段值：</p><pre><code class="line-numbers language-Java">final Pig pig = new Pig();pig.setName(&quot;特立独行&quot;);System.out.println(pig.getName()); // 特立独行</code></pre><p>（3）final 修饰的字段<br>final 修饰的字段可以分为两种，一种是 static 的，另外一种是没有 static 的，就像下面这样：</p><pre><code class="line-numbers language-Java">public class Pig &#123;   private final int age = 1;   public static final double PRICE = 36.5;&#125;</code></pre><p>非 static 的 final 字段必须有一个默认值，否则编译器将会提醒没有初始化：<br><img src="https://www.qyihe.xyz/images/post/10.62.jpg"><br>static 的 final 字段也叫常量，它的名字应该为大写，可以在声明的时候初始化，也可以通过 static 代码块初始化。</p><p>(4) final 修饰的参数</p><p>final 关键字还可以修饰参数，它意味着参数在方法体内不能被再修改：</p><pre><code class="line-numbers language-Java">public class ArgFinalTest &#123;    public void arg(final int age) &#123;    &#125;    public void arg1(final String name) &#123;    &#125;&#125;</code></pre><p>如果尝试去修改它的话，编译器会提示以下错误：<br><img src="https://www.qyihe.xyz/images/post/10.63.jpg"><br>。。。。。。</p><blockquote><p>转载于<a href="https://juejin.im/post/5ee414c76fb9a047dd2768ea#heading-39">沉默王二</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《解忧杂货店》读后感</title>
      <link href="/posts/5700/"/>
      <url>/posts/5700/</url>
      
        <content type="html"><![CDATA[<h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p><img src="https://cdn.isqqq.com/Blog/posts/5700/1.webp"><br>《解忧杂货店》是日本作家东野圭吾写作的长篇小说。2011年于《小说野性时代》连载，于2012年3月由角川书店发行单行本。</p><p>该书讲述了在僻静街道旁的一家杂货店，只要写下烦恼投进店前门卷帘门的投信口，第二天就会在店后的牛奶箱里得到回答：因男友身患绝症，年轻女孩月兔在爱情与梦想间徘徊；松冈克郎为了音乐梦想离家漂泊，却在现实中寸步难行；少年浩介面临家庭巨变，挣扎在亲情与未来的迷茫中……他们将困惑写成信投进杂货店，奇妙的事情随即不断发生。</p><p>该书获得第七届中央公论文艺奖、苹果日报翻译小说销售排行榜连续两季第二名，荣登纪伊国屋、诚品、博客来、金石堂各大排行榜第1名，亚马逊中国2015年度畅销图书榜第二。</p><p>同名华语电影于2017年上映。2017年12月15日，亚马逊中国发布基于亚马逊阅读大数据产生的一系列年度阅读榜单。其中，东野圭吾的《解忧杂货店》连续4年上榜，又一次成为2017年亚马逊最畅销图书。</p><h1 id="读后感："><a href="#读后感：" class="headerlink" title="读后感："></a>读后感：</h1><p>故事开头，三个无业青年盗窃因车抛锚，在天亮之前暂避到废弃的杂货店里，无意中在店里的牛奶箱里接到了一封来自于过去的咨询信。<br>原来这个杂货店在三十多年前，是一家帮人解决烦恼的杂货店，晚年丧偶的店主通过回复一封封求助的来信，重新找到了被需要的感觉。因缘际会，店主去世之后的来信，就这样来到了他们的手中。而那种被人信任和需要的感觉，是他们在很久以来都没有感受过的。<br>因此，他们开始以‘浪矢杂货店’的名义给人回信——尽管错别字很多，语气也很粗鲁不文，但是他们也像浪矢爷爷一样真心对待这些信，一封封来自过去的困惑，迷茫，通过牛奶箱来到了现在，不知不觉的，这些信改变了过去那些人的人生，也改变了信箱这头三个青年的人生。</p><p>东野圭吾采用了截然不同的角度来分别讲述这四个故事，分开看独立成章，连起来又对情节起到了层层推进的作用。四个故事中出现的人物，都隐隐的和”浪矢杂货店”以及孤儿院”丸光园”有着千丝万缕的联系，其间每个人不经意的选择和行为，都像投入水面的石子一样，造成了持续不断的涟漪，这些涟漪不断扩大，渐渐形成了牢不可破的羁绊，过去未来终于交汇。</p><p>浪矢爷爷曾经和他的儿子说，“很多时候，咨询的人心里已经有了答案，来咨询只是想确认自己的决定是对的。”他们只是迷途的羔羊，手中都有地图，却没有去看，或是不知道自己的位置，所以回信的人只要点出他们的羁绊所在，他们就知道该如何走下去。但是敦也他们三人则是一张白纸，因为没有羁绊，所以即使想决定目的地，也不知道路在哪里。</p><p>“地图是一张白纸，这当然很伤脑筋，任何人都会不知所措。可是换个角度来看，正因为是一张白纸，才可以随心所欲地描绘地图。一切全在你自己，一切都是自由的，在你面前是无限的可能。”这是浪矢爷爷最后回复的一封咨询信，是给未来这三位接班人的信。经由这封信，他们也终于理清了自己身上隐形的羁绊，并且心甘情愿地背负起这甜蜜的负担——为所有需要自己的、相信自己的人去努力，如果没有的话，那么就要努力证明自己来获得别人的认可，变成会令别人需要和相信的存在，这是他们所选择的路，也是我们应该去走的路。</p>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java循环</title>
      <link href="/posts/55803/"/>
      <url>/posts/55803/</url>
      
        <content type="html"><![CDATA[<h1 id="循环的定义："><a href="#循环的定义：" class="headerlink" title="循环的定义："></a>循环的定义：</h1><p>利用计算机来执行多次重复的操作</p><h1 id="循环的分类："><a href="#循环的分类：" class="headerlink" title="循环的分类："></a>循环的分类：</h1><h2 id="for循环："><a href="#for循环：" class="headerlink" title="for循环："></a>for循环：</h2><p>for(初始A;条件判断B;循环操作C){<br>&#x2F;&#x2F;循环体D<br>}<br>for循环执行流程：<br>第一次： A&gt;B(true)&gt;D&gt;C<br>第二次： B(true)&gt;D&gt;C<br>第三次： B(true)&gt;D&gt;C<br>…<br>第n次: B(false) 结束整个循环<br>比如：</p><pre><code class="line-numbers language-Java">for(int i = 0;i&lt;10;i++)&#123;​     System.out.println(&quot;Hello World&quot;);&#125;</code></pre><h2 id="while循环："><a href="#while循环：" class="headerlink" title="while循环："></a>while循环：</h2><p>while(条件表达式（布尔类型）){<br>&#x2F;&#x2F;条件满足执行<br>}<br>比如：</p><pre><code class="line-numbers language-Java">int i = 0;while(i &lt; 10)&#123;  System.out.println(&quot;Hello World&quot;);  i++;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java equals和==的区别</title>
      <link href="/posts/65180/"/>
      <url>/posts/65180/</url>
      
        <content type="html"><![CDATA[<h1 id="x3D-x3D"><a href="#x3D-x3D" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h1><p>&#x3D;&#x3D;不要和&#x3D;搞混了,&#x3D;是一个赋值<br>而&#x3D;&#x3D;是一个比较运算符，基本数据类型比较的是值，引用数据类型比较的值是地址值。<br>这个运算符的两边如果都是基本数据类型,判断的是基本数据类型的值是否相等<br>比如:</p><pre><code class="line-numbers language-Java">int i=1;int n=1;System.out.println(i==j);//返回值为true</code></pre><h1 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h1><p>equals()是一个方法，只能比较引用数据类型。重写前比较的是地址值，重写后比一般是比较对象的属性。<br>如果没有重写equals方法,就是继承自Object的equals方法,Object类中的equals方法判断的是地址<br>判断String类型的数据除外,Object类中的equals方法在判断String类型数据时,判断的是内容</p><pre><code class="line-numbers language-Java">public boolean equals(Object anObject) &#123;        if (this == anObject) &#123;            return true;        &#125;        if (anObject instanceof String) &#123;            String anotherString = (String)anObject;            int n = value.length;            if (n == anotherString.value.length) &#123;                char v1[] = value;                char v2[] = anotherString.value;                int i = 0;                while (n-- != 0) &#123;                    if (v1[i] != v2[i])                        return false;                    i++;                &#125;                return true;            &#125;        &#125;        return false;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你想清楚了吗</title>
      <link href="/posts/39064/"/>
      <url>/posts/39064/</url>
      
        <content type="html"><![CDATA[<p>所以，想清楚了吗？<br>怀疑的就再想清楚，<br>想清楚了就别再犹豫。</p><p>到底你，<br>是怎样的你。<br>你想要的是什么，</p><p>然后，<br>给自己多一点信心，<br>对自己多一点尊重。<br>相信自己所做的决择。</p><p>因为你，<br>得决定你想要什么，<br>不要让别人带给你的想象<br>左右你的目标。</p><p>让自己，<br>为自己而活，为值得的而活，<br>别再为别人所得到所拥有，<br>而自己没必要的一切而烦恼。</p>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进制转换</title>
      <link href="/posts/55041/"/>
      <url>/posts/55041/</url>
      
        <content type="html"><![CDATA[<h1 id="进制区分"><a href="#进制区分" class="headerlink" title="进制区分"></a>进制区分</h1><table><thead><tr><th>进制</th><th>组成</th><th>例如</th></tr></thead><tbody><tr><td>2进制</td><td>只有0和1组成</td><td>101010</td></tr><tr><td>8进制</td><td>以0开头,0~7组成</td><td>01234</td></tr><tr><td>10进制</td><td>以1<del>9开头,0</del>9组成</td><td>100</td></tr><tr><td>16进制</td><td>以0X开头,0<del>9或者a</del>f组成</td><td>0x12c</td></tr></tbody></table><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><h4 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h4><p>十进制数除2取余法即十进制数除2，余数为权位上的数，得到的商值继续除2，依此步骤继续向下运算直到商为0为止。</p><h4 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h4><p>把二进制数按权展开,相加即得十进制数。</p><h4 id="二进制转八进制"><a href="#二进制转八进制" class="headerlink" title="二进制转八进制"></a>二进制转八进制</h4><p>3位二进制数按权展开相加得到1位八进制数,（注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。</p><p>####八进制转成二进制</p><p>八进制数通过除2取余法，得到二进制数，对每个八进制为3个二进制，不足时在最左边补零。</p><h4 id="二进制转十六进制"><a href="#二进制转十六进制" class="headerlink" title="二进制转十六进制"></a>二进制转十六进制</h4><p>与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。（注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）</p><h4 id="十进制与八进制与十六进制之间的转换"><a href="#十进制与八进制与十六进制之间的转换" class="headerlink" title="十进制与八进制与十六进制之间的转换"></a>十进制与八进制与十六进制之间的转换</h4><h3 id="十进制转八进制或者十六进制有两种方法"><a href="#十进制转八进制或者十六进制有两种方法" class="headerlink" title="十进制转八进制或者十六进制有两种方法"></a>十进制转八进制或者十六进制有两种方法</h3><p>2：间接法—把十进制转成二进制，然后再由二进制转成八进制或者十六进制。这里不再做图片用法解释。</p><p>1：把十进制转八进制或者十六进制按照除8或者16取余，直到商为0为止。</p><h2 id="八进制或者十六进制转成十进制"><a href="#八进制或者十六进制转成十进制" class="headerlink" title="八进制或者十六进制转成十进制"></a>八进制或者十六进制转成十进制</h2><p>把八进制、十六进制数按权展开、相加即得十进制数。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
            <tag> 进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github初始化配置</title>
      <link href="/posts/5440/"/>
      <url>/posts/5440/</url>
      
        <content type="html"><![CDATA[<h3 id="初次安装-git-配置用户名和邮箱"><a href="#初次安装-git-配置用户名和邮箱" class="headerlink" title="初次安装 git 配置用户名和邮箱"></a>初次安装 git 配置用户名和邮箱</h3><pre><code class="line-numbers language-git">git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx@qq.com&quot;</code></pre><h2 id="git-使用-ssh-密钥"><a href="#git-使用-ssh-密钥" class="headerlink" title="git 使用 ssh 密钥"></a>git 使用 ssh 密钥</h2><p>git 支持 https 和 git 两种传输协议，GitHub 分享链接时会有两种协议可选。</p><ul><li>使用 https 协议，每次 pull、push 都会提示要输入密码</li><li>使用 git 协议，然后使用 ssh 密钥，这样免去每次都输密码的麻烦<br>初次使用 git 的用户要使用 git 协议大概需要三个步骤</li></ul><h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3><p>大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。</p><pre><code class="line-numbers language-git">cd ~/.sshls</code></pre><p>看一下有没有 id_rsa 和 id_rsa.pub(或者是 id_dsa 和 id_dsa.pub 之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。</p><p>假如没有这些文件，甚至连.ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux&#x2F;Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：</p><pre><code class="line-numbers language-git">ssh-keygen -t rsa -C &lt;xxx@qq.com&gt;Creates a new ssh key using the provided email \# Generating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa):</code></pre><p>按Enter,然后，会提示你输入密码，如下 (建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)：</p><pre><code class="line-numbers language-git">Enter same passphrase again: [Type passphrase again]</code></pre><p>到此为止，你本地的密钥对就生成了。</p><h4 id="添加公钥到你的远程仓库（GitHub）"><a href="#添加公钥到你的远程仓库（GitHub）" class="headerlink" title="添加公钥到你的远程仓库（GitHub）"></a>添加公钥到你的远程仓库（GitHub）</h4><pre><code class="line-numbers language-git">cat ~/.ssh/id_rsa.pubssh-rsa xxx admin\@admin-PC</code></pre><h5 id="SSH-Key"><a href="#SSH-Key" class="headerlink" title="SSH Key"></a>SSH Key</h5><p>登陆你的 GitHub 帐户，点击你的头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key -&gt; 然后你复制上面的公钥内容（上面全部），粘贴进“Key”文本域内。title域，自己随便起个名字。 -&gt; 点击 Add key。</p><h6 id="验证-key"><a href="#验证-key" class="headerlink" title="验证 key"></a>验证 key</h6><pre><code class="line-numbers language-git">ssh -T &lt;git@github.com&gt;Hi xxx! You&#39;ve successfully authenticated, but GitHub does not \# provide shellaccess.</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数据类型</title>
      <link href="/posts/188331/"/>
      <url>/posts/188331/</url>
      
        <content type="html"><![CDATA[<p>Java是一种强类型语言，每个变量都必须声明其类型。<br>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。<br>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。<br>变量在使用前必须对其声明, 只有在变量声明以后，才能为其分配相应长度的存储单元,声明格式为： </p><pre><code class="line-numbers language-Java">String name = “Java”,int num = 12;</code></pre><h3 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h3><h3 id="整数型："><a href="#整数型：" class="headerlink" title="整数型："></a>整数型：</h3><p>byte：<br>byte 数据类型是8位、有符号的，以二进制补码表示的整数；<br>最小值是 -128（-2^7）；<br>最大值是 127（2^7-1）；<br>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；<br>例子：byte a &#x3D; 12，byte b &#x3D; -12。</p><h3 id="short："><a href="#short：" class="headerlink" title="short："></a>short：</h3><p>short 数据类型是 16 位、有符号的以二进制补码表示的整数<br>最小值是 -32768（-2^15）；<br>最大值是 32767（2^15 - 1）；<br>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；<br>例子：short s &#x3D; 10000，short r &#x3D; -10000。</p><h3 id="int："><a href="#int：" class="headerlink" title="int："></a>int：</h3><p>int 数据类型是32位、有符号的以二进制补码表示的整数；<br>最小值是 -2,147,483,648（-2^31）；<br>最大值是 2,147,483,647（2^31 - 1）；<br>一般地整型变量默认为 int 类型；<br>例子：int a &#x3D; 10000, int b &#x3D; -20000。</p><h3 id="long："><a href="#long：" class="headerlink" title="long："></a>long：</h3><p>long 数据类型是 64 位、有符号的以二进制补码表示的整数；<br>最小值是 -9,223,372,036,854,775,808（-2^63）；<br>最大值是 9,223,372,036,854,775,807（2^63 -1）；<br>这种类型主要使用在需要比较大整数的系统上；<br>例子： long a &#x3D; 100000L，Long b &#x3D; -100000L。<br>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><h3 id="float："><a href="#float：" class="headerlink" title="float："></a>float：</h3><p>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；<br>float 在储存大型浮点数组的时候可节省内存空间；<br>浮点数不能用来表示精确的值，如货币；<br>例子：float f1 &#x3D; 123.4f。</p><h3 id="double："><a href="#double：" class="headerlink" title="double："></a>double：</h3><p>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；<br>浮点数的默认类型为double类型；<br>double类型同样不能表示精确的值，如货币；<br>例子：double d1 &#x3D; 123.4。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h3 id="char："><a href="#char：" class="headerlink" title="char："></a>char：</h3><p>char类型是一个单一的 16 位 Unicode 字符；<br>最小值是 \u0000（即为0）；<br>最大值是 \uffff（即为65,535）；<br>char 数据类型可以储存任何字符；<br>例子：char letter &#x3D; ‘C’;。</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><h3 id="boolean："><a href="#boolean：" class="headerlink" title="boolean："></a>boolean：</h3><p>boolean数据类型表示一位的信息；<br>只有两个取值：true 和 false；<br>这种类型只作为一种标志来记录 true&#x2F;false 情况；<br>默认值是 false；<br>例子：boolean one &#x3D; true。</p><h3 id="内存中占据的存储大小："><a href="#内存中占据的存储大小：" class="headerlink" title="内存中占据的存储大小："></a>内存中占据的存储大小：</h3><p><img src="https://i.loli.net/2020/06/03/yPIv9wcZ4MqGphk.png" alt="Java"><br>整数类型：<br>byte&lt;short&lt;int&lt;long<br>浮点型：<br>float&lt;double<br>引用类型：<br>char<br>布尔型 ：<br>boolean</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<h1 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h1><p>Welcome to <a href="https://isqqq.com/">乔一禾</a>! 这是一个记录学习笔记和分享奇奇怪怪的地方！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
